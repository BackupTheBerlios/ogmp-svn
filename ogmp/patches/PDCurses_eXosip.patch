Index: PDCurses/panel/panel.c
===================================================================
--- PDCurses/panel/panel.c	(revision 1)
+++ PDCurses/panel/panel.c	(working copy)
@@ -1,1003 +1,1003 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include <panel.h>
-
-#ifdef UNIX
-#include <defs.h>
-#include <term.h>
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_panel = "$Id: panel.c,v 1.2 2001/01/10 08:28:01 mark Exp $";
-#endif
-
-
-/*man-start*********************************************************************
-
-  panels	- panel package for curses
-
-  PDCurses Description:
- 	The panel library is built using the curses library and any program
- 	using panels routines must call one of the curses initialization
- 	routines such as initscr(). A program using these routines must be
- 	linked with the panels and curses libraries.
-
- 	The panels package gives the applications programmer a way to have
- 	depth relationships between curses windows; a curses window is
- 	associated with every panel. The panels routines allow curses windows
- 	to overlap without making visible the overlapped portions of 
- 	underlying windows. The initial curses window, stdscr, lies beneath
- 	all panels. The set of currently visible panels is the 'deck' of
- 	panels.
-
- 	The panels package allows the applications programmer to create
- 	panels, fetch and set their associated windows, shuffle panels in 
- 	the deck, and manipulate panels in other ways.
-
-  PDCurses Return Value:
- 	Each panels routine that returns a pointer to an object returns NULL
- 	if an error occurs. Each panel routine that returns an integer, 
- 	returns OK if it executes successfully and ERR if it does not.
-
-  Notes
- 	The header <panel.h> includes the header <curses.h>.
-
-  Credits
- 	Original Author - Warren Tucker N4HGF
- 	{gatech,emory}!n4hgf!wht -or- wht@n4hgf.Mt-Park.GA.US
-
-**man-end**********************************************************************/
-
-
-/*
-  Defined functions:
-	int bottom_panel(PANEL *pan);
-	int del_panel(PANEL *pan);
-	int hide_panel(PANEL *pan);
-	int move_panel(PANEL *pan,int starty,int startx);
-	PANEL *new_panel(WINDOW *win);
-	PANEL *panel_above(PANEL *pan);
-	PANEL *panel_below(PANEL *pan);
-	int panel_hidden(PANEL *pan);
-	char *panel_userptr(PANEL *pan);
-	WINDOW *panel_window(PANEL *pan);
-	int replace_panel(PANEL *pan,WINDOW *win);
-	int set_panel_userptr(PANEL *pan,char *uptr);
-	int show_panel(PANEL *pan);
-	int top_panel(PANEL *pan);
-	void update_panels(void);
-
-	Touchline(pan,start,count)
-	Touchpan(pan)
-	Wnoutrefresh(pan)
-	__calculate_obscure()
-	__free_obscure(pan)
-	__override(pan,show)
-	__panel_is_linked(pan)
-	__panel_link_bottom(pan)
-	__panel_link_top(pan)
-	__panel_unlink(pan)
-	__panels_overlapped(pan1,pan2)
-	dPanel(text,pan)
-	dStack(fmt,num,pan)
-	open_dfp()
-
---------------------------------------------------------------------------*/
-PANEL *__bottom_panel = (PANEL *)0;
-PANEL *__top_panel = (PANEL *)0;
-PANEL __stdscr_pseudo_panel = { (WINDOW *)0 };
-
-#define STATIC static
-
-/*+-------------------------------------------------------------------------
-	dPanel(text,pan)
---------------------------------------------------------------------------*/
-#ifdef PANEL_DEBUG
-dPanel(text,pan)
-char *text;
-PANEL *pan;
-{
-	_tracef("%s id=%s b=%s a=%s y=%d x=%d",
-		text,pan->user,
-		(pan->below) ? pan->below->user : "--",
-		(pan->above) ? pan->above->user : "--",
-		pan->wstarty, pan->wstartx);
-}	/* end of dPanel */
-#else
-#define dPanel(text,pan)
-#endif
-
-/*+-------------------------------------------------------------------------
-	dStack(fmt,num,pan)
---------------------------------------------------------------------------*/
-#ifdef PANEL_DEBUG
-void
-dStack(fmt,num,pan)
-char *fmt;
-int num;
-PANEL *pan;
-{
-char s80[80];
-
-	sprintf(s80,fmt,num,pan);
-	_tracef("%s b=%s t=%s",s80,
-		(__bottom_panel) ? __bottom_panel->user : "--",
-		(__top_panel)    ? __top_panel->user    : "--");
-	if(pan)
-		_tracef("pan id=%s",pan->user);
-	pan = __bottom_panel;
-	while(pan)
-	{
-		dPanel("stk",pan);
-		pan = pan->above;
-	}
-}	/* end of dStack */
-#else
-#define dStack(fmt,num,pan)
-#endif
-
-/*+-------------------------------------------------------------------------
-	Wnoutrefresh(pan) - debugging hook for wnoutrefresh
---------------------------------------------------------------------------*/
-#ifdef PANEL_DEBUG
-STATIC int
-Wnoutrefresh(pan)
-PANEL *pan;
-{
-	dPanel("wnoutrefresh",pan);
-	wnoutrefresh(pan->win);
-}	/* end of Wnoutrefresh */
-#else
-#define Wnoutrefresh(pan) wnoutrefresh((pan)->win)
-#endif
-
-/*+-------------------------------------------------------------------------
-	Touchpan(pan)
---------------------------------------------------------------------------*/
-#ifdef PANEL_DEBUG
-STATIC int
-Touchpan(pan)
-PANEL *pan;
-{
-	dPanel("Touchpan",pan);
-	touchwin(pan->win);
-}	/* end of Touchpan */
-#else
-#define Touchpan(pan) touchwin((pan)->win)
-#endif
-
-/*+-------------------------------------------------------------------------
-	Touchline(pan,start,count)
---------------------------------------------------------------------------*/
-#ifdef PANEL_DEBUG
-STATIC int
-Touchline(pan,start,count)
-PANEL *pan;
-int start;
-int count;
-{
-char s80[80];
-	sprintf(s80,"Touchline s=%d c=%d",start,count);
-	dPanel(s80,pan);
-	touchline(pan->win,start,count);
-}	/* end of Touchline */
-#else
-#define Touchline(pan,start,count) touchline((pan)->win,start,count)
-#endif
-
-/*+-------------------------------------------------------------------------
-	__panels_overlapped(pan1,pan2) - check panel overlapped
---------------------------------------------------------------------------*/
-STATIC int
-__panels_overlapped(pan1,pan2)
-register PANEL *pan1;
-register PANEL *pan2;
-{
-	if(!pan1 || !pan2)
-		return(0);
-	return((pan1->wstarty >= pan2->wstarty && pan1->wstarty < pan2->wendy) ||
-		(pan2->wstarty >= pan1->wstarty && pan2->wstarty < pan1->wendy))
-	&& ((pan1->wstartx >= pan2->wstartx && pan1->wstartx < pan2->wendx) ||
-		(pan2->wstartx >= pan1->wstartx && pan2->wstartx < pan1->wendx));
-}	/* end of __panels_overlapped */
-
-/*+-------------------------------------------------------------------------
-	__free_obscure(pan)
---------------------------------------------------------------------------*/
-STATIC void
-__free_obscure(pan)
-PANEL *pan;
-{
-PANELOBS *tobs = pan->obscure;				/* "this" one */
-PANELOBS *nobs;								/* "next" one */
-
-	while(tobs)
-	{
-		nobs = tobs->above;
-		free((char *)tobs);
-		tobs = nobs;
-	}
-	pan->obscure = (PANELOBS *)0;
-}	/* end of __free_obscure */
-
-/*+-------------------------------------------------------------------------
-	__override(pan,show)
---------------------------------------------------------------------------*/
-STATIC void
-__override(pan,show)
-PANEL *pan;
-int show;
-{
-register int y;
-register PANEL *pan2;
-PANELOBS *tobs = pan->obscure;				/* "this" one */
-
-
-	if(show == 1)
-		Touchpan(pan);
-	else if(!show)
-	{
-		Touchpan(pan);
-/*
-		Touchline(&__stdscr_pseudo_panel,pan->wendy,getmaxy(pan->win));
-*/
-		Touchpan(&__stdscr_pseudo_panel);
-	}
-	else if(show == -1)
-	{
-		while(tobs && (tobs->pan != pan))
-			tobs = tobs->above;
-	}
-
-	while(tobs)
-	{
-		if((pan2 = tobs->pan) != pan)
-		{
-			for(y = pan->wstarty; y < pan->wendy; y++)
-			{
-				if( (y >= pan2->wstarty) && (y < pan2->wendy) &&
-					((is_linetouched(pan->win,y - pan->wstarty)) ||
-					(is_linetouched(stdscr,y))))
-				{
-					Touchline(pan2,y - pan2->wstarty,1);
-				}
-			}
-		}
-		tobs = tobs->above;
-	}
-}	/* end of __override */
-
-/*+-------------------------------------------------------------------------
-	__calculate_obscure()
---------------------------------------------------------------------------*/
-STATIC void
-__calculate_obscure()
-{
-PANEL *pan;
-register PANEL *pan2;
-register PANELOBS *tobs;			/* "this" one */
-PANELOBS *lobs = (PANELOBS *)0;		/* last one */
-
-	pan = __bottom_panel;
-	while(pan)
-	{
-		if(pan->obscure)
-			__free_obscure(pan);
-		lobs = (PANELOBS *)0;		/* last one */
-		pan2 = __bottom_panel;
-		while(pan2)
-		{
-			if(__panels_overlapped(pan,pan2))
-			{
-				if(!(tobs = (PANELOBS *)malloc(sizeof(PANELOBS))))
-					return;
-				tobs->pan = pan2;
-				dPanel("obscured",pan2);
-				tobs->above = (PANELOBS *)0;
-				if(lobs)
-					lobs->above = tobs;
-				else
-					pan->obscure = tobs;
-				lobs  = tobs;
-			}
-			pan2 = pan2->above;
-		}
-		__override(pan,1);
-		pan = pan->above;
-	}
-
-}	/* end of __calculate_obscure */
-
-/*+-------------------------------------------------------------------------
-	__panel_is_linked(pan) - check to see if panel is in the stack
---------------------------------------------------------------------------*/
-STATIC int
-__panel_is_linked(pan)
-PANEL *pan;
-{
-register PANEL *pan2 = __bottom_panel;
-
-	while(pan2)
-	{
-		if(pan2 == pan)
-			return(1);
-		pan2 = pan2->above;
-	}
-	return(OK);
-}	/* end of __panel_is_linked */
-
-/*+-------------------------------------------------------------------------
-	__panel_link_top(pan) - link panel into stack at top
---------------------------------------------------------------------------*/
-STATIC void
-__panel_link_top(pan)
-PANEL *pan;
-{
-
-#ifdef PANEL_DEBUG
-	dStack("<lt%d>",1,pan);
-	if(__panel_is_linked(pan))
-		return;
-#endif
-
-	pan->above = (PANEL *)0;
-	pan->below = (PANEL *)0;
-	if(__top_panel)
-	{
-		__top_panel->above = pan;
-		pan->below = __top_panel;
-	}
-	__top_panel = pan;
-	if(!__bottom_panel)
-		__bottom_panel = pan;
-	__calculate_obscure();
-	dStack("<lt%d>",9,pan);
-
-}	/* end of __panel_link_top */
-
-/*+-------------------------------------------------------------------------
-	__panel_link_bottom(pan) - link panel into stack at bottom
---------------------------------------------------------------------------*/
-STATIC void
-__panel_link_bottom(pan)
-PANEL *pan;
-{
-
-#ifdef PANEL_DEBUG
-	dStack("<lb%d>",1,pan);
-	if(__panel_is_linked(pan))
-		return;
-#endif
-
-	pan->above = (PANEL *)0;
-	pan->below = (PANEL *)0;
-	if(__bottom_panel)
-	{
-		__bottom_panel->below = pan;
-		pan->above = __bottom_panel;
-	}
-	__bottom_panel = pan;
-	if(!__top_panel)
-		__top_panel = pan;
-	__calculate_obscure();
-	dStack("<lb%d>",9,pan);
-
-}	/* end of __panel_link_bottom */
-
-/*+-------------------------------------------------------------------------
-	__panel_unlink(pan) - unlink panel from stack
---------------------------------------------------------------------------*/
-STATIC void
-__panel_unlink(pan)
-PANEL *pan;
-{
-register PANEL *prev;
-register PANEL *next;
-
-#ifdef PANEL_DEBUG
-	dStack("<u%d>",1,pan);
-	if(!__panel_is_linked(pan))
-		return;
-#endif
-
-	__override(pan,0);
-	__free_obscure(pan);
-
-	prev = pan->below;
-	next = pan->above;
-
-	if(prev)		/* if non-zero, we will not update the list head */
-	{
-		prev->above = next;
-		if(next)
-			next->below = prev;
-	}
-	else if(next)
-		next->below = prev;
-	if(pan == __bottom_panel)
-		__bottom_panel = next;
-	if(pan == __top_panel)
-		__top_panel = prev;
-
-	__calculate_obscure();
-
-	pan->above = (PANEL *)0;
-	pan->below = (PANEL *)0;
-	dStack("<u%d>",9,pan);
-
-}	/* end of __panel_unlink */
-
-/**********************************************************************/
-/* The following are the public functions for the panels library.     */
-/**********************************************************************/
-
-/*man-start*********************************************************************
-
-  bottom_panel	- puts panel at bottom of deck
-
-  PDCurses Description:
- 	This function places pan at the bottom of the deck. The size, location
- 	and contents of the panel are unchanged.
-
-  PDCurses Return Value:
- 	Returns OK or ERR.
-
-  PDCurses Errors:
- 	Returns ERR if pan is NULL.
-
-  Portability:
- 	PDCurses	int bottom_panel( PANEL *pan );
- 	SYS V Curses	int bottom_panel( PANEL *pan );
-
-**man-end**********************************************************************/
-
-int
-bottom_panel(pan)
-register PANEL *pan;
-{
-	if(!pan)
-		return(ERR);
-	if(pan == __bottom_panel)
-		return(OK);
-	if(__panel_is_linked(pan))
-		(void)hide_panel(pan);
-	__panel_link_bottom(pan);
-	return(OK);
-}	/* end of bottom_panel */
-
-/*man-start*********************************************************************
-
-  del_panel	- deletes a panel
-
-  PDCurses Description:
- 	This function deletes pan but not its associated winwow.
-
-  PDCurses Return Value:
- 	Returns OK or ERR.
-
-  PDCurses Errors:
- 	Returns ERR if pan is NULL.
-
-  Portability:
- 	PDCurses	int del_panel( PANEL *pan );
- 	SYS V Curses	int del_panel( PANEL *pan );
-
-**man-end**********************************************************************/
-
-int
-del_panel(pan)
-register PANEL *pan;
-{
-	if(pan)
-	{
-		if(__panel_is_linked(pan))
-			(void)hide_panel(pan);
-		free((char *)pan);
-		return(OK);
-	}
-	return(ERR);
-}	/* end of del_panel */
-
-/*man-start*********************************************************************
-
-  hide_panel	- removes a panel from the deck
-
-  PDCurses Description:
- 	This function removes a panel from the deck and thus hides it from
- 	view.
-
-  PDCurses Return Value:
- 	Returns OK or ERR.
-
-  PDCurses Errors:
- 	Returns ERR if pan is NULL.
-
-  Portability:
- 	PDCurses	int hide_panel( PANEL *pan );
- 	SYS V Curses	int hide_panel( PANEL *pan );
-
-**man-end**********************************************************************/
-
-int
-hide_panel(pan)
-register PANEL *pan;
-{
-
-	if(!pan)
-		return(ERR);
-
-	if(!__panel_is_linked(pan))
-	{
-		pan->above = (PANEL *)0;
-		pan->below = (PANEL *)0;
-		return(ERR);
-	}
-
-	__panel_unlink(pan);
-
-	return(OK);
-}	/* end of hide_panel */
-
-/*man-start*********************************************************************
-
-  move_panel	- move a window on the virtual screen
-
-  PDCurses Description:
- 	This function move the curses window associated with pan so that
- 	its upper lefthand corner is at the supplied coordinates. Do not
- 	use mvwin() on the window.
-
-  PDCurses Return Value:
- 	Returns OK or ERR.
-
-  PDCurses Errors:
- 	Returns ERR if pan is NULL or an error occurs when
- 	trying to move the curses window.
-
-  Portability:
- 	PDCurses	int move_panel( PANEL *pan, int starty, int startx);
- 	SYS V Curses	int move_panel( PANEL *pan, int starty, int startx);
-
-**man-end**********************************************************************/
-
-int
-move_panel(pan,starty,startx)
-PANEL *pan;
-int starty;
-int startx;
-{
-WINDOW *win;
-
-	if(!pan)
-		return(ERR);
-	if(__panel_is_linked(pan))
-		__override(pan,0);
-	win = pan->win;
-	if(mvwin(win,starty,startx) == ERR)
-		return(ERR);
-	pan->wstarty = getbegy(win);
-	pan->wstartx = getbegx(win);
-	pan->wendy = pan->wstarty + getmaxy(win);
-	pan->wendx = pan->wstartx + getmaxx(win);
-	if(__panel_is_linked(pan))
-		__calculate_obscure();
-	return(OK);
-}	/* end of move_panel */
-
-/*man-start*********************************************************************
-
-  new_panel	- create a new panel
-
-  PDCurses Description:
- 	This function creates a new panel associated with win and returns
- 	the panel pointer. The new panel is placed at the top of the deck.
-
-  PDCurses Return Value:
- 	Returns pointer to new panel, or NULL if an error occurs.
-
-  PDCurses Errors:
- 	Returns NULL if an error occurs.
-
-  Portability:
- 	PDCurses	PANEL *new_panel( WINDOW *win );
- 	SYS V Curses	PANEL *new_panel( WINDOW *win );
-
-**man-end**********************************************************************/
-
-PANEL *
-new_panel(win)
-WINDOW *win;
-{
-PANEL *pan = (PANEL *)malloc(sizeof(PANEL));
-
-	if(!__stdscr_pseudo_panel.win)
-	{
-		__stdscr_pseudo_panel.win = stdscr;
-		__stdscr_pseudo_panel.wstarty = 0;
-		__stdscr_pseudo_panel.wstartx = 0;
-		__stdscr_pseudo_panel.wendy = LINES;
-		__stdscr_pseudo_panel.wendx = COLS;
-		__stdscr_pseudo_panel.user = "stdscr";
-		__stdscr_pseudo_panel.obscure = (PANELOBS *)0;
-	}
-
-	if(pan)
-	{
-		pan->win = win;
-		pan->above = (PANEL *)0;
-		pan->below = (PANEL *)0;
-		pan->wstarty = getbegy(win);
-		pan->wstartx = getbegx(win);
-		pan->wendy = pan->wstarty + getmaxy(win);
-		pan->wendx = pan->wstartx + getmaxx(win);
-#ifdef PANEL_DEBUG
-		pan->user = "new";
-#else
-		pan->user = (char *)0;
-#endif
-		pan->obscure = (PANELOBS *)0;
-		(void)show_panel(pan);
-	}
-
-	return(pan);
-}	/* end of new_panel */
-
-/*man-start*********************************************************************
-
-  panel_above	- return pointer to panel above
-
-  PDCurses Description:
- 	This function returns a pointer to the panel in the deck above
- 	pan. If the value of pan passed is NULL, this function returns
- 	a pointer to the bottom panel in the deck.
-
-  PDCurses Return Value:
- 	Returns pointer to panel above pan, or NULL if pan is the top
- 	panel.
-
-  PDCurses Errors:
- 	Returns NULL if an error occurs.
-
-  Portability:
- 	PDCurses	PANEL *panel_above( PANEL *pan );
- 	SYS V Curses	PANEL *panel_above( PANEL *pan );
-
-**man-end**********************************************************************/
-
-PANEL *
-panel_above(pan)
-PANEL *pan;
-{
-	if(!pan)
-		return(__bottom_panel);
-	else
-		return(pan->above);
-}	/* end of panel_above */
-
-/*man-start*********************************************************************
-
-  panel_below	- return pointer to panel below
-
-  PDCurses Description:
- 	This function returns a pointer to the panel in the deck below
- 	pan. If the value of pan passed is NULL, this function returns
- 	a pointer to the top panel in the deck.
-
-  PDCurses Return Value:
- 	Returns pointer to panel below pan, or NULL if pan is the bottom
- 	panel.
-
-  PDCurses Errors:
- 	Returns NULL if an error occurs.
-
-  Portability:
- 	PDCurses	PANEL *panel_below( PANEL *pan );
- 	SYS V Curses	PANEL *panel_below( PANEL *pan );
-
-**man-end**********************************************************************/
-
-PANEL *
-panel_below(pan)
-PANEL *pan;
-{
-	if(!pan)
-		return(__top_panel);
-	else
-		return(pan->below);
-}	/* end of panel_below */
-
-/*man-start*********************************************************************
-
-  panel_hidden	- indicates if panel is hidden
-
-  PDCurses Description:
- 	This function returns TRUE if pan is hidden and FALSE if it is not.
-
-  PDCurses Return Value:
- 	TRUE or FALSE.
-
-  PDCurses Errors:
- 	Returns ERR if pan is NULL.
-
-  Portability:
- 	PDCurses	int panel_hidden( PANEL *pan );
- 	SYS V Curses	int panel_hidden( PANEL *pan );
-
-**man-end**********************************************************************/
-
-int
-panel_hidden(pan)
-PANEL *pan;
-{
-	if(!pan)
-		return(ERR);
-	return(__panel_is_linked(pan) ? ERR : OK);
-}	/* end of panel_hidden */
-
-/*man-start*********************************************************************
-
-  panel_userptr	- return user information
-
-  PDCurses Description:
- 	Each panel has a user pointer available for maintaining relevant
- 	information. This function returns a pointer to that information
- 	previously set up by set_panel_userptr().
-
-  PDCurses Return Value:
- 	Returns pointer to user information.
-
-  PDCurses Errors:
- 	Returns NULL if pan is NULL or no user information exists.
-
-  Portability:
- 	PDCurses	char *panel_userptr( PANEL *pan );
- 	SYS V Curses	char *panel_userptr( PANEL *pan );
-
-**man-end**********************************************************************/
-
-char *
-panel_userptr(pan)
-PANEL *pan;
-{
-	if(!pan)
-		return((char *)0);
-	return(pan->user);
-}	/* end of panel_userptr */
-
-/*man-start*********************************************************************
-
-  panel_window	- returns pointer to curses window
-
-  PDCurses Description:
- 	This function returns a pointer to the curses window associated
- 	with the panel.
-
-  PDCurses Return Value:
- 	Pointer to panel's window.
-
-  PDCurses Errors:
- 	Return NULL on error.
-
-  Portability:
- 	PDCurses	WINDOW *panel_window(PANEL *);
- 	SYS V Curses	WINDOW *panel_window(PANEL *);
-
-**man-end**********************************************************************/
-
-WINDOW *
-panel_window(pan)
-PANEL *pan;
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("panel_window() - called\n");
-#endif
-	return(pan->win);
-}	/* end of panel_window */
-
-/*man-start*********************************************************************
-
-  replace_panel	- set curses window contents
-
-  PDCurses Description:
- 	This function replaces the current window of pan with win.
-
-  PDCurses Return Value:
- 	Returns OK or ERR.
-
-  PDCurses Errors:
- 	Returns ERR if pan is NULL.
-
-  Portability:
- 	PDCurses	int replace_panel( PANEL *pan, WINDOW *win );
- 	SYS V Curses	int replace_panel( PANEL *pan, WINDOW *win );
-
-**man-end**********************************************************************/
-
-int
-replace_panel(pan,win)
-PANEL *pan;
-WINDOW *win;
-{
-	if(!pan)
-		return(ERR);
-	if(__panel_is_linked(pan))
-		__override(pan,0);
-	pan->win = win;
-	pan->wstarty = getbegy(win);
-	pan->wstartx = getbegx(win);
-	pan->wendy = pan->wstarty + getmaxy(win);
-	pan->wendx = pan->wstartx + getmaxx(win);
-	if(__panel_is_linked(pan))
-		__calculate_obscure();
-	return(OK);
-}	/* end of replace_panel */
-
-/*man-start*********************************************************************
-
-  set_panel_userptr	- sets user information for a panel
-
-  PDCurses Description:
- 	Each panel has a user pointer available for maintaining relevant
- 	information. This function sets the value of that information.
-
-  PDCurses Return Value:
- 	Returns OK or ERR.
-
-  PDCurses Errors:
- 	Returns ERR if pan is NULL.
-
-  Portability:
- 	PDCurses	int set_panel_userptr( PANEL *pan, char *uptr );
- 	SYS V Curses	int set_panel_userptr( PANEL *pan, char *uptr );
-
-**man-end**********************************************************************/
-
-int
-set_panel_userptr(pan,uptr)
-PANEL *pan;
-char *uptr;
-{
-	if(!pan)
-		return(ERR);
-	pan->user = uptr;
-	return(OK);
-}	/* end of set_panel_userptr */
-
-/*man-start*********************************************************************
-
-  show_panel	- displays a panel
-
-  PDCurses Description:
- 	This function makes a previously hidden panel visible and places
- 	it back in the deck on top.
-
-  PDCurses Return Value:
- 	Returns OK or ERR.
-
-  PDCurses Errors:
- 	Returns ERR if pan is NULL.
-
-  Portability:
- 	PDCurses	int show_panel( PANEL *pan );
- 	SYS V Curses	int show_panel( PANEL *pan );
-
-**man-end**********************************************************************/
-
-int
-show_panel(pan)
-register PANEL *pan;
-{
-
-	if(!pan)
-		return(ERR);
-	if(pan == __top_panel)
-		return(OK);
-	if(__panel_is_linked(pan))
-		(void)hide_panel(pan);
-	__panel_link_top(pan);
-	return(OK);
-}	/* end of show_panel */
-
-/*man-start*********************************************************************
-
-  top_panel	- puts panel on top of deck
-
-  PDCurses Description:
- 	This function places pan on the top of the deck. The size, location
- 	and contents of the panel are unchanged.
-
-  PDCurses Return Value:
- 	Returns OK or ERR.
-
-  PDCurses Errors:
- 	Returns ERR if pan is NULL.
-
-  Portability:
- 	PDCurses	int top_panel( PANEL *pan );
- 	SYS V Curses	int top_panel( PANEL *pan );
-
-**man-end**********************************************************************/
-
-int
-top_panel(pan)
-register PANEL *pan;
-{
-	return(show_panel(pan));
-}	/* end of top_panel */
-
-/*man-start*********************************************************************
-
-  update_panels	- panels virtual screen refresh routine
-
-  PDCurses Description:
- 	This function refreshes the virtual screen to reflect the depth
- 	relationships between the panels in the deck. The user must use
- 	doupdate() to refresh the physical screen.
-
-  PDCurses Return Value:
- 	None
-
-  PDCurses Errors:
- 	None
-
-  Portability:
- 	PDCurses	void update_panels( void )
- 	SYS V Curses	void update_panels( void )
-
-**man-end**********************************************************************/
-
-void
-update_panels()
-{
-PANEL *pan;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("update_panels() - called\n");
-#endif
-
-	pan = __bottom_panel;
-	while(pan)
-	{
-		__override(pan,-1);
-		pan = pan->above;
-	}
-
-	if(is_wintouched(stdscr))
-		Wnoutrefresh(&__stdscr_pseudo_panel);
-	
-	pan = __bottom_panel;
-	if(pan)
-	{
-		while(pan)
-		{
-			if(is_wintouched(pan->win) || !pan->above)
-				Wnoutrefresh(pan);
-			pan = pan->above;
-		}
-	}
-}	/* end of update_panels */
-
-/* end of panel.c */
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include <panel.h>
+
+#ifdef UNIX
+#include <defs.h>
+#include <term.h>
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_panel = "$Id: panel.c,v 1.2 2001/01/10 08:28:01 mark Exp $";
+#endif
+
+
+/*man-start*********************************************************************
+
+  panels	- panel package for curses
+
+  PDCurses Description:
+ 	The panel library is built using the curses library and any program
+ 	using panels routines must call one of the curses initialization
+ 	routines such as initscr(). A program using these routines must be
+ 	linked with the panels and curses libraries.
+
+ 	The panels package gives the applications programmer a way to have
+ 	depth relationships between curses windows; a curses window is
+ 	associated with every panel. The panels routines allow curses windows
+ 	to overlap without making visible the overlapped portions of 
+ 	underlying windows. The initial curses window, stdscr, lies beneath
+ 	all panels. The set of currently visible panels is the 'deck' of
+ 	panels.
+
+ 	The panels package allows the applications programmer to create
+ 	panels, fetch and set their associated windows, shuffle panels in 
+ 	the deck, and manipulate panels in other ways.
+
+  PDCurses Return Value:
+ 	Each panels routine that returns a pointer to an object returns NULL
+ 	if an error occurs. Each panel routine that returns an integer, 
+ 	returns OK if it executes successfully and ERR if it does not.
+
+  Notes
+ 	The header <panel.h> includes the header <curses.h>.
+
+  Credits
+ 	Original Author - Warren Tucker N4HGF
+ 	{gatech,emory}!n4hgf!wht -or- wht@n4hgf.Mt-Park.GA.US
+
+**man-end**********************************************************************/
+
+
+/*
+  Defined functions:
+	int bottom_panel(PANEL *pan);
+	int del_panel(PANEL *pan);
+	int hide_panel(PANEL *pan);
+	int move_panel(PANEL *pan,int starty,int startx);
+	PANEL *new_panel(WINDOW *win);
+	PANEL *panel_above(PANEL *pan);
+	PANEL *panel_below(PANEL *pan);
+	int panel_hidden(PANEL *pan);
+	char *panel_userptr(PANEL *pan);
+	WINDOW *panel_window(PANEL *pan);
+	int replace_panel(PANEL *pan,WINDOW *win);
+	int set_panel_userptr(PANEL *pan,char *uptr);
+	int show_panel(PANEL *pan);
+	int top_panel(PANEL *pan);
+	void update_panels(void);
+
+	Touchline(pan,start,count)
+	Touchpan(pan)
+	Wnoutrefresh(pan)
+	__calculate_obscure()
+	__free_obscure(pan)
+	__override(pan,show)
+	__panel_is_linked(pan)
+	__panel_link_bottom(pan)
+	__panel_link_top(pan)
+	__panel_unlink(pan)
+	__panels_overlapped(pan1,pan2)
+	dPanel(text,pan)
+	dStack(fmt,num,pan)
+	open_dfp()
+
+--------------------------------------------------------------------------*/
+PANEL *__bottom_panel = (PANEL *)0;
+PANEL *__top_panel = (PANEL *)0;
+PANEL __stdscr_pseudo_panel = { (WINDOW *)0 };
+
+#define STATIC static
+
+/*+-------------------------------------------------------------------------
+	dPanel(text,pan)
+--------------------------------------------------------------------------*/
+#ifdef PANEL_DEBUG
+dPanel(text,pan)
+char *text;
+PANEL *pan;
+{
+	_tracef("%s id=%s b=%s a=%s y=%d x=%d",
+		text,pan->user,
+		(pan->below) ? pan->below->user : "--",
+		(pan->above) ? pan->above->user : "--",
+		pan->wstarty, pan->wstartx);
+}	/* end of dPanel */
+#else
+#define dPanel(text,pan)
+#endif
+
+/*+-------------------------------------------------------------------------
+	dStack(fmt,num,pan)
+--------------------------------------------------------------------------*/
+#ifdef PANEL_DEBUG
+void
+dStack(fmt,num,pan)
+char *fmt;
+int num;
+PANEL *pan;
+{
+char s80[80];
+
+	sprintf(s80,fmt,num,pan);
+	_tracef("%s b=%s t=%s",s80,
+		(__bottom_panel) ? __bottom_panel->user : "--",
+		(__top_panel)    ? __top_panel->user    : "--");
+	if(pan)
+		_tracef("pan id=%s",pan->user);
+	pan = __bottom_panel;
+	while(pan)
+	{
+		dPanel("stk",pan);
+		pan = pan->above;
+	}
+}	/* end of dStack */
+#else
+#define dStack(fmt,num,pan)
+#endif
+
+/*+-------------------------------------------------------------------------
+	Wnoutrefresh(pan) - debugging hook for wnoutrefresh
+--------------------------------------------------------------------------*/
+#ifdef PANEL_DEBUG
+STATIC int
+Wnoutrefresh(pan)
+PANEL *pan;
+{
+	dPanel("wnoutrefresh",pan);
+	wnoutrefresh(pan->win);
+}	/* end of Wnoutrefresh */
+#else
+#define Wnoutrefresh(pan) wnoutrefresh((pan)->win)
+#endif
+
+/*+-------------------------------------------------------------------------
+	Touchpan(pan)
+--------------------------------------------------------------------------*/
+#ifdef PANEL_DEBUG
+STATIC int
+Touchpan(pan)
+PANEL *pan;
+{
+	dPanel("Touchpan",pan);
+	touchwin(pan->win);
+}	/* end of Touchpan */
+#else
+#define Touchpan(pan) touchwin((pan)->win)
+#endif
+
+/*+-------------------------------------------------------------------------
+	Touchline(pan,start,count)
+--------------------------------------------------------------------------*/
+#ifdef PANEL_DEBUG
+STATIC int
+Touchline(pan,start,count)
+PANEL *pan;
+int start;
+int count;
+{
+char s80[80];
+	sprintf(s80,"Touchline s=%d c=%d",start,count);
+	dPanel(s80,pan);
+	touchline(pan->win,start,count);
+}	/* end of Touchline */
+#else
+#define Touchline(pan,start,count) touchline((pan)->win,start,count)
+#endif
+
+/*+-------------------------------------------------------------------------
+	__panels_overlapped(pan1,pan2) - check panel overlapped
+--------------------------------------------------------------------------*/
+STATIC int
+__panels_overlapped(pan1,pan2)
+register PANEL *pan1;
+register PANEL *pan2;
+{
+	if(!pan1 || !pan2)
+		return(0);
+	return((pan1->wstarty >= pan2->wstarty && pan1->wstarty < pan2->wendy) ||
+		(pan2->wstarty >= pan1->wstarty && pan2->wstarty < pan1->wendy))
+	&& ((pan1->wstartx >= pan2->wstartx && pan1->wstartx < pan2->wendx) ||
+		(pan2->wstartx >= pan1->wstartx && pan2->wstartx < pan1->wendx));
+}	/* end of __panels_overlapped */
+
+/*+-------------------------------------------------------------------------
+	__free_obscure(pan)
+--------------------------------------------------------------------------*/
+STATIC void
+__free_obscure(pan)
+PANEL *pan;
+{
+PANELOBS *tobs = pan->obscure;				/* "this" one */
+PANELOBS *nobs;								/* "next" one */
+
+	while(tobs)
+	{
+		nobs = tobs->above;
+		free((char *)tobs);
+		tobs = nobs;
+	}
+	pan->obscure = (PANELOBS *)0;
+}	/* end of __free_obscure */
+
+/*+-------------------------------------------------------------------------
+	__override(pan,show)
+--------------------------------------------------------------------------*/
+STATIC void
+__override(pan,show)
+PANEL *pan;
+int show;
+{
+register int y;
+register PANEL *pan2;
+PANELOBS *tobs = pan->obscure;				/* "this" one */
+
+
+	if(show == 1)
+		Touchpan(pan);
+	else if(!show)
+	{
+		Touchpan(pan);
+/*
+		Touchline(&__stdscr_pseudo_panel,pan->wendy,getmaxy(pan->win));
+*/
+		Touchpan(&__stdscr_pseudo_panel);
+	}
+	else if(show == -1)
+	{
+		while(tobs && (tobs->pan != pan))
+			tobs = tobs->above;
+	}
+
+	while(tobs)
+	{
+		if((pan2 = tobs->pan) != pan)
+		{
+			for(y = pan->wstarty; y < pan->wendy; y++)
+			{
+				if( (y >= pan2->wstarty) && (y < pan2->wendy) &&
+					((is_linetouched(pan->win,y - pan->wstarty)) ||
+					(is_linetouched(stdscr,y))))
+				{
+					Touchline(pan2,y - pan2->wstarty,1);
+				}
+			}
+		}
+		tobs = tobs->above;
+	}
+}	/* end of __override */
+
+/*+-------------------------------------------------------------------------
+	__calculate_obscure()
+--------------------------------------------------------------------------*/
+STATIC void
+__calculate_obscure()
+{
+PANEL *pan;
+register PANEL *pan2;
+register PANELOBS *tobs;			/* "this" one */
+PANELOBS *lobs = (PANELOBS *)0;		/* last one */
+
+	pan = __bottom_panel;
+	while(pan)
+	{
+		if(pan->obscure)
+			__free_obscure(pan);
+		lobs = (PANELOBS *)0;		/* last one */
+		pan2 = __bottom_panel;
+		while(pan2)
+		{
+			if(__panels_overlapped(pan,pan2))
+			{
+				if(!(tobs = (PANELOBS *)malloc(sizeof(PANELOBS))))
+					return;
+				tobs->pan = pan2;
+				dPanel("obscured",pan2);
+				tobs->above = (PANELOBS *)0;
+				if(lobs)
+					lobs->above = tobs;
+				else
+					pan->obscure = tobs;
+				lobs  = tobs;
+			}
+			pan2 = pan2->above;
+		}
+		__override(pan,1);
+		pan = pan->above;
+	}
+
+}	/* end of __calculate_obscure */
+
+/*+-------------------------------------------------------------------------
+	__panel_is_linked(pan) - check to see if panel is in the stack
+--------------------------------------------------------------------------*/
+STATIC int
+__panel_is_linked(pan)
+PANEL *pan;
+{
+register PANEL *pan2 = __bottom_panel;
+
+	while(pan2)
+	{
+		if(pan2 == pan)
+			return(1);
+		pan2 = pan2->above;
+	}
+	return(OK);
+}	/* end of __panel_is_linked */
+
+/*+-------------------------------------------------------------------------
+	__panel_link_top(pan) - link panel into stack at top
+--------------------------------------------------------------------------*/
+STATIC void
+__panel_link_top(pan)
+PANEL *pan;
+{
+
+#ifdef PANEL_DEBUG
+	dStack("<lt%d>",1,pan);
+	if(__panel_is_linked(pan))
+		return;
+#endif
+
+	pan->above = (PANEL *)0;
+	pan->below = (PANEL *)0;
+	if(__top_panel)
+	{
+		__top_panel->above = pan;
+		pan->below = __top_panel;
+	}
+	__top_panel = pan;
+	if(!__bottom_panel)
+		__bottom_panel = pan;
+	__calculate_obscure();
+	dStack("<lt%d>",9,pan);
+
+}	/* end of __panel_link_top */
+
+/*+-------------------------------------------------------------------------
+	__panel_link_bottom(pan) - link panel into stack at bottom
+--------------------------------------------------------------------------*/
+STATIC void
+__panel_link_bottom(pan)
+PANEL *pan;
+{
+
+#ifdef PANEL_DEBUG
+	dStack("<lb%d>",1,pan);
+	if(__panel_is_linked(pan))
+		return;
+#endif
+
+	pan->above = (PANEL *)0;
+	pan->below = (PANEL *)0;
+	if(__bottom_panel)
+	{
+		__bottom_panel->below = pan;
+		pan->above = __bottom_panel;
+	}
+	__bottom_panel = pan;
+	if(!__top_panel)
+		__top_panel = pan;
+	__calculate_obscure();
+	dStack("<lb%d>",9,pan);
+
+}	/* end of __panel_link_bottom */
+
+/*+-------------------------------------------------------------------------
+	__panel_unlink(pan) - unlink panel from stack
+--------------------------------------------------------------------------*/
+STATIC void
+__panel_unlink(pan)
+PANEL *pan;
+{
+register PANEL *prev;
+register PANEL *next;
+
+#ifdef PANEL_DEBUG
+	dStack("<u%d>",1,pan);
+	if(!__panel_is_linked(pan))
+		return;
+#endif
+
+	__override(pan,0);
+	__free_obscure(pan);
+
+	prev = pan->below;
+	next = pan->above;
+
+	if(prev)		/* if non-zero, we will not update the list head */
+	{
+		prev->above = next;
+		if(next)
+			next->below = prev;
+	}
+	else if(next)
+		next->below = prev;
+	if(pan == __bottom_panel)
+		__bottom_panel = next;
+	if(pan == __top_panel)
+		__top_panel = prev;
+
+	__calculate_obscure();
+
+	pan->above = (PANEL *)0;
+	pan->below = (PANEL *)0;
+	dStack("<u%d>",9,pan);
+
+}	/* end of __panel_unlink */
+
+/**********************************************************************/
+/* The following are the public functions for the panels library.     */
+/**********************************************************************/
+
+/*man-start*********************************************************************
+
+  bottom_panel	- puts panel at bottom of deck
+
+  PDCurses Description:
+ 	This function places pan at the bottom of the deck. The size, location
+ 	and contents of the panel are unchanged.
+
+  PDCurses Return Value:
+ 	Returns OK or ERR.
+
+  PDCurses Errors:
+ 	Returns ERR if pan is NULL.
+
+  Portability:
+ 	PDCurses	int bottom_panel( PANEL *pan );
+ 	SYS V Curses	int bottom_panel( PANEL *pan );
+
+**man-end**********************************************************************/
+
+int
+bottom_panel(pan)
+register PANEL *pan;
+{
+	if(!pan)
+		return(ERR);
+	if(pan == __bottom_panel)
+		return(OK);
+	if(__panel_is_linked(pan))
+		(void)hide_panel(pan);
+	__panel_link_bottom(pan);
+	return(OK);
+}	/* end of bottom_panel */
+
+/*man-start*********************************************************************
+
+  del_panel	- deletes a panel
+
+  PDCurses Description:
+ 	This function deletes pan but not its associated winwow.
+
+  PDCurses Return Value:
+ 	Returns OK or ERR.
+
+  PDCurses Errors:
+ 	Returns ERR if pan is NULL.
+
+  Portability:
+ 	PDCurses	int del_panel( PANEL *pan );
+ 	SYS V Curses	int del_panel( PANEL *pan );
+
+**man-end**********************************************************************/
+
+int
+del_panel(pan)
+register PANEL *pan;
+{
+	if(pan)
+	{
+		if(__panel_is_linked(pan))
+			(void)hide_panel(pan);
+		free((char *)pan);
+		return(OK);
+	}
+	return(ERR);
+}	/* end of del_panel */
+
+/*man-start*********************************************************************
+
+  hide_panel	- removes a panel from the deck
+
+  PDCurses Description:
+ 	This function removes a panel from the deck and thus hides it from
+ 	view.
+
+  PDCurses Return Value:
+ 	Returns OK or ERR.
+
+  PDCurses Errors:
+ 	Returns ERR if pan is NULL.
+
+  Portability:
+ 	PDCurses	int hide_panel( PANEL *pan );
+ 	SYS V Curses	int hide_panel( PANEL *pan );
+
+**man-end**********************************************************************/
+
+int
+hide_panel(pan)
+register PANEL *pan;
+{
+
+	if(!pan)
+		return(ERR);
+
+	if(!__panel_is_linked(pan))
+	{
+		pan->above = (PANEL *)0;
+		pan->below = (PANEL *)0;
+		return(ERR);
+	}
+
+	__panel_unlink(pan);
+
+	return(OK);
+}	/* end of hide_panel */
+
+/*man-start*********************************************************************
+
+  move_panel	- move a window on the virtual screen
+
+  PDCurses Description:
+ 	This function move the curses window associated with pan so that
+ 	its upper lefthand corner is at the supplied coordinates. Do not
+ 	use mvwin() on the window.
+
+  PDCurses Return Value:
+ 	Returns OK or ERR.
+
+  PDCurses Errors:
+ 	Returns ERR if pan is NULL or an error occurs when
+ 	trying to move the curses window.
+
+  Portability:
+ 	PDCurses	int move_panel( PANEL *pan, int starty, int startx);
+ 	SYS V Curses	int move_panel( PANEL *pan, int starty, int startx);
+
+**man-end**********************************************************************/
+
+int
+move_panel(pan,starty,startx)
+PANEL *pan;
+int starty;
+int startx;
+{
+WINDOW *win;
+
+	if(!pan)
+		return(ERR);
+	if(__panel_is_linked(pan))
+		__override(pan,0);
+	win = pan->win;
+	if(mvwin(win,starty,startx) == ERR)
+		return(ERR);
+	pan->wstarty = getbegy(win);
+	pan->wstartx = getbegx(win);
+	pan->wendy = pan->wstarty + getmaxy(win);
+	pan->wendx = pan->wstartx + getmaxx(win);
+	if(__panel_is_linked(pan))
+		__calculate_obscure();
+	return(OK);
+}	/* end of move_panel */
+
+/*man-start*********************************************************************
+
+  new_panel	- create a new panel
+
+  PDCurses Description:
+ 	This function creates a new panel associated with win and returns
+ 	the panel pointer. The new panel is placed at the top of the deck.
+
+  PDCurses Return Value:
+ 	Returns pointer to new panel, or NULL if an error occurs.
+
+  PDCurses Errors:
+ 	Returns NULL if an error occurs.
+
+  Portability:
+ 	PDCurses	PANEL *new_panel( WINDOW *win );
+ 	SYS V Curses	PANEL *new_panel( WINDOW *win );
+
+**man-end**********************************************************************/
+
+PANEL *
+new_panel(win)
+WINDOW *win;
+{
+PANEL *pan = (PANEL *)malloc(sizeof(PANEL));
+
+	if(!__stdscr_pseudo_panel.win)
+	{
+		__stdscr_pseudo_panel.win = stdscr;
+		__stdscr_pseudo_panel.wstarty = 0;
+		__stdscr_pseudo_panel.wstartx = 0;
+		__stdscr_pseudo_panel.wendy = LINES;
+		__stdscr_pseudo_panel.wendx = COLS;
+		__stdscr_pseudo_panel.user = "stdscr";
+		__stdscr_pseudo_panel.obscure = (PANELOBS *)0;
+	}
+
+	if(pan)
+	{
+		pan->win = win;
+		pan->above = (PANEL *)0;
+		pan->below = (PANEL *)0;
+		pan->wstarty = getbegy(win);
+		pan->wstartx = getbegx(win);
+		pan->wendy = pan->wstarty + getmaxy(win);
+		pan->wendx = pan->wstartx + getmaxx(win);
+#ifdef PANEL_DEBUG
+		pan->user = "new";
+#else
+		pan->user = (char *)0;
+#endif
+		pan->obscure = (PANELOBS *)0;
+		(void)show_panel(pan);
+	}
+
+	return(pan);
+}	/* end of new_panel */
+
+/*man-start*********************************************************************
+
+  panel_above	- return pointer to panel above
+
+  PDCurses Description:
+ 	This function returns a pointer to the panel in the deck above
+ 	pan. If the value of pan passed is NULL, this function returns
+ 	a pointer to the bottom panel in the deck.
+
+  PDCurses Return Value:
+ 	Returns pointer to panel above pan, or NULL if pan is the top
+ 	panel.
+
+  PDCurses Errors:
+ 	Returns NULL if an error occurs.
+
+  Portability:
+ 	PDCurses	PANEL *panel_above( PANEL *pan );
+ 	SYS V Curses	PANEL *panel_above( PANEL *pan );
+
+**man-end**********************************************************************/
+
+PANEL *
+panel_above(pan)
+PANEL *pan;
+{
+	if(!pan)
+		return(__bottom_panel);
+	else
+		return(pan->above);
+}	/* end of panel_above */
+
+/*man-start*********************************************************************
+
+  panel_below	- return pointer to panel below
+
+  PDCurses Description:
+ 	This function returns a pointer to the panel in the deck below
+ 	pan. If the value of pan passed is NULL, this function returns
+ 	a pointer to the top panel in the deck.
+
+  PDCurses Return Value:
+ 	Returns pointer to panel below pan, or NULL if pan is the bottom
+ 	panel.
+
+  PDCurses Errors:
+ 	Returns NULL if an error occurs.
+
+  Portability:
+ 	PDCurses	PANEL *panel_below( PANEL *pan );
+ 	SYS V Curses	PANEL *panel_below( PANEL *pan );
+
+**man-end**********************************************************************/
+
+PANEL *
+panel_below(pan)
+PANEL *pan;
+{
+	if(!pan)
+		return(__top_panel);
+	else
+		return(pan->below);
+}	/* end of panel_below */
+
+/*man-start*********************************************************************
+
+  panel_hidden	- indicates if panel is hidden
+
+  PDCurses Description:
+ 	This function returns TRUE if pan is hidden and FALSE if it is not.
+
+  PDCurses Return Value:
+ 	TRUE or FALSE.
+
+  PDCurses Errors:
+ 	Returns ERR if pan is NULL.
+
+  Portability:
+ 	PDCurses	int panel_hidden( PANEL *pan );
+ 	SYS V Curses	int panel_hidden( PANEL *pan );
+
+**man-end**********************************************************************/
+
+int
+panel_hidden(pan)
+PANEL *pan;
+{
+	if(!pan)
+		return(ERR);
+	return(__panel_is_linked(pan) ? ERR : OK);
+}	/* end of panel_hidden */
+
+/*man-start*********************************************************************
+
+  panel_userptr	- return user information
+
+  PDCurses Description:
+ 	Each panel has a user pointer available for maintaining relevant
+ 	information. This function returns a pointer to that information
+ 	previously set up by set_panel_userptr().
+
+  PDCurses Return Value:
+ 	Returns pointer to user information.
+
+  PDCurses Errors:
+ 	Returns NULL if pan is NULL or no user information exists.
+
+  Portability:
+ 	PDCurses	char *panel_userptr( PANEL *pan );
+ 	SYS V Curses	char *panel_userptr( PANEL *pan );
+
+**man-end**********************************************************************/
+
+char *
+panel_userptr(pan)
+PANEL *pan;
+{
+	if(!pan)
+		return((char *)0);
+	return(pan->user);
+}	/* end of panel_userptr */
+
+/*man-start*********************************************************************
+
+  panel_window	- returns pointer to curses window
+
+  PDCurses Description:
+ 	This function returns a pointer to the curses window associated
+ 	with the panel.
+
+  PDCurses Return Value:
+ 	Pointer to panel's window.
+
+  PDCurses Errors:
+ 	Return NULL on error.
+
+  Portability:
+ 	PDCurses	WINDOW *panel_window(PANEL *);
+ 	SYS V Curses	WINDOW *panel_window(PANEL *);
+
+**man-end**********************************************************************/
+
+WINDOW *
+panel_window(pan)
+PANEL *pan;
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("panel_window() - called\n");
+#endif
+	return(pan->win);
+}	/* end of panel_window */
+
+/*man-start*********************************************************************
+
+  replace_panel	- set curses window contents
+
+  PDCurses Description:
+ 	This function replaces the current window of pan with win.
+
+  PDCurses Return Value:
+ 	Returns OK or ERR.
+
+  PDCurses Errors:
+ 	Returns ERR if pan is NULL.
+
+  Portability:
+ 	PDCurses	int replace_panel( PANEL *pan, WINDOW *win );
+ 	SYS V Curses	int replace_panel( PANEL *pan, WINDOW *win );
+
+**man-end**********************************************************************/
+
+int
+replace_panel(pan,win)
+PANEL *pan;
+WINDOW *win;
+{
+	if(!pan)
+		return(ERR);
+	if(__panel_is_linked(pan))
+		__override(pan,0);
+	pan->win = win;
+	pan->wstarty = getbegy(win);
+	pan->wstartx = getbegx(win);
+	pan->wendy = pan->wstarty + getmaxy(win);
+	pan->wendx = pan->wstartx + getmaxx(win);
+	if(__panel_is_linked(pan))
+		__calculate_obscure();
+	return(OK);
+}	/* end of replace_panel */
+
+/*man-start*********************************************************************
+
+  set_panel_userptr	- sets user information for a panel
+
+  PDCurses Description:
+ 	Each panel has a user pointer available for maintaining relevant
+ 	information. This function sets the value of that information.
+
+  PDCurses Return Value:
+ 	Returns OK or ERR.
+
+  PDCurses Errors:
+ 	Returns ERR if pan is NULL.
+
+  Portability:
+ 	PDCurses	int set_panel_userptr( PANEL *pan, char *uptr );
+ 	SYS V Curses	int set_panel_userptr( PANEL *pan, char *uptr );
+
+**man-end**********************************************************************/
+
+int
+set_panel_userptr(pan,uptr)
+PANEL *pan;
+char *uptr;
+{
+	if(!pan)
+		return(ERR);
+	pan->user = uptr;
+	return(OK);
+}	/* end of set_panel_userptr */
+
+/*man-start*********************************************************************
+
+  show_panel	- displays a panel
+
+  PDCurses Description:
+ 	This function makes a previously hidden panel visible and places
+ 	it back in the deck on top.
+
+  PDCurses Return Value:
+ 	Returns OK or ERR.
+
+  PDCurses Errors:
+ 	Returns ERR if pan is NULL.
+
+  Portability:
+ 	PDCurses	int show_panel( PANEL *pan );
+ 	SYS V Curses	int show_panel( PANEL *pan );
+
+**man-end**********************************************************************/
+
+int
+show_panel(pan)
+register PANEL *pan;
+{
+
+	if(!pan)
+		return(ERR);
+	if(pan == __top_panel)
+		return(OK);
+	if(__panel_is_linked(pan))
+		(void)hide_panel(pan);
+	__panel_link_top(pan);
+	return(OK);
+}	/* end of show_panel */
+
+/*man-start*********************************************************************
+
+  top_panel	- puts panel on top of deck
+
+  PDCurses Description:
+ 	This function places pan on the top of the deck. The size, location
+ 	and contents of the panel are unchanged.
+
+  PDCurses Return Value:
+ 	Returns OK or ERR.
+
+  PDCurses Errors:
+ 	Returns ERR if pan is NULL.
+
+  Portability:
+ 	PDCurses	int top_panel( PANEL *pan );
+ 	SYS V Curses	int top_panel( PANEL *pan );
+
+**man-end**********************************************************************/
+
+int
+top_panel(pan)
+register PANEL *pan;
+{
+	return(show_panel(pan));
+}	/* end of top_panel */
+
+/*man-start*********************************************************************
+
+  update_panels	- panels virtual screen refresh routine
+
+  PDCurses Description:
+ 	This function refreshes the virtual screen to reflect the depth
+ 	relationships between the panels in the deck. The user must use
+ 	doupdate() to refresh the physical screen.
+
+  PDCurses Return Value:
+ 	None
+
+  PDCurses Errors:
+ 	None
+
+  Portability:
+ 	PDCurses	void update_panels( void )
+ 	SYS V Curses	void update_panels( void )
+
+**man-end**********************************************************************/
+
+void
+update_panels()
+{
+PANEL *pan;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("update_panels() - called\n");
+#endif
+
+	pan = __bottom_panel;
+	while(pan)
+	{
+		__override(pan,-1);
+		pan = pan->above;
+	}
+
+	if(is_wintouched(stdscr))
+		Wnoutrefresh(&__stdscr_pseudo_panel);
+	
+	pan = __bottom_panel;
+	if(pan)
+	{
+		while(pan)
+		{
+			if(is_wintouched(pan->win) || !pan->above)
+				Wnoutrefresh(pan);
+			pan = pan->above;
+		}
+	}
+}	/* end of update_panels */
+
+/* end of panel.c */
Index: PDCurses/pdcurses/refresh.c
===================================================================
--- PDCurses/pdcurses/refresh.c	(revision 1)
+++ PDCurses/pdcurses/refresh.c	(working copy)
@@ -1,394 +1,394 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define  CURSES_LIBRARY 1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-#include <string.h>
-
-#ifdef HAVE_MEMORY_H
-#include <memory.h>
-#endif
-
-/* undefine any macros for functions defined in this module */
-#undef   refresh
-#undef   wrefresh
-#undef   wnoutrefresh
-#undef   doupdate
-#undef   redrawwin
-#undef   wredrawln
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef wattrset
-#  undef mvwprintw
-#  undef wmove
-#  undef wattrset
-#  undef touchwin
-#  undef reset_prog_mode
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_refresh  = "$Id: refresh.c,v 1.2 2002/12/16 06:58:28 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                       refresh
-
-  Synopsis:
-   int   refresh(void);
-   int   wrefresh(WINDOW *win);
-   int   wnoutrefresh(register WINDOW *win);
-   int   doupdate(void);
-   int   redrawwin(WINDOW *win);
-   int   redrawln(WINDOW *win, int beg_line, int num_lines);
-
-  X/Open Description:
-   The routine wrefresh() copies the named window to the physical
-   terminal screen, taking into account what is already there in
-   order to optimize cursor movement.
-   The routine refresh() does the same, using stdscr as a default
-   screen.
-   These routines must be called to get any output on the
-   terminal, as other routines only manipulate data structures.
-   Unless leaveok has been enabled, the physical cursor of the
-   terminal is left at the location of the window's cursor.
-
-   The wnoutrefresh() and doupdate() routines allow multiple updates
-   with more efficiency than wrefresh() alone.  In addition to all 
-   of the window structures representing the terminal screen: a physical
-   screen, describing what is actually on the screen and a virtual screen,
-   describing what the programmer wants to have on the screen.
-
-   The wrefresh() function works by first calling wnoutrefresh(),
-   which copies the named window to the virtual screen.  It then
-   calls doupdate(), which compares the virtual screen to the
-   physical screen and does the actual update.  If the programmer
-   wishes to output several windows at once, a series of cals to
-   wrefresh() will result in alternating calls to wnoutrefresh()
-   and doupdate(), causing several bursts of output to the
-   screen.  By first calling wnoutrefresh() for each window, it
-   is then possible to call doupdate() once.  This results in
-   only one burst of output, with probably fewer total characters
-   transmitted and certainly less CPU time used.
-
-  X/Open Return Value:
-   All functions return OK on success and ERR on error.
-
-  X/Open Errors:
-   No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      refresh                               Y        Y       Y
-      wrefresh                              Y        Y       Y
-      wnoutrefresh                          Y        Y       Y
-      doupdate                              Y        Y       Y
-      redrawwin                             -        -      4.0
-      wredrawln                             -        -      4.0
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   refresh( void )
-#else
-int   PDC_CDECL   refresh()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("refresh() - called\n");
-#endif
-
-   return( wrefresh(stdscr) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   wrefresh(WINDOW *win)
-#else
-int   PDC_CDECL   wrefresh(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-   bool save_clear=FALSE;
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("wrefresh() - called\n");
-#endif
-
-   if (win == (WINDOW *)NULL) return( ERR );
-   if (win->_flags & _PAD) return( ERR );
-   if (win->_flags & _SUBPAD) return( ERR );
-
-   save_clear = win->_clear;
-   if (win == curscr)
-      curscr->_clear = TRUE;
-   else  
-      wnoutrefresh(win);
-   if (save_clear
-   &&  win->_maxy == SP->lines
-   &&  win->_maxx == SP->cols)
-      {
-      curscr->_clear = TRUE;
-      }
-   doupdate();
-   return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   wnoutrefresh(WINDOW *win)
-#else
-int   PDC_CDECL   wnoutrefresh(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-register int      first=0; /* first changed char on line */
-register int      last=0;  /* last changed char on line  */
-   int      begy=0,begx=0; /* window's place on screen   */
-   int      i=0,j=0,x=0,y=0;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("wnoutrefresh() - called: win=%x\n",win);
-#endif
-   if (win == (WINDOW *)NULL)
-      return( ERR );
-
-   if ((win->_flags == _PAD)
-   ||  (win->_flags == _SUBPAD))
-      return( ERR );
-
-   y = win->_cury;
-   x = win->_curx;
-
-   if (win->_title != NULL)
-   {
-      int len = strlen(win->_title);
-      chtype attrs = win->_attrs;
-   /*
-    * There may be a better place to implement window titles, but this
-    * seems to be the best place. -- Frotz
-    */
-      if ((len > 0)
-      && !(win->_flags & _SUBWIN)
-      && !(win->_flags & _SUBPAD))
-      {
-         wattrset(win, win->_title_attr);
-         mvwprintw(win, 0, (win->_title_ofs), "%s", (long) win->_title);
-         wmove(win, y, x); /* restore cursor postion */
-         wattrset(win, attrs);   /* restore attributes     */
-      }
-   }
-
-   if (win->_flags & _PAD)
-      return( ERR );
-
-   begy = win->_begy;
-   begx = win->_begx;
-
-   for (i = 0, j = begy; i < win->_maxy; i++, j++)
-   {
-      if (win->_firstch[i] != _NO_CHANGE)
-      {
-         first = win->_firstch[i];
-         last = win->_lastch[i];
-
-         memcpy(&(curscr->_y[j][begx + first]),
-                &(win->_y[i][first]),
-                (last - first + 1) * sizeof(chtype));
-
-         first += begx; /* s's min/max change positions */
-         last += begx;
-
-         if (curscr->_firstch[j] != _NO_CHANGE)
-            curscr->_firstch[j] = min(curscr->_firstch[j], first);
-         else
-            curscr->_firstch[j] = first;
-
-         curscr->_lastch[j] = max(curscr->_lastch[j], last);
-
-         win->_firstch[i] = _NO_CHANGE;   /* updated now */
-      }
-      win->_lastch[i] = _NO_CHANGE; /* updated now */
-   }
-
-   if (win->_clear)
-      win->_clear = FALSE;
-
-   if (!win->_leaveit)
-   {
-      curscr->_cury = win->_cury + begy;
-      curscr->_curx = win->_curx + begx;
-   }
-   return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   doupdate(void)
-#else
-int   PDC_CDECL   doupdate()
-#endif
-/***********************************************************************/
-{
-register int   i;
-bool rc;
-#ifdef   REGISTERWINDOWS
-   WINDS*   next = SP->visible;
-#endif
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("doupdate() - called\n");
-#endif
-
-   if (isendwin())  /* coming back after endwin() called */
-   {
-      reset_prog_mode();
-      curscr->_clear = TRUE;
-      SP->alive = TRUE; /* so isendwin() result is correct */
-   }
-
-#ifdef   REGISTERWINDOWS
-   if (SP->refreshall)
-   {
-      while (next != NULL)
-      {
-         if (next->w->_parent != NULL)
-         {
-            touchwin(next->w->_parent);
-            wnoutrefresh(next->w->_parent);
-         }
-         touchwin(next->w);
-         wnoutrefresh(next->w);
-         next = next->next;
-      }
-   }
-#endif
-
-   if (SP->shell)
-      reset_prog_mode();
-
-   if (curscr == (WINDOW *)NULL)
-      return( ERR );
-
-/* if checking for typeahead, bail out here if any is found */
-   
-   if (SP->refrbrk && (SP->cbreak || SP->raw_inp)) 
-   {
-      rc = PDC_breakout();
-      if(rc)
-         return( OK );
-   }
-
-   if (curscr->_clear)
-      PDC_clr_update(curscr);
-   else
-   {
-#ifdef WIN32
-      if (!SP->refrbrk
-      &&  getenv("PDC_FULL_DISPLAY") != NULL)
-         PDC_doupdate();
-      else
-      {
-         for (i = 0; i < SP->lines; i++)
-         {
-# ifdef PDCDEBUG
-   if (trace_on) PDC_debug("doupdate() - Transforming line %d of %d: %s\n",i,SP->lines,(curscr->_firstch[i] != _NO_CHANGE)?"Yes" : "No");
-#endif
-            if (curscr->_firstch[i] != _NO_CHANGE)
-               if (PDC_transform_line(i))  /* if test new */
-                  break;
-         }
-      }
-#else
-      for (i = 0; i < SP->lines; i++)
-      {
-         if (curscr->_firstch[i] != _NO_CHANGE)
-            if (PDC_transform_line(i))  /* if test new */
-               break;
-      }
-#endif
-   }
-
-# if defined (XCURSES)
-   XCursesInstructAndWait(CURSES_REFRESH);
-# endif
-
-   if (SP->cursrow != curscr->_cury
-   ||  SP->curscol != curscr->_curx)
-   {
-      PDC_gotoxy(curscr->_cury, curscr->_curx);
-      SP->cursrow = curscr->_cury;
-      SP->curscol = curscr->_curx;
-   }
-
-   return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   redrawwin(WINDOW *win)
-#else
-int   PDC_CDECL   redrawwin(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("redrawwin() - called: win=%x\n",win);
-#endif
-
-   if (win == (WINDOW *)NULL)
-      return( ERR );
-
-   return(wredrawln(win,0,win->_maxy));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   wredrawln(WINDOW *win, int start, int num)
-#else
-int   PDC_CDECL   wredrawln(win,start,num)
-WINDOW *win;
-int start;
-int num;
-#endif
-/***********************************************************************/
-{
-   register int i;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("wredrawln() - called: win=%x start=%d num=%d\n",win,start,num);
-#endif
-
-   if (win == (WINDOW *)NULL)
-      return( ERR );
-
-   if  (start > win->_maxy || start + num > win->_maxy)
-      return( ERR );
-   for(i=start;i<start+num;i++)
-      {
-      win->_firstch[i] = 0;
-      win->_lastch[i] = win->_maxx - 1;
-      }
-   return( OK );
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define  CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#include <string.h>
+
+#ifdef HAVE_MEMORY_H
+#include <memory.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef   refresh
+#undef   wrefresh
+#undef   wnoutrefresh
+#undef   doupdate
+#undef   redrawwin
+#undef   wredrawln
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef wattrset
+#  undef mvwprintw
+#  undef wmove
+#  undef wattrset
+#  undef touchwin
+#  undef reset_prog_mode
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_refresh  = "$Id: refresh.c,v 1.2 2002/12/16 06:58:28 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                       refresh
+
+  Synopsis:
+   int   refresh(void);
+   int   wrefresh(WINDOW *win);
+   int   wnoutrefresh(register WINDOW *win);
+   int   doupdate(void);
+   int   redrawwin(WINDOW *win);
+   int   redrawln(WINDOW *win, int beg_line, int num_lines);
+
+  X/Open Description:
+   The routine wrefresh() copies the named window to the physical
+   terminal screen, taking into account what is already there in
+   order to optimize cursor movement.
+   The routine refresh() does the same, using stdscr as a default
+   screen.
+   These routines must be called to get any output on the
+   terminal, as other routines only manipulate data structures.
+   Unless leaveok has been enabled, the physical cursor of the
+   terminal is left at the location of the window's cursor.
+
+   The wnoutrefresh() and doupdate() routines allow multiple updates
+   with more efficiency than wrefresh() alone.  In addition to all 
+   of the window structures representing the terminal screen: a physical
+   screen, describing what is actually on the screen and a virtual screen,
+   describing what the programmer wants to have on the screen.
+
+   The wrefresh() function works by first calling wnoutrefresh(),
+   which copies the named window to the virtual screen.  It then
+   calls doupdate(), which compares the virtual screen to the
+   physical screen and does the actual update.  If the programmer
+   wishes to output several windows at once, a series of cals to
+   wrefresh() will result in alternating calls to wnoutrefresh()
+   and doupdate(), causing several bursts of output to the
+   screen.  By first calling wnoutrefresh() for each window, it
+   is then possible to call doupdate() once.  This results in
+   only one burst of output, with probably fewer total characters
+   transmitted and certainly less CPU time used.
+
+  X/Open Return Value:
+   All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+   No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      refresh                               Y        Y       Y
+      wrefresh                              Y        Y       Y
+      wnoutrefresh                          Y        Y       Y
+      doupdate                              Y        Y       Y
+      redrawwin                             -        -      4.0
+      wredrawln                             -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   refresh( void )
+#else
+int   PDC_CDECL   refresh()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("refresh() - called\n");
+#endif
+
+   return( wrefresh(stdscr) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   wrefresh(WINDOW *win)
+#else
+int   PDC_CDECL   wrefresh(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+   bool save_clear=FALSE;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("wrefresh() - called\n");
+#endif
+
+   if (win == (WINDOW *)NULL) return( ERR );
+   if (win->_flags & _PAD) return( ERR );
+   if (win->_flags & _SUBPAD) return( ERR );
+
+   save_clear = win->_clear;
+   if (win == curscr)
+      curscr->_clear = TRUE;
+   else  
+      wnoutrefresh(win);
+   if (save_clear
+   &&  win->_maxy == PDC_SP->lines
+   &&  win->_maxx == PDC_SP->cols)
+      {
+      curscr->_clear = TRUE;
+      }
+   doupdate();
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   wnoutrefresh(WINDOW *win)
+#else
+int   PDC_CDECL   wnoutrefresh(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+register int      first=0; /* first changed char on line */
+register int      last=0;  /* last changed char on line  */
+   int      begy=0,begx=0; /* window's place on screen   */
+   int      i=0,j=0,x=0,y=0;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("wnoutrefresh() - called: win=%x\n",win);
+#endif
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+   if ((win->_flags == _PAD)
+   ||  (win->_flags == _SUBPAD))
+      return( ERR );
+
+   y = win->_cury;
+   x = win->_curx;
+
+   if (win->_title != NULL)
+   {
+      int len = strlen(win->_title);
+      chtype attrs = win->_attrs;
+   /*
+    * There may be a better place to implement window titles, but this
+    * seems to be the best place. -- Frotz
+    */
+      if ((len > 0)
+      && !(win->_flags & _SUBWIN)
+      && !(win->_flags & _SUBPAD))
+      {
+         wattrset(win, win->_title_attr);
+         mvwprintw(win, 0, (win->_title_ofs), "%s", (long) win->_title);
+         wmove(win, y, x); /* restore cursor postion */
+         wattrset(win, attrs);   /* restore attributes     */
+      }
+   }
+
+   if (win->_flags & _PAD)
+      return( ERR );
+
+   begy = win->_begy;
+   begx = win->_begx;
+
+   for (i = 0, j = begy; i < win->_maxy; i++, j++)
+   {
+      if (win->_firstch[i] != _NO_CHANGE)
+      {
+         first = win->_firstch[i];
+         last = win->_lastch[i];
+
+         memcpy(&(curscr->_y[j][begx + first]),
+                &(win->_y[i][first]),
+                (last - first + 1) * sizeof(chtype));
+
+         first += begx; /* s's min/max change positions */
+         last += begx;
+
+         if (curscr->_firstch[j] != _NO_CHANGE)
+            curscr->_firstch[j] = min(curscr->_firstch[j], first);
+         else
+            curscr->_firstch[j] = first;
+
+         curscr->_lastch[j] = max(curscr->_lastch[j], last);
+
+         win->_firstch[i] = _NO_CHANGE;   /* updated now */
+      }
+      win->_lastch[i] = _NO_CHANGE; /* updated now */
+   }
+
+   if (win->_clear)
+      win->_clear = FALSE;
+
+   if (!win->_leaveit)
+   {
+      curscr->_cury = win->_cury + begy;
+      curscr->_curx = win->_curx + begx;
+   }
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   doupdate(void)
+#else
+int   PDC_CDECL   doupdate()
+#endif
+/***********************************************************************/
+{
+register int   i;
+bool rc;
+#ifdef   REGISTERWINDOWS
+   WINDS*   next = PDC_SP->visible;
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("doupdate() - called\n");
+#endif
+
+   if (isendwin())  /* coming back after endwin() called */
+   {
+      reset_prog_mode();
+      curscr->_clear = TRUE;
+      PDC_SP->alive = TRUE; /* so isendwin() result is correct */
+   }
+
+#ifdef   REGISTERWINDOWS
+   if (PDC_SP->refreshall)
+   {
+      while (next != NULL)
+      {
+         if (next->w->_parent != NULL)
+         {
+            touchwin(next->w->_parent);
+            wnoutrefresh(next->w->_parent);
+         }
+         touchwin(next->w);
+         wnoutrefresh(next->w);
+         next = next->next;
+      }
+   }
+#endif
+
+   if (PDC_SP->shell)
+      reset_prog_mode();
+
+   if (curscr == (WINDOW *)NULL)
+      return( ERR );
+
+/* if checking for typeahead, bail out here if any is found */
+   
+   if (PDC_SP->refrbrk && (PDC_SP->cbreak || PDC_SP->raw_inp)) 
+   {
+      rc = PDC_breakout();
+      if(rc)
+         return( OK );
+   }
+
+   if (curscr->_clear)
+      PDC_clr_update(curscr);
+   else
+   {
+#ifdef WIN32
+      if (!PDC_SP->refrbrk
+      &&  getenv("PDC_FULL_DISPLAY") != NULL)
+         PDC_doupdate();
+      else
+      {
+         for (i = 0; i < PDC_SP->lines; i++)
+         {
+# ifdef PDCDEBUG
+   if (trace_on) PDC_debug("doupdate() - Transforming line %d of %d: %s\n",i,PDC_SP->lines,(curscr->_firstch[i] != _NO_CHANGE)?"Yes" : "No");
+#endif
+            if (curscr->_firstch[i] != _NO_CHANGE)
+               if (PDC_transform_line(i))  /* if test new */
+                  break;
+         }
+      }
+#else
+      for (i = 0; i < PDC_SP->lines; i++)
+      {
+         if (curscr->_firstch[i] != _NO_CHANGE)
+            if (PDC_transform_line(i))  /* if test new */
+               break;
+      }
+#endif
+   }
+
+# if defined (XCURSES)
+   XCursesInstructAndWait(CURSES_REFRESH);
+# endif
+
+   if (PDC_SP->cursrow != curscr->_cury
+   ||  PDC_SP->curscol != curscr->_curx)
+   {
+      PDC_gotoxy(curscr->_cury, curscr->_curx);
+      PDC_SP->cursrow = curscr->_cury;
+      PDC_SP->curscol = curscr->_curx;
+   }
+
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   redrawwin(WINDOW *win)
+#else
+int   PDC_CDECL   redrawwin(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("redrawwin() - called: win=%x\n",win);
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+   return(wredrawln(win,0,win->_maxy));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   wredrawln(WINDOW *win, int start, int num)
+#else
+int   PDC_CDECL   wredrawln(win,start,num)
+WINDOW *win;
+int start;
+int num;
+#endif
+/***********************************************************************/
+{
+   register int i;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("wredrawln() - called: win=%x start=%d num=%d\n",win,start,num);
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+   if  (start > win->_maxy || start + num > win->_maxy)
+      return( ERR );
+   for(i=start;i<start+num;i++)
+      {
+      win->_firstch[i] = 0;
+      win->_lastch[i] = win->_maxx - 1;
+      }
+   return( OK );
+}
Index: PDCurses/pdcurses/scroll.c
===================================================================
--- PDCurses/pdcurses/scroll.c	(revision 1)
+++ PDCurses/pdcurses/scroll.c	(working copy)
@@ -1,201 +1,201 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define  CURSES_LIBRARY 1
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif
-#include <curses.h>
-
-#ifdef HAVE_MEMORY_H
-# include <memory.h>
-#endif
-
-/* undefine any macros for functions defined in this module */
-#undef   scroll
-#undef   scrl
-#undef   wscrl
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_scroll  = "$Id: scroll.c,v 1.2 2002/05/26 01:14:45 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                        scroll
-
-  Synopsis:
-    int scroll(WINDOW *win);
-    int scrl(int n);
-    int wscrl(WINDOW *win, int n);
-
-  X/Open Description:
-    scroll() causes the window to scroll up one line.  This involves 
-    moving the lines in the window data strcture.
- 
-    With the scrl() and wscrl() routines, for positive n scroll the 
-    window up n lines (line i+n becomes i); otherwise scroll the 
-    window down n lines.
- 
-    For these functions to work, scrolling must be enabled via 
-    scrollok().
- 
-    Note that scrl() and scroll() may be macros.
- 
-    Note also that scrolling is not allowed if the supplied window 
-    is a PAD.
-
-  X/Open Return Value:
-    All functions return OK on success and ERR on error.
-
-  X/Open Errors:
-    No errors are defined for this function.
-
-  NOTE:
-    The behaviour of Unix curses is to clear the line with a space
-    and attributes of A_NORMAL. PDCurses clears the line with the
-    window's current attributes (including current colour). To get
-    the behaviour of PDCurses, #define PDCURSES_WCLR in curses.h or
-    add -DPDCURSES_WCLR to the compile switches.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      scroll                                Y        Y       Y
-      scrl                                  -        -      4.0
-      wscrl                                 -        -      4.0
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_CDECL scroll(WINDOW *win)
-#else
-int PDC_CDECL scroll(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("scroll() - called\n");
-#endif
-
-   if (win == (WINDOW *)NULL)
-      return( ERR );
-
-   return(wscrl(win,1));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int  PDC_CDECL wscrl(WINDOW *win, int n)
-#else
-int  PDC_CDECL wscrl(win,n)
-WINDOW *win;
-int n;
-#endif
-/***********************************************************************/
-{
-   register int   i;
-   register int   l;
-   chtype*  ptr;
-   chtype*  temp;
-   static   chtype   blank;
-
-   if (win == (WINDOW *)NULL)
-      return( ERR );
-
-#if defined(PDCURSES_WCLR)
-   blank = win->_blank | win->_attrs;
-#else
-/* wrs (4/10/93) account for window background */
-   blank = win->_bkgd;
-#endif
-
-   /*
-    * Check if window scrolls. Valid for window AND pad
-    */
-   if ( !win->_scroll )
-   {
-      return( ERR );
-   }
-
-   /* wrs -- 7/11/93 -- quick add to original scroll() routine to implement
-    *                   scrolling for a specified number of lines
-    *                   (not very efficient for more than 1 line)
-    */
-
-   if ( n >= 0 )
-   {
-      for ( l=0; l<n; l++ ) 
-      {
-         temp = win->_y[win->_tmarg];
-         for (i = win->_tmarg; (i < win->_bmarg); i++)
-         {
-            win->_y[i] = win->_y[i + 1];  /* re-arrange line
-                            * pointers */
-            win->_firstch[i] = 0;
-            win->_lastch[i] = win->_maxx - 1;
-         }
-         for (ptr = temp; (ptr - temp < win->_maxx); ptr++)
-            *ptr = blank;           /* make a blank line */
-         win->_y[win->_bmarg] = temp;
-         win->_firstch[win->_bmarg] = 0;
-         win->_lastch[win->_bmarg] = win->_maxx - 1;
-      }
-   }
-   else 
-   {
-      for ( l=n; l<0; l++ ) 
-      {
-         temp = win->_y[win->_bmarg];
-         for (i = win->_bmarg; (i > win->_tmarg); i--)
-         {
-            win->_y[i] = win->_y[i - 1];  /* re-arrange line
-                            * pointers */
-            win->_firstch[i] = 0;
-            win->_lastch[i] = win->_maxx - 1;
-         }
-         for (ptr = temp; (ptr - temp < win->_maxx); ptr++)
-            *ptr = blank;           /* make a blank line */
-         win->_y[win->_tmarg] = temp;
-         win->_firstch[win->_tmarg] = 0;
-         win->_lastch[win->_tmarg] = win->_maxx - 1;
-      }
-   }
-   PDC_sync(win);
-   return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_CDECL scrl(int n)
-#else
-int PDC_CDECL scrl(n)
-int n;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("scrl() - called\n");
-#endif
-
-   return(wscrl(stdscr,n));
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define  CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef HAVE_MEMORY_H
+# include <memory.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef   scroll
+#undef   scrl
+#undef   wscrl
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_scroll  = "$Id: scroll.c,v 1.2 2002/05/26 01:14:45 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        scroll
+
+  Synopsis:
+    int scroll(WINDOW *win);
+    int scrl(int n);
+    int wscrl(WINDOW *win, int n);
+
+  X/Open Description:
+    scroll() causes the window to scroll up one line.  This involves 
+    moving the lines in the window data strcture.
+ 
+    With the scrl() and wscrl() routines, for positive n scroll the 
+    window up n lines (line i+n becomes i); otherwise scroll the 
+    window down n lines.
+ 
+    For these functions to work, scrolling must be enabled via 
+    scrollok().
+ 
+    Note that scrl() and scroll() may be macros.
+ 
+    Note also that scrolling is not allowed if the supplied window 
+    is a PAD.
+
+  X/Open Return Value:
+    All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+    No errors are defined for this function.
+
+  NOTE:
+    The behaviour of Unix curses is to clear the line with a space
+    and attributes of A_NORMAL. PDCurses clears the line with the
+    window's current attributes (including current colour). To get
+    the behaviour of PDCurses, #define PDCURSES_WCLR in curses.h or
+    add -DPDCURSES_WCLR to the compile switches.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      scroll                                Y        Y       Y
+      scrl                                  -        -      4.0
+      wscrl                                 -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL scroll(WINDOW *win)
+#else
+int PDC_CDECL scroll(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("scroll() - called\n");
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+   return(wscrl(win,1));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int  PDC_CDECL wscrl(WINDOW *win, int n)
+#else
+int  PDC_CDECL wscrl(win,n)
+WINDOW *win;
+int n;
+#endif
+/***********************************************************************/
+{
+   register int   i;
+   register int   l;
+   chtype*  ptr;
+   chtype*  temp;
+   static   chtype   blank;
+
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+#if defined(PDCURSES_WCLR)
+   blank = win->_blank | win->_attrs;
+#else
+/* wrs (4/10/93) account for window background */
+   blank = win->_bkgd;
+#endif
+
+   /*
+    * Check if window scrolls. Valid for window AND pad
+    */
+   if ( !win->_scroll )
+   {
+      return( ERR );
+   }
+
+   /* wrs -- 7/11/93 -- quick add to original scroll() routine to implement
+    *                   scrolling for a specified number of lines
+    *                   (not very efficient for more than 1 line)
+    */
+
+   if ( n >= 0 )
+   {
+      for ( l=0; l<n; l++ ) 
+      {
+         temp = win->_y[win->_tmarg];
+         for (i = win->_tmarg; (i < win->_bmarg); i++)
+         {
+            win->_y[i] = win->_y[i + 1];  /* re-arrange line
+                            * pointers */
+            win->_firstch[i] = 0;
+            win->_lastch[i] = win->_maxx - 1;
+         }
+         for (ptr = temp; (ptr - temp < win->_maxx); ptr++)
+            *ptr = blank;           /* make a blank line */
+         win->_y[win->_bmarg] = temp;
+         win->_firstch[win->_bmarg] = 0;
+         win->_lastch[win->_bmarg] = win->_maxx - 1;
+      }
+   }
+   else 
+   {
+      for ( l=n; l<0; l++ ) 
+      {
+         temp = win->_y[win->_bmarg];
+         for (i = win->_bmarg; (i > win->_tmarg); i--)
+         {
+            win->_y[i] = win->_y[i - 1];  /* re-arrange line
+                            * pointers */
+            win->_firstch[i] = 0;
+            win->_lastch[i] = win->_maxx - 1;
+         }
+         for (ptr = temp; (ptr - temp < win->_maxx); ptr++)
+            *ptr = blank;           /* make a blank line */
+         win->_y[win->_tmarg] = temp;
+         win->_firstch[win->_tmarg] = 0;
+         win->_lastch[win->_tmarg] = win->_maxx - 1;
+      }
+   }
+   PDC_sync(win);
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL scrl(int n)
+#else
+int PDC_CDECL scrl(n)
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("scrl() - called\n");
+#endif
+
+   return(wscrl(stdscr,n));
+}
Index: PDCurses/pdcurses/instr.c
===================================================================
--- PDCurses/pdcurses/instr.c	(revision 1)
+++ PDCurses/pdcurses/instr.c	(working copy)
@@ -1,287 +1,287 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	instr
-#undef	innstr
-#undef	winstr
-#undef	winnstr
-#undef	mvinstr
-#undef	mvinnstr
-#undef	mvwinstr
-#undef	mvwinnstr
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef	move
-#  undef	wmove
-#  undef	inch
-#  undef	winch
-#  undef	mvwinch
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_instr  = "$Id: instr.c,v 1.1 2001/01/10 08:27:12 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                        instr
-
-  Synopsis:
-  	int instr(char *str);
-  	int innstr(char *str, int n);
-  	int winstr(WINDOW *win, char *str);
-  	int winnstr(WINDOW *win, char *str, int n);
-  	int mvinstr(int y, int x, char *str);
-  	int mvinnstr(int y, int x, char *str, int n);
-  	int mvwinstr(WINDOW *, int y, int x, char *str);
-  	int mvwinnstr(WINDOW *, int y, int x, char *str, int n);
-
-  System V Curses Description:
- 	These routines return a string of characters in str, starting at the
- 	current cursor position in the named window and ending at the right
- 	margin of the window.  Attributes are stripped from the characters.
- 	The four functions with n as the last argument return the string at most
- 	n characters long.
-
- 	Note:  instr(), innstr(), winstr(), mvinstr(), mvinnstr(),
- 		mvwinstr() and mvwinnstr() are all macros.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      instr                                 -        -      4.0
-      winstr                                -        -      4.0
-      mvinstr                               -        -      4.0
-      mvwinstr                              -        -      4.0
-      innstr                                -        -      4.0
-      winnstr                               -        -      4.0
-      mvinnstr                              -        -      4.0
-      mvwinnstr                             -        -      4.0
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	instr(char *str)
-#else
-int	PDC_CDECL	instr(str)
-char *str;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("instr() - called: string=\"%s\"\n",str);
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	return(winnstr(stdscr,str,stdscr->_maxx));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	innstr(char *str, int n)
-#else
-int	PDC_CDECL	innstr(str,n)
-char *str;
-int n;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("innstr() - called: n %d \n",n);
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	return(winnstr(stdscr,str,n));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	winstr(WINDOW *win, char *str)
-#else
-int	PDC_CDECL	winstr(win,str)
-WINDOW *win;
-char *str;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("winstr() - called: \n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	return(winnstr(win,str,win->_maxx));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	winnstr(WINDOW *win, char *str, int n)
-#else
-int	PDC_CDECL	winnstr(win,str,n)
-WINDOW *win;
-char *str;
-int n;
-#endif
-/***********************************************************************/
-{
-	chtype tmp;
-	int oldy = win->_cury;
-	int oldx = win->_curx;
-	int imax = (win->_maxx - win->_curx);
-	int ic;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("winnstr() - called: n %d \n",n);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if( n > 0 )
-		imax = ((imax<n)?imax:n);
-
-	for ( ic=0; ic < imax; ic++ )
-	{
-		tmp = mvwinch( win, oldy, oldx+ic );
-		if( tmp == ERR ) 
-		{
-			*(str+imax) = '\0';
-			return( ERR );
-		}
-		*(str+ic) = tmp & A_CHARTEXT;
-	}
-
-	*(str+imax) = '\0';
-
-	win->_curx = oldx;
-
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvinstr(int y, int x, char *str)
-#else
-int	PDC_CDECL	mvinstr(y,x,str)
-int y;
-int x;
-char *str;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvinstr() - called: y %d x %d \n",y,x);
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	if (move(y,x) == ERR)
-		return( ERR );
-
-	return(winnstr(stdscr,str,stdscr->_maxx));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvinnstr(int y, int x, char *str, int n)
-#else
-int	PDC_CDECL	mvinnstr(y,x,str,n)
-int y;
-int x;
-char *str;
-int n;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvinnstr() - called: y %d x %d n %d \n",y,x,n);
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	if (move(y,x) == ERR)
-		return( ERR );
-
-	return(winnstr(stdscr,str,n));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvwinstr(WINDOW *win, int y, int x, char *str)
-#else
-int	PDC_CDECL	mvwinstr(win,y,x,str)
-WINDOW *win;
-int y;
-int x;
-char *str;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvwinstr() - called: y %d x %d \n",y,x);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if (wmove(win,y,x) == ERR)
-		return( ERR );
-
-	return(winnstr(win,str,win->_maxx));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvwinnstr(WINDOW *win,int y, int x, char *str, int n)
-#else
-int	PDC_CDECL	mvwinnstr(win,y,x,str,n)
-WINDOW *win;
-int y;
-int x;
-char *str;
-int n;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvwinnstr() - called: y %d x %d n %d \n",y,x,n);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if (wmove(win,y,x) == ERR)
-		return( ERR );
-
-	return(winnstr(win,str,n));
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	instr
+#undef	innstr
+#undef	winstr
+#undef	winnstr
+#undef	mvinstr
+#undef	mvinnstr
+#undef	mvwinstr
+#undef	mvwinnstr
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	move
+#  undef	wmove
+#  undef	inch
+#  undef	winch
+#  undef	mvwinch
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_instr  = "$Id: instr.c,v 1.1 2001/01/10 08:27:12 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        instr
+
+  Synopsis:
+  	int instr(char *str);
+  	int innstr(char *str, int n);
+  	int winstr(WINDOW *win, char *str);
+  	int winnstr(WINDOW *win, char *str, int n);
+  	int mvinstr(int y, int x, char *str);
+  	int mvinnstr(int y, int x, char *str, int n);
+  	int mvwinstr(WINDOW *, int y, int x, char *str);
+  	int mvwinnstr(WINDOW *, int y, int x, char *str, int n);
+
+  System V Curses Description:
+ 	These routines return a string of characters in str, starting at the
+ 	current cursor position in the named window and ending at the right
+ 	margin of the window.  Attributes are stripped from the characters.
+ 	The four functions with n as the last argument return the string at most
+ 	n characters long.
+
+ 	Note:  instr(), innstr(), winstr(), mvinstr(), mvinnstr(),
+ 		mvwinstr() and mvwinnstr() are all macros.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      instr                                 -        -      4.0
+      winstr                                -        -      4.0
+      mvinstr                               -        -      4.0
+      mvwinstr                              -        -      4.0
+      innstr                                -        -      4.0
+      winnstr                               -        -      4.0
+      mvinnstr                              -        -      4.0
+      mvwinnstr                             -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	instr(char *str)
+#else
+int	PDC_CDECL	instr(str)
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("instr() - called: string=\"%s\"\n",str);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	return(winnstr(stdscr,str,stdscr->_maxx));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	innstr(char *str, int n)
+#else
+int	PDC_CDECL	innstr(str,n)
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("innstr() - called: n %d \n",n);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	return(winnstr(stdscr,str,n));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	winstr(WINDOW *win, char *str)
+#else
+int	PDC_CDECL	winstr(win,str)
+WINDOW *win;
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winstr() - called: \n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(winnstr(win,str,win->_maxx));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	winnstr(WINDOW *win, char *str, int n)
+#else
+int	PDC_CDECL	winnstr(win,str,n)
+WINDOW *win;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+	chtype tmp;
+	int oldy = win->_cury;
+	int oldx = win->_curx;
+	int imax = (win->_maxx - win->_curx);
+	int ic;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winnstr() - called: n %d \n",n);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if( n > 0 )
+		imax = ((imax<n)?imax:n);
+
+	for ( ic=0; ic < imax; ic++ )
+	{
+		tmp = mvwinch( win, oldy, oldx+ic );
+		if( tmp == ERR ) 
+		{
+			*(str+imax) = '\0';
+			return( ERR );
+		}
+		*(str+ic) = tmp & A_CHARTEXT;
+	}
+
+	*(str+imax) = '\0';
+
+	win->_curx = oldx;
+
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvinstr(int y, int x, char *str)
+#else
+int	PDC_CDECL	mvinstr(y,x,str)
+int y;
+int x;
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvinstr() - called: y %d x %d \n",y,x);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (move(y,x) == ERR)
+		return( ERR );
+
+	return(winnstr(stdscr,str,stdscr->_maxx));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvinnstr(int y, int x, char *str, int n)
+#else
+int	PDC_CDECL	mvinnstr(y,x,str,n)
+int y;
+int x;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvinnstr() - called: y %d x %d n %d \n",y,x,n);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (move(y,x) == ERR)
+		return( ERR );
+
+	return(winnstr(stdscr,str,n));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwinstr(WINDOW *win, int y, int x, char *str)
+#else
+int	PDC_CDECL	mvwinstr(win,y,x,str)
+WINDOW *win;
+int y;
+int x;
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwinstr() - called: y %d x %d \n",y,x);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(win,y,x) == ERR)
+		return( ERR );
+
+	return(winnstr(win,str,win->_maxx));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwinnstr(WINDOW *win,int y, int x, char *str, int n)
+#else
+int	PDC_CDECL	mvwinnstr(win,y,x,str,n)
+WINDOW *win;
+int y;
+int x;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwinnstr() - called: y %d x %d n %d \n",y,x,n);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(win,y,x) == ERR)
+		return( ERR );
+
+	return(winnstr(win,str,n));
+}
Index: PDCurses/pdcurses/getyx.c
===================================================================
--- PDCurses/pdcurses/getyx.c	(revision 1)
+++ PDCurses/pdcurses/getyx.c	(working copy)
@@ -1,201 +1,201 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	getbegy
-#undef	getbegx
-#undef	getmaxy
-#undef	getmaxx
-#undef	getpary
-#undef	getparx
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_getyx  = "$Id: getyx.c,v 1.1 2001/01/10 08:27:03 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                         getyx
-
-  Synopsis:
-  	void getyx(WINDOW *win, int y, int x);
-  	void getparyx(WINDOW *win, int y, int x);
-  	void getbegyx(WINDOW *win, int y, int x);
-  	void getmaxyx(WINDOW *win, int y, int x);
-
-  	int getbegy(WINDOW *win);
-  	int getbegx(WINDOW *win);
-  	int getpary(WINDOW *win);
-  	int getparx(WINDOW *win);
-  	int getmaxy(WINDOW *win);
-  	int getmaxx(WINDOW *win);
-
-  X/Open Description:
- 	With the getyx() macro, the cursor position of the window is placed
- 	in the two integer variables y and x. getbegyx() and getmaxyx()
- 	return the current beginning coordinates and size of the specified
- 	window respectively. getparyx() returns the beginning coordinates 
- 	of the parent's window if the specified window is a sub-window
- 	otherwise -1 is returned.
-
- 	These functions are implemented as macros, so their return values
- 	are undefined. Also as these functions are implemented as macros,
- 	no '&' is required before the variables y and x.
-
- 	The functions getbegy(), getbegx(), getmaxy(), getmaxx() ,
- 	getpary(), and getparx() do return the beginning coordinate or 
- 	size values, so they can be specified on the right-hand side of 
- 	an assignment statement. They are, however, implemented as macros.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      getyx                                 Y        Y       Y
-      getparyx                              -        -      4.0
-      getbegyx                              -        -      3.0
-      getmaxyx                              -        -      3.0
-      getbegy                               -        -       -
-      getbegx                               -        -       -
-      getpary                               -        -       -
-      getparx                               -        -       -
-      getmaxy                               -        -       -
-      getmaxx                               -        -       -
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	getbegy(WINDOW *win)
-#else
-int	PDC_CDECL	getbegy(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("getbegy() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	return(win->_begy);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	getbegx(WINDOW *win)
-#else
-int	PDC_CDECL	getbegx(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("getbegx() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	return(win->_begx);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	getpary(WINDOW *win)
-#else
-int	PDC_CDECL	getpary(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("getpary() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	return(win->_pary);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	getparx(WINDOW *win)
-#else
-int	PDC_CDECL	getparx(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("getparx() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	return(win->_parx);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	getmaxy(WINDOW *win)
-#else
-int	PDC_CDECL	getmaxy(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("getmaxy() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	return(win->_maxy);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	getmaxx(WINDOW *win)
-#else
-int	PDC_CDECL	getmaxx(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("getmaxx() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	return(win->_maxx);
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	getbegy
+#undef	getbegx
+#undef	getmaxy
+#undef	getmaxx
+#undef	getpary
+#undef	getparx
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_getyx  = "$Id: getyx.c,v 1.1 2001/01/10 08:27:03 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         getyx
+
+  Synopsis:
+  	void getyx(WINDOW *win, int y, int x);
+  	void getparyx(WINDOW *win, int y, int x);
+  	void getbegyx(WINDOW *win, int y, int x);
+  	void getmaxyx(WINDOW *win, int y, int x);
+
+  	int getbegy(WINDOW *win);
+  	int getbegx(WINDOW *win);
+  	int getpary(WINDOW *win);
+  	int getparx(WINDOW *win);
+  	int getmaxy(WINDOW *win);
+  	int getmaxx(WINDOW *win);
+
+  X/Open Description:
+ 	With the getyx() macro, the cursor position of the window is placed
+ 	in the two integer variables y and x. getbegyx() and getmaxyx()
+ 	return the current beginning coordinates and size of the specified
+ 	window respectively. getparyx() returns the beginning coordinates 
+ 	of the parent's window if the specified window is a sub-window
+ 	otherwise -1 is returned.
+
+ 	These functions are implemented as macros, so their return values
+ 	are undefined. Also as these functions are implemented as macros,
+ 	no '&' is required before the variables y and x.
+
+ 	The functions getbegy(), getbegx(), getmaxy(), getmaxx() ,
+ 	getpary(), and getparx() do return the beginning coordinate or 
+ 	size values, so they can be specified on the right-hand side of 
+ 	an assignment statement. They are, however, implemented as macros.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      getyx                                 Y        Y       Y
+      getparyx                              -        -      4.0
+      getbegyx                              -        -      3.0
+      getmaxyx                              -        -      3.0
+      getbegy                               -        -       -
+      getbegx                               -        -       -
+      getpary                               -        -       -
+      getparx                               -        -       -
+      getmaxy                               -        -       -
+      getmaxx                               -        -       -
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	getbegy(WINDOW *win)
+#else
+int	PDC_CDECL	getbegy(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("getbegy() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(win->_begy);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	getbegx(WINDOW *win)
+#else
+int	PDC_CDECL	getbegx(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("getbegx() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(win->_begx);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	getpary(WINDOW *win)
+#else
+int	PDC_CDECL	getpary(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("getpary() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(win->_pary);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	getparx(WINDOW *win)
+#else
+int	PDC_CDECL	getparx(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("getparx() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(win->_parx);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	getmaxy(WINDOW *win)
+#else
+int	PDC_CDECL	getmaxy(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("getmaxy() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(win->_maxy);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	getmaxx(WINDOW *win)
+#else
+int	PDC_CDECL	getmaxx(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("getmaxx() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(win->_maxx);
+}
Index: PDCurses/pdcurses/insch.c
===================================================================
--- PDCurses/pdcurses/insch.c	(revision 1)
+++ PDCurses/pdcurses/insch.c	(working copy)
@@ -1,197 +1,197 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	insch
-#undef	winsch
-#undef	mvinsch
-#undef	mvwinsch
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef	refresh
-#  undef	wrefresh
-#  undef	move
-#  undef	wmove
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_insch  = "$Id: insch.c,v 1.1 2001/01/10 08:27:10 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                         insch
-
-  Synopsis:
-  	int insch(chtype ch);
-  	int winsch(WINDOW *win, chtype ch);
-  	int mvinsch(int y, int x, chtype ch);
-  	int mvwinsch(WINDOW *win, int y, int x, chtype ch);
-
-  X/Open Description:
- 	The routine insch() inserts the character ch into the default
- 	window at the current cursor position and the window cursor is
- 	advanced.  The character is of the type chtype as containing
- 	both data and attributes.
-
- 	The routine winsch() inserts the character ch into the specified
- 	window at the current cursor position.  The cursor position is
- 	advanced.
-
- 	The routine mvinsch() moves the cursor to the specified (y, x)
- 	position and inserts the character ch into the default window.
- 	The cursor position is advanced after the character has been
- 	inserted.
-
- 	The routine mvwinsch() moves the cursor to the specified (y, x)
- 	position and inserts the character ch into the specified
- 	window.  The cursor position is advanced after the character
- 	has been inserted.
-
- 	The routine echochar() inserts the character ch into stdscr
- 	at the current cursor position and a refresh() is called.  
- 	The cursor position is advanced.
-
- 	The routine wechochar() inserts the character ch into the
- 	specified window at the current cursor position and a wrefresh() 
- 	is called. The cursor position is advanced.
-
- 	All these routines are similar to putchar().  The following
- 	information applies to all the routines.
-
- 	If the cursor moves on to the right margin, an automatic
- 	newline is performed.  If scrollok is enabled, and a character
- 	is added to the bottom right corner of the screen, the
- 	scrolling region will be scrolled up one line.  If scrolling
- 	is not allowed, ERR will be returned.
-
- 	If ch is a tab, newline, or backspace, the cursor will be
- 	moved appropriately within the window.  If ch is a newline,
- 	the clrtoeol routine is called before the cursor is moved to
- 	the beginning of the next line.  If newline mapping is off,
- 	the cursor will be moved to the next line, but the x
- 	coordinate will be unchanged.  If ch is a tab the cursor is
- 	moved to the next tab position within the window.  If ch is
- 	another control character, it will be drawn in the ^X
- 	notation.  Calling the inch() routine after adding a control
- 	character returns the representation of the control character,
- 	not the control character.
-
- 	Video attributes can be combined with a character by ORing
- 	them into the parameter.  This will result in these attributes
- 	being set.  The intent here is that text, including
- 	attributes, can be copied from one place to another using inch()
- 	and insch().
-
- 	NOTE: All these functions are implemented as macros.
-
-  PDCurses Description:
- 	Depending upon the state of the raw character output, 7- or
- 	8-bit characters will be output.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      insch                                 Y        Y       Y
-      winsch                                Y        Y       Y
-      mvinsch                               Y        Y       Y
-      mvwinsch                              Y        Y       Y
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	insch(chtype ch)
-#else
-int	PDC_CDECL	insch(ch)
-chtype ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("insch() - called\n");
-#endif
-
-	return( PDC_chins( stdscr, ch, (bool)(!(SP->raw_out))) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	winsch(WINDOW *win, chtype ch)
-#else
-int	PDC_CDECL	winsch(win,ch)
-WINDOW *win;
-chtype ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("winsch() - called\n");
-#endif
-
-	return( PDC_chins( win, ch, (bool)(!(SP->raw_out))) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvinsch(int y, int x, chtype ch)
-#else
-int	PDC_CDECL	mvinsch(y,x,ch)
-int y;
-int x;
-chtype ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvinsch() - called\n");
-#endif
-	if (move(y,x) == ERR)
-		return(ERR);
-	return( PDC_chins( stdscr, ch, (bool)(!(SP->raw_out))) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvwinsch(WINDOW *win, int y, int x, chtype ch)
-#else
-int	PDC_CDECL	mvwinsch(win,y,x,ch)
-WINDOW *win;
-int y;
-int x;
-chtype ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvwinsch() - called\n");
-#endif
-	if (wmove(win,y,x) == ERR)
-		return(ERR);
-	return( PDC_chins( win, ch, (bool)(!(SP->raw_out))) );
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	insch
+#undef	winsch
+#undef	mvinsch
+#undef	mvwinsch
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	refresh
+#  undef	wrefresh
+#  undef	move
+#  undef	wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_insch  = "$Id: insch.c,v 1.1 2001/01/10 08:27:10 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         insch
+
+  Synopsis:
+  	int insch(chtype ch);
+  	int winsch(WINDOW *win, chtype ch);
+  	int mvinsch(int y, int x, chtype ch);
+  	int mvwinsch(WINDOW *win, int y, int x, chtype ch);
+
+  X/Open Description:
+ 	The routine insch() inserts the character ch into the default
+ 	window at the current cursor position and the window cursor is
+ 	advanced.  The character is of the type chtype as containing
+ 	both data and attributes.
+
+ 	The routine winsch() inserts the character ch into the specified
+ 	window at the current cursor position.  The cursor position is
+ 	advanced.
+
+ 	The routine mvinsch() moves the cursor to the specified (y, x)
+ 	position and inserts the character ch into the default window.
+ 	The cursor position is advanced after the character has been
+ 	inserted.
+
+ 	The routine mvwinsch() moves the cursor to the specified (y, x)
+ 	position and inserts the character ch into the specified
+ 	window.  The cursor position is advanced after the character
+ 	has been inserted.
+
+ 	The routine echochar() inserts the character ch into stdscr
+ 	at the current cursor position and a refresh() is called.  
+ 	The cursor position is advanced.
+
+ 	The routine wechochar() inserts the character ch into the
+ 	specified window at the current cursor position and a wrefresh() 
+ 	is called. The cursor position is advanced.
+
+ 	All these routines are similar to putchar().  The following
+ 	information applies to all the routines.
+
+ 	If the cursor moves on to the right margin, an automatic
+ 	newline is performed.  If scrollok is enabled, and a character
+ 	is added to the bottom right corner of the screen, the
+ 	scrolling region will be scrolled up one line.  If scrolling
+ 	is not allowed, ERR will be returned.
+
+ 	If ch is a tab, newline, or backspace, the cursor will be
+ 	moved appropriately within the window.  If ch is a newline,
+ 	the clrtoeol routine is called before the cursor is moved to
+ 	the beginning of the next line.  If newline mapping is off,
+ 	the cursor will be moved to the next line, but the x
+ 	coordinate will be unchanged.  If ch is a tab the cursor is
+ 	moved to the next tab position within the window.  If ch is
+ 	another control character, it will be drawn in the ^X
+ 	notation.  Calling the inch() routine after adding a control
+ 	character returns the representation of the control character,
+ 	not the control character.
+
+ 	Video attributes can be combined with a character by ORing
+ 	them into the parameter.  This will result in these attributes
+ 	being set.  The intent here is that text, including
+ 	attributes, can be copied from one place to another using inch()
+ 	and insch().
+
+ 	NOTE: All these functions are implemented as macros.
+
+  PDCurses Description:
+ 	Depending upon the state of the raw character output, 7- or
+ 	8-bit characters will be output.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      insch                                 Y        Y       Y
+      winsch                                Y        Y       Y
+      mvinsch                               Y        Y       Y
+      mvwinsch                              Y        Y       Y
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	insch(chtype ch)
+#else
+int	PDC_CDECL	insch(ch)
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("insch() - called\n");
+#endif
+
+	return( PDC_chins( stdscr, ch, (bool)(!(PDC_SP->raw_out))) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	winsch(WINDOW *win, chtype ch)
+#else
+int	PDC_CDECL	winsch(win,ch)
+WINDOW *win;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winsch() - called\n");
+#endif
+
+	return( PDC_chins( win, ch, (bool)(!(PDC_SP->raw_out))) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvinsch(int y, int x, chtype ch)
+#else
+int	PDC_CDECL	mvinsch(y,x,ch)
+int y;
+int x;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvinsch() - called\n");
+#endif
+	if (move(y,x) == ERR)
+		return(ERR);
+	return( PDC_chins( stdscr, ch, (bool)(!(PDC_SP->raw_out))) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwinsch(WINDOW *win, int y, int x, chtype ch)
+#else
+int	PDC_CDECL	mvwinsch(win,y,x,ch)
+WINDOW *win;
+int y;
+int x;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwinsch() - called\n");
+#endif
+	if (wmove(win,y,x) == ERR)
+		return(ERR);
+	return( PDC_chins( win, ch, (bool)(!(PDC_SP->raw_out))) );
+}
Index: PDCurses/pdcurses/pdcutil.c
===================================================================
--- PDCurses/pdcurses/pdcutil.c	(revision 1)
+++ PDCurses/pdcurses/pdcutil.c	(working copy)
@@ -1,694 +1,694 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#define	INCLUDE_WINDOWS_H
-#include <curses.h>
-
-#undef PDC_usleep
-
-#ifdef TIME_WITH_SYS_TIME
-# include <sys/time.h>
-# include <time.h>
-#else
-# ifdef HAVE_SYS_TIME_H
-#  include <sys/time.h>
-# else
-#  include <time.h>
-# endif
-#endif
-
-#ifdef HAVE_UNISTD_H
-#  include <unistd.h>
-#endif
-
-#include <stdlib.h>
-#include <ctype.h>
-#include <stdio.h>
-
-#ifdef HAVE_LIMITS_H
-#  include <limits.h>
-#endif
-
-#ifdef STDC_HEADERS
-#  include <string.h>
-#endif
-
-#if defined(HAVE_STDARG_H) && defined(HAVE_PROTO)
-#  include <stdarg.h>
-#  define HAVE_STDARG_H_HAVE_PROTO
-#else
-#  include <varargs.h>
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_PDCutil  = "$Id: pdcutil.c,v 1.1 2001/01/10 08:27:22 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  PDC_memmove()	- Replacement memmove() for lacking compliers.
-
-  PDCurses Description:
- 	This is a private PDCurses routine.
-
- 	Move a portion of memory taking consideration of overlapping memory
- 	areas.
-
-  PDCurses Return Value:
- 	This function returns NULL if no temporary memory could be allocated.
-
-  Portability:
- 	PDCurses	int PDC_memmove(void *s1,const void *s2,size_t n);
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-void *PDC_memmove (void *s1, const void *s2, size_t n)
-#else
-void *PDC_memmove (s1,s2,n)
-void *s1;
-void *s2;
-size_t n;
-#endif
-/***********************************************************************/
-{
-  char *dd=NULL;
-#ifdef HAVE_PROTO
-  const char *ss=NULL;
-#else
-  char *ss=NULL;
-#endif
-
-  dd = (char *)s1;
-#ifdef HAVE_PROTO
-  ss = (const char *)s2;
-#else
-  ss = (char *)s2;
-#endif
-  if (dd > ss && dd < ss + n)
-    {
-      dd += n;
-      ss += n;
-      while (n--)
-        *--dd = *--ss;
-    }
-  else
-    while (n--)
-      *dd++ = *ss++;
-  return s1;
-}
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-void PDC_beep (void)
-#else
-void PDC_beep ()
-#endif
-/***********************************************************************/
-{
-#ifdef UNIX
-	if (bell != NULL)
-		putp(bell);
-#endif
-
-#if defined (XCURSES)
-	XCursesInstruct(CURSES_BELL);
-#endif
-
-#if defined(DOS) 
-	PDC_putctty( (chtype)'\007', 0 );
-#endif
-
-#if defined(OS2)
-#   if defined(EMXVIDEO)
-	putchar('\007');
-#   else
-	DosBeep( 1380, 100 );
-#   endif
-#endif
-
-#if defined(WIN32)
-/*	MessageBeep(MB_OK); */
-	MessageBeep(0XFFFFFFFF);
-#endif
-
-  return;
-}
-
-/*man-start*********************************************************************
-
-  PDC_usleep()	- waits for specified number of microseconds
-
-  PDCurses Description:
- 	This routine is intended to provide a mechanism to wait the
- 	specified number of microseconds. It is provided for those
- 	platforms that do not have their own usleep() function.
-
-  Portability:
- 	PDCurses	void PDC_usleep( clock_t );
-
-  Acknowledgement
- 	PDC_usleep() was written by John Steele  (jsteele@netcom.com)
- 	and hacked savagely by Mark Hessling
-
-**man-end**********************************************************************/
-
-
-/***********************************************************************/
-#if defined(HAVE_USLEEP)
-# ifdef HAVE_PROTO
-void	PDC_usleep(long wait)
-# else
-void	PDC_usleep(wait)
-long wait;
-# endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_usleep() - called\n");
-#endif
-	usleep(wait);
-	return;
-}
-/***********************************************************************/
-#elif defined(HAVE_POLL)
-#   include <poll.h>
-#   ifdef HAVE_PROTO
-void	PDC_usleep(long wait)
-#   else
-void	PDC_usleep(wait)
-long wait;
-#   endif
-/***********************************************************************/
-{
-	struct pollfd fd;
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_usleep() - called\n");
-#endif
-	poll(&fd,0L,min(1L,wait/1000));
-	return;
-}
-/***********************************************************************/
-# else
-#  ifdef HAVE_PROTO
-void	PDC_usleep(long wait)
-#  else
-void	PDC_usleep(wait)
-long wait;
-#  endif
-/***********************************************************************/
-{
-#ifndef WIN32
-	clock_t goal;
-#endif
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_usleep() - called\n");
-# endif
-
-#if defined(WIN32)
-	Sleep(wait);
-#else
-	goal = (clock_t)wait + clock();
-	while (goal > clock())
-	;
-#endif
-	return;
-}
-#endif
-
-#ifndef HAVE_VSSCANF
-/*
- * Do not compile this module unless required.  This is due to the
- * requirement of some compilers; at least Borland C++ 3.0, of having
- * to link with math libraries due to the use of floats in the code.
- *
- * This module is based on vsscanf.c and input.c from emx 0.8f library
- * source which is Copyright (c) 1990-1992 by Eberhard Mattes.
- * Eberhard Mattes has kindly agreed to allow this module to be incorporated
- * into PDCurses.
- */
-
-/*man-start*********************************************************************
-
-  PDC_vsscanf()	- Internal routine to parse and format an input buffer.
-
-  PDCurses Description:
- 	This is a private PDCurses routine.
-
- 	Scan a series of input fields. Each field is formatted according to
- 	a supplied format string and the formatted input is stored in the
- 	variable number of addresses passed.
-
-  PDCurses Return Value:
- 	This function returns the number of input fields or EOF on error.
-
-  PDCurses Errors:
- 	If the supplied data is invalid or an incorrect number of arguments
- 	are passed, EOF is returned as an error.
-
-  Portability:
- 	PDCurses	int PDC_vsscanf(char *buf,const char *fmt,va_list arg_ptr);
-
-**man-end**********************************************************************/
-
-#define WHITE(x) ((x) == ' ' || (x) == '\t' || (x) == '\n')
-
-#define NEXT(x) \
-        do { \
-            x = *buf++; \
-            if (x == '\0') \
-               return (count == 0 ? EOF : count); \
-            ++chars; \
-           } while (0)
-
-#define UNGETC(x) \
-        do { \
-            --buf; *buf = x; --chars; \
-           } while (0)
-
-/***********************************************************************/
-#ifdef HAVE_STDARG_H_HAVE_PROTO
-int PDC_vsscanf ( char *buf, const char *fmt, va_list arg_ptr)
-#else
-int PDC_vsscanf (buf,fmt,va_alist)
-char *buf;
-char *fmt;
-va_dcl
-#endif
-/***********************************************************************/
-{
-#if !defined(HAVE_STDARG_H_HAVE_PROTO)
-	va_list arg_ptr;
-#endif
-	int count, chars, c, width, radix, d, i;
-	int *int_ptr;
-	long *long_ptr;
-	short *short_ptr;
-	char *char_ptr;
-	unsigned char f;
-	char neg, assign, ok, size;
-	unsigned long n;
-	char map[256], end;
-	double dx, dd, *dbl_ptr;
-	float *flt_ptr;
-	int exp;
-	char eneg;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_vsscanf() - called\n");
-#endif
-
-#if 0
-# ifdef HAVE_STDARG_H_HAVE_PROTO
-	va_start(arg_ptr, fmt);
-# else
-	va_start(arg_ptr);
-# endif
-#else
-# if !defined(HAVE_STDARG_H_HAVE_PROTO)
-	va_start(arg_ptr);
-# endif
-#endif
-
-  count = 0; chars = 0; c = 0;
-  while ((f = *fmt) != 0)
-    {
-      if (WHITE (f))
-        {
-          do
-            {
-              ++fmt; f = *fmt;
-            } while (WHITE (f));
-          do
-            {
-              c = *buf++;
-              if (c == '\0')
-                {
-                  if (f == 0 || count != 0)
-                    return (count);
-                  else
-                    return (EOF);
-                }
-              else
-                ++chars;
-            } while (WHITE (c));
-          UNGETC (c);
-        }
-      else if (f != '%')
-        {
-          NEXT (c);
-          if (c != f)
-            return (count);
-          ++fmt;
-        }
-      else
-        {
-          assign = TRUE; width = INT_MAX;
-          char_ptr = NULL;
-          ++fmt;
-          if (*fmt == '*')
-            {
-              assign = FALSE;
-              ++fmt;
-            }
-          if (isdigit (*fmt))
-            {
-              width = 0;
-              while (isdigit (*fmt))
-                width = width * 10 + (*fmt++ - '0');
-              if (width == 0) width = INT_MAX;
-            }
-          size = 0;
-          if (*fmt == 'h' || *fmt == 'l')
-            size = *fmt++;
-          f = *fmt;
-          switch (f)
-            {
-            case 'c':
-              if (width == INT_MAX)
-                width = 1;
-              if (assign)
-                char_ptr = va_arg (arg_ptr, char *);
-              while (width > 0)
-                {
-                  --width;
-                  NEXT (c);
-                  if (assign)
-                    {
-                      *char_ptr++ = (char)c;
-                      ++count;
-                    }
-                }
-              break;
-            case '[':
-              (void)memset (map, 0, 256);
-              end = 0;
-              ++fmt;
-              if (*fmt == '^')
-                {
-                  ++fmt; end = 1;
-                }
-              i = 0;
-              for (;;)
-                {
-                  f = (unsigned char)*fmt;
-                  switch (f)
-                    {
-                    case 0:
-                      --fmt;       /* avoid skipping past 0 */
-                      NEXT (c);
-                      goto string;
-                    case ']':
-                      if (i > 0)
-                        {
-                          NEXT (c);
-                          goto string;
-                        }
-                      /* no break */
-                    default:
-                      if (fmt[1] == '-' && fmt[2] != 0 &&
-                          f < (unsigned char)fmt[2])
-                        {
-                          (void)memset (map+f, 1, (unsigned char)fmt[2]-f);
-                          fmt += 2;
-                        }
-                      else
-                        map[f] = 1;
-                      break;
-                    }
-                  ++fmt; ++i;
-                }
-            case 's':
-              (void)memset (map, 0, 256);
-              map[' '] = 1;
-              map['\n'] = 1;
-              map['\r'] = 1;
-              map['\t'] = 1;
-              end = 1;
-              do
-                {
-                  NEXT (c);
-                } while (WHITE (c));
-string:
-              if (assign)
-                char_ptr = va_arg (arg_ptr, char *);
-              while (width > 0 && map[(unsigned char)c] != end)
-                {
-                  --width;
-                  if (assign)
-                    *char_ptr++ = (char)c;
-                  c = *buf++;
-                  if (c == '\0')
-                    break;
-                  else
-                    ++chars;
-                }
-              if (assign)
-                {
-                  *char_ptr = 0;
-                  ++count;
-                }
-              if (c == '\0')
-                return (count);
-              else
-                UNGETC (c);
-              break;
-            case 'f':
-            case 'e':
-            case 'E':
-            case 'g':
-            case 'G':
-              neg = ok = FALSE; dx = 0.0;
-              do
-                {
-                  NEXT (c);
-                } while (WHITE (c));
-              if (c == '+')
-                {
-                  NEXT (c); --width;
-                }
-              else if (c == '-')
-                {
-                  neg = TRUE; NEXT (c); --width;
-                }
-              while (width > 0 && isdigit (c))
-                {
-                  --width;
-                  dx = dx * 10.0 + (double)(c - '0');
-                  ok = TRUE;
-                  c = *buf++;
-                  if (c == '\0')
-                    break;
-                  else
-                    ++chars;
-                }
-              if (width > 0 && c == '.')
-                {
-                  --width;
-                  dd = 10.0; NEXT (c);
-                  while (width > 0 && isdigit (c))
-                    {
-                      --width;
-                      dx += (double)(c - '0') / dd;
-                      dd *= 10.0;
-                      ok = TRUE;
-                      c = *buf++;
-                      if (c == '\0')
-                        break;
-                      else
-                        ++chars;
-                    }
-                }
-              if (!ok)
-                return (count);
-              if (width > 0 && (c == 'e' || c == 'E'))
-                {
-                  eneg = FALSE; exp = 0; NEXT (c); --width;
-                  if (width > 0 && c == '+')
-                    {
-                      NEXT (c); --width;
-                    }
-                  else if (width > 0 && c == '-')
-                    {
-                      eneg = TRUE; NEXT (c); --width;
-                    }
-                  if (!(width > 0 && isdigit (c)))
-                    {
-                      UNGETC (c);
-                      return (count);
-                    }
-                  while (width > 0 && isdigit (c))
-                    {
-                      --width;
-                      exp = exp * 10 + (c - '0');
-                      c = *buf++;
-                      if (c == '\0')
-                        break;
-                      else
-                        ++chars;
-                    }
-                  if (eneg) exp = -exp;
-                  while (exp > 0)
-                    {
-                      dx *= 10.0;
-                      --exp;
-                    }
-                  while (exp < 0)
-                    {
-                      dx /= 10.0;
-                      ++exp;
-                    }
-                }
-              if (assign)
-                {
-                  if (neg) dx = -dx;
-                  if (size == 'l')
-                    {
-                      dbl_ptr = va_arg (arg_ptr, double *);
-                      *dbl_ptr = dx;
-                    }
-                  else
-                    {
-                      flt_ptr = va_arg (arg_ptr, float *);
-                      *flt_ptr = (float)dx;
-                    }
-                  ++count;
-                }
-              if (c == '\0')
-                return (count);
-              else
-                UNGETC (c);
-              break;
-            case 'i':
-              neg = FALSE; radix = 10;
-              do
-                {
-                  NEXT (c);
-                } while (WHITE (c));
-              if (!(width > 0 && c == '0'))
-                goto scan_complete_number;
-              NEXT (c); --width;
-              if (width > 0 && (c == 'x' || c == 'X'))
-                {
-                  NEXT (c); radix = 16; --width;
-                }
-              else if (width > 0 && (c >= '0' && c <= '7'))
-                radix = 8;
-              goto scan_unsigned_number;
-            case 'd':
-            case 'u':
-            case 'o':
-            case 'x':
-            case 'X':
-              do
-                {
-                  NEXT (c);
-                } while (WHITE (c));
-              switch (f)
-                {
-                case 'o':           radix = 8; break;
-                case 'x': case 'X': radix = 16; break;
-                default:            radix = 10; break;
-                }
-scan_complete_number:
-              neg = FALSE;
-              if (width > 0 && c == '+')
-                {
-                  NEXT (c); --width;
-                }
-              else if (width > 0 && c == '-' && radix == 10)
-                {
-                  neg = TRUE; NEXT (c); --width;
-                }
-scan_unsigned_number:
-              n = 0; ok = FALSE;
-              while (width > 0)
-                {
-                  --width;
-                  if (isdigit (c))
-                    d = c - '0';
-                  else if (isupper (c))
-                    d = c - 'A' + 10;
-                  else if (islower (c))
-                    d = c - 'a' + 10;
-                  else
-                    break;
-                  if (d < 0 || d >= radix)
-                    break;
-                  ok = TRUE;
-                  n = n * radix + d;
-                  c = *buf++;
-                  if (c == '\0')
-                    break;
-                  else
-                    ++chars;
-                }
-              if (!ok)
-                return (count);
-              if (assign)
-                {
-                  if (neg) n = -n;
-                  switch(size)
-                     {
-                      case 'h':
-                              short_ptr = va_arg (arg_ptr, short *);
-                              *short_ptr = (short)n;
-                              break;
-                      case 'l':
-                              long_ptr = va_arg (arg_ptr, long *);
-                              *long_ptr = (long)n;
-                              break;
-                      default:
-                              int_ptr = va_arg (arg_ptr, int *);
-                              *int_ptr = (int)n;
-                     }
-                  ++count;
-                }
-              if (c == '\0')
-                return (count);
-              else
-                UNGETC (c);
-              break;
-            case 'n':
-              if (assign)
-                {
-                  int_ptr = va_arg (arg_ptr, int *);
-                  *int_ptr = chars;
-                  ++count;
-                }
-              break;
-            default:
-              if (f == 0)                 /* % at end of string */
-                return (count);
-              NEXT (c);
-              if (c != f)
-                return (count);
-              break;
-            }
-          ++fmt;
-        }
-    }
-  return (count);
-}
-#endif
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#define	INCLUDE_WINDOWS_H
+#include <curses.h>
+
+#undef PDC_usleep
+
+#ifdef TIME_WITH_SYS_TIME
+# include <sys/time.h>
+# include <time.h>
+#else
+# ifdef HAVE_SYS_TIME_H
+#  include <sys/time.h>
+# else
+#  include <time.h>
+# endif
+#endif
+
+#ifdef HAVE_UNISTD_H
+#  include <unistd.h>
+#endif
+
+#include <stdlib.h>
+#include <ctype.h>
+#include <stdio.h>
+
+#ifdef HAVE_LIMITS_H
+#  include <limits.h>
+#endif
+
+#ifdef STDC_HEADERS
+#  include <string.h>
+#endif
+
+#if defined(HAVE_STDARG_H) && defined(HAVE_PROTO)
+#  include <stdarg.h>
+#  define HAVE_STDARG_H_HAVE_PROTO
+#else
+#  include <varargs.h>
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_PDCutil  = "$Id: pdcutil.c,v 1.1 2001/01/10 08:27:22 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_memmove()	- Replacement memmove() for lacking compliers.
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Move a portion of memory taking consideration of overlapping memory
+ 	areas.
+
+  PDCurses Return Value:
+ 	This function returns NULL if no temporary memory could be allocated.
+
+  Portability:
+ 	PDCurses	int PDC_memmove(void *s1,const void *s2,size_t n);
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void *PDC_memmove (void *s1, const void *s2, size_t n)
+#else
+void *PDC_memmove (s1,s2,n)
+void *s1;
+void *s2;
+size_t n;
+#endif
+/***********************************************************************/
+{
+  char *dd=NULL;
+#ifdef HAVE_PROTO
+  const char *ss=NULL;
+#else
+  char *ss=NULL;
+#endif
+
+  dd = (char *)s1;
+#ifdef HAVE_PROTO
+  ss = (const char *)s2;
+#else
+  ss = (char *)s2;
+#endif
+  if (dd > ss && dd < ss + n)
+    {
+      dd += n;
+      ss += n;
+      while (n--)
+        *--dd = *--ss;
+    }
+  else
+    while (n--)
+      *dd++ = *ss++;
+  return s1;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void PDC_beep (void)
+#else
+void PDC_beep ()
+#endif
+/***********************************************************************/
+{
+#ifdef UNIX
+	if (bell != NULL)
+		putp(bell);
+#endif
+
+#if defined (XCURSES)
+	XCursesInstruct(CURSES_BELL);
+#endif
+
+#if defined(DOS) 
+	PDC_putctty( (chtype)'\007', 0 );
+#endif
+
+#if defined(OS2)
+#   if defined(EMXVIDEO)
+	putchar('\007');
+#   else
+	DosBeep( 1380, 100 );
+#   endif
+#endif
+
+#if defined(WIN32)
+/*	MessageBeep(MB_OK); */
+	MessageBeep(0XFFFFFFFF);
+#endif
+
+  return;
+}
+
+/*man-start*********************************************************************
+
+  PDC_usleep()	- waits for specified number of microseconds
+
+  PDCurses Description:
+ 	This routine is intended to provide a mechanism to wait the
+ 	specified number of microseconds. It is provided for those
+ 	platforms that do not have their own usleep() function.
+
+  Portability:
+ 	PDCurses	void PDC_usleep( clock_t );
+
+  Acknowledgement
+ 	PDC_usleep() was written by John Steele  (jsteele@netcom.com)
+ 	and hacked savagely by Mark Hessling
+
+**man-end**********************************************************************/
+
+
+/***********************************************************************/
+#if defined(HAVE_USLEEP)
+# ifdef HAVE_PROTO
+void	PDC_usleep(long wait)
+# else
+void	PDC_usleep(wait)
+long wait;
+# endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_usleep() - called\n");
+#endif
+	usleep(wait);
+	return;
+}
+/***********************************************************************/
+#elif defined(HAVE_POLL)
+#   include <poll.h>
+#   ifdef HAVE_PROTO
+void	PDC_usleep(long wait)
+#   else
+void	PDC_usleep(wait)
+long wait;
+#   endif
+/***********************************************************************/
+{
+	struct pollfd fd;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_usleep() - called\n");
+#endif
+	poll(&fd,0L,min(1L,wait/1000));
+	return;
+}
+/***********************************************************************/
+# else
+#  ifdef HAVE_PROTO
+void	PDC_usleep(long wait)
+#  else
+void	PDC_usleep(wait)
+long wait;
+#  endif
+/***********************************************************************/
+{
+#ifndef WIN32
+	clock_t goal;
+#endif
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_usleep() - called\n");
+# endif
+
+#if defined(WIN32)
+	Sleep(wait);
+#else
+	goal = (clock_t)wait + clock();
+	while (goal > clock())
+	;
+#endif
+	return;
+}
+#endif
+
+#ifndef HAVE_VSSCANF
+/*
+ * Do not compile this module unless required.  This is due to the
+ * requirement of some compilers; at least Borland C++ 3.0, of having
+ * to link with math libraries due to the use of floats in the code.
+ *
+ * This module is based on vsscanf.c and input.c from emx 0.8f library
+ * source which is Copyright (c) 1990-1992 by Eberhard Mattes.
+ * Eberhard Mattes has kindly agreed to allow this module to be incorporated
+ * into PDCurses.
+ */
+
+/*man-start*********************************************************************
+
+  PDC_vsscanf()	- Internal routine to parse and format an input buffer.
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Scan a series of input fields. Each field is formatted according to
+ 	a supplied format string and the formatted input is stored in the
+ 	variable number of addresses passed.
+
+  PDCurses Return Value:
+ 	This function returns the number of input fields or EOF on error.
+
+  PDCurses Errors:
+ 	If the supplied data is invalid or an incorrect number of arguments
+ 	are passed, EOF is returned as an error.
+
+  Portability:
+ 	PDCurses	int PDC_vsscanf(char *buf,const char *fmt,va_list arg_ptr);
+
+**man-end**********************************************************************/
+
+#define WHITE(x) ((x) == ' ' || (x) == '\t' || (x) == '\n')
+
+#define NEXT(x) \
+        do { \
+            x = *buf++; \
+            if (x == '\0') \
+               return (count == 0 ? EOF : count); \
+            ++chars; \
+           } while (0)
+
+#define UNGETC(x) \
+        do { \
+            --buf; *buf = x; --chars; \
+           } while (0)
+
+/***********************************************************************/
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+int PDC_vsscanf ( char *buf, const char *fmt, va_list arg_ptr)
+#else
+int PDC_vsscanf (buf,fmt,va_alist)
+char *buf;
+char *fmt;
+va_dcl
+#endif
+/***********************************************************************/
+{
+#if !defined(HAVE_STDARG_H_HAVE_PROTO)
+	va_list arg_ptr;
+#endif
+	int count, chars, c, width, radix, d, i;
+	int *int_ptr;
+	long *long_ptr;
+	short *short_ptr;
+	char *char_ptr;
+	unsigned char f;
+	char neg, assign, ok, size;
+	unsigned long n;
+	char map[256], end;
+	double dx, dd, *dbl_ptr;
+	float *flt_ptr;
+	int exp;
+	char eneg;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_vsscanf() - called\n");
+#endif
+
+#if 0
+# ifdef HAVE_STDARG_H_HAVE_PROTO
+	va_start(arg_ptr, fmt);
+# else
+	va_start(arg_ptr);
+# endif
+#else
+# if !defined(HAVE_STDARG_H_HAVE_PROTO)
+	va_start(arg_ptr);
+# endif
+#endif
+
+  count = 0; chars = 0; c = 0;
+  while ((f = *fmt) != 0)
+    {
+      if (WHITE (f))
+        {
+          do
+            {
+              ++fmt; f = *fmt;
+            } while (WHITE (f));
+          do
+            {
+              c = *buf++;
+              if (c == '\0')
+                {
+                  if (f == 0 || count != 0)
+                    return (count);
+                  else
+                    return (EOF);
+                }
+              else
+                ++chars;
+            } while (WHITE (c));
+          UNGETC (c);
+        }
+      else if (f != '%')
+        {
+          NEXT (c);
+          if (c != f)
+            return (count);
+          ++fmt;
+        }
+      else
+        {
+          assign = TRUE; width = INT_MAX;
+          char_ptr = NULL;
+          ++fmt;
+          if (*fmt == '*')
+            {
+              assign = FALSE;
+              ++fmt;
+            }
+          if (isdigit (*fmt))
+            {
+              width = 0;
+              while (isdigit (*fmt))
+                width = width * 10 + (*fmt++ - '0');
+              if (width == 0) width = INT_MAX;
+            }
+          size = 0;
+          if (*fmt == 'h' || *fmt == 'l')
+            size = *fmt++;
+          f = *fmt;
+          switch (f)
+            {
+            case 'c':
+              if (width == INT_MAX)
+                width = 1;
+              if (assign)
+                char_ptr = va_arg (arg_ptr, char *);
+              while (width > 0)
+                {
+                  --width;
+                  NEXT (c);
+                  if (assign)
+                    {
+                      *char_ptr++ = (char)c;
+                      ++count;
+                    }
+                }
+              break;
+            case '[':
+              (void)memset (map, 0, 256);
+              end = 0;
+              ++fmt;
+              if (*fmt == '^')
+                {
+                  ++fmt; end = 1;
+                }
+              i = 0;
+              for (;;)
+                {
+                  f = (unsigned char)*fmt;
+                  switch (f)
+                    {
+                    case 0:
+                      --fmt;       /* avoid skipping past 0 */
+                      NEXT (c);
+                      goto string;
+                    case ']':
+                      if (i > 0)
+                        {
+                          NEXT (c);
+                          goto string;
+                        }
+                      /* no break */
+                    default:
+                      if (fmt[1] == '-' && fmt[2] != 0 &&
+                          f < (unsigned char)fmt[2])
+                        {
+                          (void)memset (map+f, 1, (unsigned char)fmt[2]-f);
+                          fmt += 2;
+                        }
+                      else
+                        map[f] = 1;
+                      break;
+                    }
+                  ++fmt; ++i;
+                }
+            case 's':
+              (void)memset (map, 0, 256);
+              map[' '] = 1;
+              map['\n'] = 1;
+              map['\r'] = 1;
+              map['\t'] = 1;
+              end = 1;
+              do
+                {
+                  NEXT (c);
+                } while (WHITE (c));
+string:
+              if (assign)
+                char_ptr = va_arg (arg_ptr, char *);
+              while (width > 0 && map[(unsigned char)c] != end)
+                {
+                  --width;
+                  if (assign)
+                    *char_ptr++ = (char)c;
+                  c = *buf++;
+                  if (c == '\0')
+                    break;
+                  else
+                    ++chars;
+                }
+              if (assign)
+                {
+                  *char_ptr = 0;
+                  ++count;
+                }
+              if (c == '\0')
+                return (count);
+              else
+                UNGETC (c);
+              break;
+            case 'f':
+            case 'e':
+            case 'E':
+            case 'g':
+            case 'G':
+              neg = ok = FALSE; dx = 0.0;
+              do
+                {
+                  NEXT (c);
+                } while (WHITE (c));
+              if (c == '+')
+                {
+                  NEXT (c); --width;
+                }
+              else if (c == '-')
+                {
+                  neg = TRUE; NEXT (c); --width;
+                }
+              while (width > 0 && isdigit (c))
+                {
+                  --width;
+                  dx = dx * 10.0 + (double)(c - '0');
+                  ok = TRUE;
+                  c = *buf++;
+                  if (c == '\0')
+                    break;
+                  else
+                    ++chars;
+                }
+              if (width > 0 && c == '.')
+                {
+                  --width;
+                  dd = 10.0; NEXT (c);
+                  while (width > 0 && isdigit (c))
+                    {
+                      --width;
+                      dx += (double)(c - '0') / dd;
+                      dd *= 10.0;
+                      ok = TRUE;
+                      c = *buf++;
+                      if (c == '\0')
+                        break;
+                      else
+                        ++chars;
+                    }
+                }
+              if (!ok)
+                return (count);
+              if (width > 0 && (c == 'e' || c == 'E'))
+                {
+                  eneg = FALSE; exp = 0; NEXT (c); --width;
+                  if (width > 0 && c == '+')
+                    {
+                      NEXT (c); --width;
+                    }
+                  else if (width > 0 && c == '-')
+                    {
+                      eneg = TRUE; NEXT (c); --width;
+                    }
+                  if (!(width > 0 && isdigit (c)))
+                    {
+                      UNGETC (c);
+                      return (count);
+                    }
+                  while (width > 0 && isdigit (c))
+                    {
+                      --width;
+                      exp = exp * 10 + (c - '0');
+                      c = *buf++;
+                      if (c == '\0')
+                        break;
+                      else
+                        ++chars;
+                    }
+                  if (eneg) exp = -exp;
+                  while (exp > 0)
+                    {
+                      dx *= 10.0;
+                      --exp;
+                    }
+                  while (exp < 0)
+                    {
+                      dx /= 10.0;
+                      ++exp;
+                    }
+                }
+              if (assign)
+                {
+                  if (neg) dx = -dx;
+                  if (size == 'l')
+                    {
+                      dbl_ptr = va_arg (arg_ptr, double *);
+                      *dbl_ptr = dx;
+                    }
+                  else
+                    {
+                      flt_ptr = va_arg (arg_ptr, float *);
+                      *flt_ptr = (float)dx;
+                    }
+                  ++count;
+                }
+              if (c == '\0')
+                return (count);
+              else
+                UNGETC (c);
+              break;
+            case 'i':
+              neg = FALSE; radix = 10;
+              do
+                {
+                  NEXT (c);
+                } while (WHITE (c));
+              if (!(width > 0 && c == '0'))
+                goto scan_complete_number;
+              NEXT (c); --width;
+              if (width > 0 && (c == 'x' || c == 'X'))
+                {
+                  NEXT (c); radix = 16; --width;
+                }
+              else if (width > 0 && (c >= '0' && c <= '7'))
+                radix = 8;
+              goto scan_unsigned_number;
+            case 'd':
+            case 'u':
+            case 'o':
+            case 'x':
+            case 'X':
+              do
+                {
+                  NEXT (c);
+                } while (WHITE (c));
+              switch (f)
+                {
+                case 'o':           radix = 8; break;
+                case 'x': case 'X': radix = 16; break;
+                default:            radix = 10; break;
+                }
+scan_complete_number:
+              neg = FALSE;
+              if (width > 0 && c == '+')
+                {
+                  NEXT (c); --width;
+                }
+              else if (width > 0 && c == '-' && radix == 10)
+                {
+                  neg = TRUE; NEXT (c); --width;
+                }
+scan_unsigned_number:
+              n = 0; ok = FALSE;
+              while (width > 0)
+                {
+                  --width;
+                  if (isdigit (c))
+                    d = c - '0';
+                  else if (isupper (c))
+                    d = c - 'A' + 10;
+                  else if (islower (c))
+                    d = c - 'a' + 10;
+                  else
+                    break;
+                  if (d < 0 || d >= radix)
+                    break;
+                  ok = TRUE;
+                  n = n * radix + d;
+                  c = *buf++;
+                  if (c == '\0')
+                    break;
+                  else
+                    ++chars;
+                }
+              if (!ok)
+                return (count);
+              if (assign)
+                {
+                  if (neg) n = -n;
+                  switch(size)
+                     {
+                      case 'h':
+                              short_ptr = va_arg (arg_ptr, short *);
+                              *short_ptr = (short)n;
+                              break;
+                      case 'l':
+                              long_ptr = va_arg (arg_ptr, long *);
+                              *long_ptr = (long)n;
+                              break;
+                      default:
+                              int_ptr = va_arg (arg_ptr, int *);
+                              *int_ptr = (int)n;
+                     }
+                  ++count;
+                }
+              if (c == '\0')
+                return (count);
+              else
+                UNGETC (c);
+              break;
+            case 'n':
+              if (assign)
+                {
+                  int_ptr = va_arg (arg_ptr, int *);
+                  *int_ptr = chars;
+                  ++count;
+                }
+              break;
+            default:
+              if (f == 0)                 /* % at end of string */
+                return (count);
+              NEXT (c);
+              if (c != f)
+                return (count);
+              break;
+            }
+          ++fmt;
+        }
+    }
+  return (count);
+}
+#endif
Index: PDCurses/pdcurses/bkgd.c
===================================================================
--- PDCurses/pdcurses/bkgd.c	(revision 1)
+++ PDCurses/pdcurses/bkgd.c	(working copy)
@@ -1,248 +1,248 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	bkgd
-#undef	bkgdset
-#undef	wbkgd
-#undef	wbkgdset
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_bkgd  = "$Id: bkgd.c,v 1.1 2001/01/10 08:26:50 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                          bkgd
-
-  Synopsis:
-  	int bkgd(chtype ch);
-  	void bkgdset(chtype ch);
-  	int wbkgd(WINDOW *win, chtype ch);
-  	void wbkgdset(WINDOW *win, chtype ch);
-
-  UNIX System V (Rel 3.2 or 4) Description:
- 	The bkgdset() and wbkgdset() routines manipulate the backgound of 
- 	the named window.  Background is a chtype consisting of any combination 
- 	of attributes and non-blank characters that are written into the window
- 	with waddch().  Both the character and attribute parts of the background
- 	are combined with the blank characters.  The background becomes a 
- 	property of the character and moves with the character through any 
- 	scrolling and insert/delete line/character operations.  To the extent
- 	possible on a particular terminal, the attribute part of the background
- 	is displayed as the graphic rendition of the character put on the
- 	screen.
-
- 	The bkgd() and wbkgd() routines combine the new background with every
- 	position in the window.  Background is any combination of attributes
- 	and a character.  Only the attribute part is used to set the background
- 	of non-blank characters, while both character and attributes are used
- 	for blank positions.  To the extent possible on a particular terminal,
- 	the attribute part of the background is displayed as the graphic
- 	rendition of the character put on the screen.
-
-  PDCurses Description:
- 	The attributes that are defined with the attrset()/attron() set of 
- 	functions take precedence over the background attributes if there is a
- 	conflict (e.g., different color pairs).
-
-  System V Return Value:
- 	bkgd() and wbkgd() return the integer OK, or a non-negative integer, if
- 	immedok() is set (although this is likely NOT the case).
-
-  PDCurses Return Value:
- 	bkgd() and wbkgd() return the integer OK ( the function immedok() is
- 	currently not supported ).
-
-  System V Notes:
- 	Note that bkgdset() and bkgd() may be macros.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      bkgd                                  -        -      4.0
-      bkgdset                               -        -      4.0
-      wbkgd                                 -        -      4.0
-      wbkgdset                              -        -      4.0
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	bkgd(chtype ch)
-#else
-int	PDC_CDECL	bkgd(ch)
-chtype ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("bkgd() - called\n");
-#endif
-	return(wbkgd(stdscr,ch));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	wbkgd(WINDOW *win, chtype ch)
-#else
-int	PDC_CDECL	wbkgd(win,ch)
-WINDOW *win;
-chtype ch;
-#endif
-/***********************************************************************/
-{
-	int x=0, y=0;
-	chtype oldcolr=0, oldattr=0, oldch=0, newcolr=0, newattr=0, newch=0, colr=0, attr=0;
-	chtype *winptr;
-#ifdef NDP
-	char tmpbuf[60];
-#endif
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wbkgd() - called\n");
-#endif
-
-	if (win == NULL)
-		return(ERR);
-
-	if( win->_bkgd == ch )
-		return OK;
-
-	oldcolr = (win->_bkgd & A_COLOR);
-	if( oldcolr != 0 )
-		oldattr = ((win->_bkgd & A_ATTRIBUTES) ^ oldcolr);
-	oldch   = (win->_bkgd & A_CHARTEXT);
-
-	wbkgdset( win, ch );
-
-	newcolr = (win->_bkgd & A_COLOR);
-	if( newcolr != 0 )
-		newattr = ((win->_bkgd & A_ATTRIBUTES) ^ newcolr);
-	newch   = (win->_bkgd & A_CHARTEXT);
-
-#ifdef NDP
-/* buggy compiler fix */
-	sprintf( tmpbuf, "%d %d", oldch, newch );
-#endif
-	
-/* what follows is what seems to occur in the System V implementation of */
-/* this routine */
-
-	for ( y = 0; y < win->_maxy; y++ ) {
-		for( x = 0; x < win->_maxx; x++ ) {
-
-			winptr = win->_y[y] + x;
-
-			ch = *winptr;
-
-		/* determine the colors and attributes of the character */
-		/* read from the window */
-
-			colr = (ch & A_COLOR);
-			attr = (ch & A_ATTRIBUTES);
-			if( colr != 0 )
-				attr = (attr ^ colr);
-
-		/* if the color is the same as the old background color, then */
-		/* make it the new background color, otherwise leave it */
-
-			if( colr == oldcolr )
-				colr = newcolr;
-
-		/* remove any attributes (non color) from the character that */
-		/* were part of the old background, then combine the remaining */
-		/* ones with the new background */
-
-			attr = (attr ^ oldattr);
-			attr |= newattr;
-
-		/* change character if it is there because it was the old */
-		/* background character */
-
-			ch = (ch & A_CHARTEXT);
-			if ( ch == oldch )
-				ch = newch;
-
-			ch = ((ch | attr) | colr);
-
-			*winptr = ch;
-
-		}
-	}
-
-	touchwin(win);
-	PDC_sync(win);
-	return(OK);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-void	PDC_CDECL	bkgdset(chtype ch)
-#else
-void	PDC_CDECL	bkgdset(ch)
-chtype ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("bkgdset() - called\n");
-#endif
-	wbkgdset(stdscr,ch);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-void	PDC_CDECL	wbkgdset(WINDOW *win, chtype ch)
-#else
-void	PDC_CDECL	wbkgdset(win,ch)
-WINDOW *win;
-chtype ch;
-#endif
-/***********************************************************************/
-{
-	chtype bkgdattr;
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wbkgdset() - called\n");
-#endif
-
-	if (win == NULL)
-		return;
-
-	if( win->_bkgd == ch )
-		return;
-
-	if ( (ch & A_ATTRIBUTES) == 0 )
-		bkgdattr = A_NORMAL;
-	else
-		bkgdattr = (ch & A_ATTRIBUTES);
-
-	ch = (ch & A_CHARTEXT);
-	
-	if( ch == 0 )
-		ch = ' ';
-
-	win->_bkgd = (ch | bkgdattr);
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	bkgd
+#undef	bkgdset
+#undef	wbkgd
+#undef	wbkgdset
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_bkgd  = "$Id: bkgd.c,v 1.1 2001/01/10 08:26:50 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                          bkgd
+
+  Synopsis:
+  	int bkgd(chtype ch);
+  	void bkgdset(chtype ch);
+  	int wbkgd(WINDOW *win, chtype ch);
+  	void wbkgdset(WINDOW *win, chtype ch);
+
+  UNIX System V (Rel 3.2 or 4) Description:
+ 	The bkgdset() and wbkgdset() routines manipulate the backgound of 
+ 	the named window.  Background is a chtype consisting of any combination 
+ 	of attributes and non-blank characters that are written into the window
+ 	with waddch().  Both the character and attribute parts of the background
+ 	are combined with the blank characters.  The background becomes a 
+ 	property of the character and moves with the character through any 
+ 	scrolling and insert/delete line/character operations.  To the extent
+ 	possible on a particular terminal, the attribute part of the background
+ 	is displayed as the graphic rendition of the character put on the
+ 	screen.
+
+ 	The bkgd() and wbkgd() routines combine the new background with every
+ 	position in the window.  Background is any combination of attributes
+ 	and a character.  Only the attribute part is used to set the background
+ 	of non-blank characters, while both character and attributes are used
+ 	for blank positions.  To the extent possible on a particular terminal,
+ 	the attribute part of the background is displayed as the graphic
+ 	rendition of the character put on the screen.
+
+  PDCurses Description:
+ 	The attributes that are defined with the attrset()/attron() set of 
+ 	functions take precedence over the background attributes if there is a
+ 	conflict (e.g., different color pairs).
+
+  System V Return Value:
+ 	bkgd() and wbkgd() return the integer OK, or a non-negative integer, if
+ 	immedok() is set (although this is likely NOT the case).
+
+  PDCurses Return Value:
+ 	bkgd() and wbkgd() return the integer OK ( the function immedok() is
+ 	currently not supported ).
+
+  System V Notes:
+ 	Note that bkgdset() and bkgd() may be macros.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      bkgd                                  -        -      4.0
+      bkgdset                               -        -      4.0
+      wbkgd                                 -        -      4.0
+      wbkgdset                              -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	bkgd(chtype ch)
+#else
+int	PDC_CDECL	bkgd(ch)
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("bkgd() - called\n");
+#endif
+	return(wbkgd(stdscr,ch));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wbkgd(WINDOW *win, chtype ch)
+#else
+int	PDC_CDECL	wbkgd(win,ch)
+WINDOW *win;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+	int x=0, y=0;
+	chtype oldcolr=0, oldattr=0, oldch=0, newcolr=0, newattr=0, newch=0, colr=0, attr=0;
+	chtype *winptr;
+#ifdef NDP
+	char tmpbuf[60];
+#endif
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wbkgd() - called\n");
+#endif
+
+	if (win == NULL)
+		return(ERR);
+
+	if( win->_bkgd == ch )
+		return OK;
+
+	oldcolr = (win->_bkgd & A_COLOR);
+	if( oldcolr != 0 )
+		oldattr = ((win->_bkgd & A_ATTRIBUTES) ^ oldcolr);
+	oldch   = (win->_bkgd & A_CHARTEXT);
+
+	wbkgdset( win, ch );
+
+	newcolr = (win->_bkgd & A_COLOR);
+	if( newcolr != 0 )
+		newattr = ((win->_bkgd & A_ATTRIBUTES) ^ newcolr);
+	newch   = (win->_bkgd & A_CHARTEXT);
+
+#ifdef NDP
+/* buggy compiler fix */
+	sprintf( tmpbuf, "%d %d", oldch, newch );
+#endif
+	
+/* what follows is what seems to occur in the System V implementation of */
+/* this routine */
+
+	for ( y = 0; y < win->_maxy; y++ ) {
+		for( x = 0; x < win->_maxx; x++ ) {
+
+			winptr = win->_y[y] + x;
+
+			ch = *winptr;
+
+		/* determine the colors and attributes of the character */
+		/* read from the window */
+
+			colr = (ch & A_COLOR);
+			attr = (ch & A_ATTRIBUTES);
+			if( colr != 0 )
+				attr = (attr ^ colr);
+
+		/* if the color is the same as the old background color, then */
+		/* make it the new background color, otherwise leave it */
+
+			if( colr == oldcolr )
+				colr = newcolr;
+
+		/* remove any attributes (non color) from the character that */
+		/* were part of the old background, then combine the remaining */
+		/* ones with the new background */
+
+			attr = (attr ^ oldattr);
+			attr |= newattr;
+
+		/* change character if it is there because it was the old */
+		/* background character */
+
+			ch = (ch & A_CHARTEXT);
+			if ( ch == oldch )
+				ch = newch;
+
+			ch = ((ch | attr) | colr);
+
+			*winptr = ch;
+
+		}
+	}
+
+	touchwin(win);
+	PDC_sync(win);
+	return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	bkgdset(chtype ch)
+#else
+void	PDC_CDECL	bkgdset(ch)
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("bkgdset() - called\n");
+#endif
+	wbkgdset(stdscr,ch);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	wbkgdset(WINDOW *win, chtype ch)
+#else
+void	PDC_CDECL	wbkgdset(win,ch)
+WINDOW *win;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+	chtype bkgdattr;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wbkgdset() - called\n");
+#endif
+
+	if (win == NULL)
+		return;
+
+	if( win->_bkgd == ch )
+		return;
+
+	if ( (ch & A_ATTRIBUTES) == 0 )
+		bkgdattr = A_NORMAL;
+	else
+		bkgdattr = (ch & A_ATTRIBUTES);
+
+	ch = (ch & A_CHARTEXT);
+	
+	if( ch == 0 )
+		ch = ' ';
+
+	win->_bkgd = (ch | bkgdattr);
+}
Index: PDCurses/pdcurses/getstr.c
===================================================================
--- PDCurses/pdcurses/getstr.c	(revision 1)
+++ PDCurses/pdcurses/getstr.c	(working copy)
@@ -1,357 +1,357 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define CURSES_LIBRARY 1
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef getstr
-#undef wgetstr
-#undef mvgetstr
-#undef mvwgetstr
-#undef ungetstr
-#undef getnstr
-#undef wgetnstr
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-# undef wrefresh
-# undef waddch
-# undef wgetch
-# undef cbreak
-# undef move
-# undef wmove
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_getstr  = "$Id: getstr.c,v 1.5 2002/11/27 11:23:43 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                        getstr
-
-  Synopsis:
-    int getstr(char *str);
-    int wgetstr(WINDOW *win, char *str);
-    int mvgetstr(int y, int x, char *str);
-    int mvwgetstr(WINDOW *win, int y, int x, char *str);
-    int getnstr(char *str, int ch);
-    int wgetnstr(WINDOW *win, char *str, int ch);
-
-  X/Open Description:
-    The effect of getstr() is as though a series of calls to getch()
-    were made, until a newline or carriage return is received. The
-    resulting value is placed in the area pointed to by *str. The user's
-    erase and kill characters are interpreted, as well as any special
-    keys; such as function keys.
-
-    With wgetnstr(), a series of characters are read until a newline
-    or carriage return is received.  The resulting value is placed
-    in the area pointed to by the character pointer str.  The user's
-    erase and kill characters are interpreted.  This differs from
-    wgetstr() in that the number of characters read is limited by a passed
-    argument.
-
-    NOTE: getstr(), getnstr(), mvgetstr() and mvwgetstr() are
-    implemented as macros.
-
-    WARNING:  There is no way to know how long the buffer passed to
-       wgetstr() is, so it is possible to overwrite wrong
-       memory or code!! This is the reason for the wgetnstr()
-       function :-)
-
-  X/Open Return Value:
-    This functions return ERR on failure or any other value on success.
-
-  X/Open Errors:
-    No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      getstr                                Y        Y       Y
-      wgtdch                                Y        Y       Y
-      mvgetstr                              Y        Y       Y
-      mvwgetstr                             Y        Y       Y
-      getnstr                               -        -      4.0
-      wgetnstr                              -        -      4.0
-
-**man-end**********************************************************************/
-
-#define MAXLINE 255
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_CDECL getstr(char *str)
-#else
-int PDC_CDECL getstr(str)
-char *str;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("getstr() - called\n");
-#endif
-
-   if (stdscr == (WINDOW *)NULL)
-      return (ERR);
-   return(wgetnstr(stdscr,str,MAXLINE));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_CDECL wgetstr(WINDOW *win, char *str)
-#else
-int PDC_CDECL wgetstr(win,str)
-WINDOW *win;
-char *str;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("wgetstr() - called\n");
-#endif
-
-   if (win == (WINDOW *)NULL)
-      return (ERR);
-
-   return(wgetnstr(win,str,MAXLINE));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_CDECL mvgetstr(int y, int x, char *str)
-#else
-int PDC_CDECL mvgetstr(y,x,str)
-int y;
-int x;
-char *str;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("mvgetstr() - called\n");
-#endif
-
-   if (stdscr == (WINDOW *)NULL)
-      return (ERR);
-   if (move(y,x) == ERR)
-      return (ERR);
-   return(wgetnstr(stdscr,str,MAXLINE));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_CDECL mvwgetstr(WINDOW *win, int y, int x, char *str)
-#else
-int PDC_CDECL mvwgetstr(win,y,x,str)
-WINDOW *win;
-int y;
-int x;
-char *str;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("mvwgetstr() - called\n");
-#endif
-
-   if (win == (WINDOW *)NULL)
-      return (ERR);
-   if (wmove(win,y,x) == ERR)
-      return (ERR);
-   return(wgetnstr(win,str,MAXLINE));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_CDECL getnstr(char *str, int n)
-#else
-int PDC_CDECL getnstr(str,n)
-char *str;
-int n;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("getnstr() - called\n");
-#endif
-
-   if (stdscr == (WINDOW *)NULL)
-      return (ERR);
-   return(wgetnstr(stdscr,str,n));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_CDECL wgetnstr(WINDOW *win, char *str, int n)
-#else
-int PDC_CDECL wgetnstr(win,str,n)
-WINDOW *win;
-char *str;
-int n;
-#endif
-/***********************************************************************/
-{
-   int   ch, i, num,chars=0;
-   int   t = win->_tabsize;
-   int   x = win->_curx;
-   char* p = str;
-   bool  stop = FALSE;
-   bool  oldecho;
-   bool  oldcbreak;
-   bool  oldnodelay;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("wgetnstr() - called\n");
-#endif
-
-   if (win == (WINDOW *)NULL)
-      return (ERR);
-
-#ifdef UNIX
-/*
- * this code is very dodgy
- *
-   wrefresh(win);
-
-   while ((*str = wgetch(win)) != ERR && *str != '\n')
-      ;
-   if (*str == ERR) {
-      *str = '\0';
-      waddstr(win,p);
-      return ERR;
-   }
-   *str = '\0';
-   waddstr(win,p);
-   return OK;
-*/
-#else
-   oldcbreak = SP->cbreak; /* remember states    */
-   oldecho = SP->echo;
-   oldnodelay = win->_nodelay;
-
-   SP->echo = FALSE;    /* we do echo ourselves */
-   cbreak();      /* ensure each key is returned immediately */
-   win->_nodelay = FALSE;     /* don't return   -1  */
-
-   wrefresh (win);
-
-   while (!stop)
-   {
-      ch = wgetch (win);
-      /* ignore modifier keys on their own */
-      if ( ch == KEY_SHIFT_L
-      ||   ch == KEY_SHIFT_R
-      ||   ch == KEY_CONTROL_L
-      ||   ch == KEY_CONTROL_R
-      ||   ch == KEY_ALT_L
-      ||   ch == KEY_ALT_R )
-         continue;
-      ch = ch & A_CHARTEXT;
-      switch( ch )
-      {
-         case '\t':
-            ch = ' ';
-            num = t - (win->_curx - x)%t;
-            for (i=0; i<num; i++)
-            {
-               if (chars < n)
-               {
-                  if (oldecho) 
-                     waddch (win, ch);
-                  *p++ = ch;
-                  ++chars;
-               }
-               else
-                  beep();
-            }
-            break;
-
-         case _ECHAR:  /* CTRL-H */  /* Delete character */
-            if (p > str)
-            {
-               if (oldecho) 
-                  waddstr (win, "\b \b");
-               ch = *--p;
-               if ((ch < ' ') && (oldecho))
-                  waddstr (win, "\b \b");
-            }
-            chars--;
-            break;
-
-         case _DLCHAR:  /* CTRL-U */    /* Delete line   */
-            while (p > str)
-            {
-               if (oldecho) 
-                  waddstr (win, "\b \b");
-               ch = *--p;
-               if ((ch < ' ') && (oldecho))
-                  waddstr (win, "\b \b");
-            }
-            chars = 0;
-            break;
-
-         case _DWCHAR: /* CTRL-W */ /* Delete word */
-            while ((p > str) && (*(p-1) == ' '))
-            {
-               if (oldecho) 
-                  waddstr (win, "\b \b");
-               --p; /* remove space */
-               chars--;
-            }
-            while ((p > str) && (*(p-1) != ' '))
-            {
-               if (oldecho) 
-                  waddstr (win, "\b \b");
-               ch = *--p;
-               if ((ch < ' ') && (oldecho))
-                  waddstr (win, "\b \b");
-               chars--;
-            }
-            break;
-
-         case '\n':
-         case '\r':
-            stop = TRUE;
-            if (oldecho) 
-               waddch (win, '\n');
-            break;
-
-         default:
-            if (chars < n)
-            {
-               *p++ = ch;
-               if (oldecho) 
-                  waddch (win, ch);
-               chars ++;
-            }
-            else
-               beep();
-            break;
-      }
-      wrefresh (win);
-   }
-   *p = '\0';
-
-   SP->echo = oldecho;  /* restore old settings */
-   SP->cbreak = oldcbreak;
-   win->_nodelay = oldnodelay;
-
-   return (OK);
-#endif
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef getstr
+#undef wgetstr
+#undef mvgetstr
+#undef mvwgetstr
+#undef ungetstr
+#undef getnstr
+#undef wgetnstr
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+# undef wrefresh
+# undef waddch
+# undef wgetch
+# undef cbreak
+# undef move
+# undef wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_getstr  = "$Id: getstr.c,v 1.5 2002/11/27 11:23:43 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        getstr
+
+  Synopsis:
+    int getstr(char *str);
+    int wgetstr(WINDOW *win, char *str);
+    int mvgetstr(int y, int x, char *str);
+    int mvwgetstr(WINDOW *win, int y, int x, char *str);
+    int getnstr(char *str, int ch);
+    int wgetnstr(WINDOW *win, char *str, int ch);
+
+  X/Open Description:
+    The effect of getstr() is as though a series of calls to getch()
+    were made, until a newline or carriage return is received. The
+    resulting value is placed in the area pointed to by *str. The user's
+    erase and kill characters are interpreted, as well as any special
+    keys; such as function keys.
+
+    With wgetnstr(), a series of characters are read until a newline
+    or carriage return is received.  The resulting value is placed
+    in the area pointed to by the character pointer str.  The user's
+    erase and kill characters are interpreted.  This differs from
+    wgetstr() in that the number of characters read is limited by a passed
+    argument.
+
+    NOTE: getstr(), getnstr(), mvgetstr() and mvwgetstr() are
+    implemented as macros.
+
+    WARNING:  There is no way to know how long the buffer passed to
+       wgetstr() is, so it is possible to overwrite wrong
+       memory or code!! This is the reason for the wgetnstr()
+       function :-)
+
+  X/Open Return Value:
+    This functions return ERR on failure or any other value on success.
+
+  X/Open Errors:
+    No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      getstr                                Y        Y       Y
+      wgtdch                                Y        Y       Y
+      mvgetstr                              Y        Y       Y
+      mvwgetstr                             Y        Y       Y
+      getnstr                               -        -      4.0
+      wgetnstr                              -        -      4.0
+
+**man-end**********************************************************************/
+
+#define MAXLINE 255
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL getstr(char *str)
+#else
+int PDC_CDECL getstr(str)
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("getstr() - called\n");
+#endif
+
+   if (stdscr == (WINDOW *)NULL)
+      return (ERR);
+   return(wgetnstr(stdscr,str,MAXLINE));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL wgetstr(WINDOW *win, char *str)
+#else
+int PDC_CDECL wgetstr(win,str)
+WINDOW *win;
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("wgetstr() - called\n");
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return (ERR);
+
+   return(wgetnstr(win,str,MAXLINE));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL mvgetstr(int y, int x, char *str)
+#else
+int PDC_CDECL mvgetstr(y,x,str)
+int y;
+int x;
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("mvgetstr() - called\n");
+#endif
+
+   if (stdscr == (WINDOW *)NULL)
+      return (ERR);
+   if (move(y,x) == ERR)
+      return (ERR);
+   return(wgetnstr(stdscr,str,MAXLINE));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL mvwgetstr(WINDOW *win, int y, int x, char *str)
+#else
+int PDC_CDECL mvwgetstr(win,y,x,str)
+WINDOW *win;
+int y;
+int x;
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("mvwgetstr() - called\n");
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return (ERR);
+   if (wmove(win,y,x) == ERR)
+      return (ERR);
+   return(wgetnstr(win,str,MAXLINE));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL getnstr(char *str, int n)
+#else
+int PDC_CDECL getnstr(str,n)
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("getnstr() - called\n");
+#endif
+
+   if (stdscr == (WINDOW *)NULL)
+      return (ERR);
+   return(wgetnstr(stdscr,str,n));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL wgetnstr(WINDOW *win, char *str, int n)
+#else
+int PDC_CDECL wgetnstr(win,str,n)
+WINDOW *win;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+   int   ch, i, num,chars=0;
+   int   t = win->_tabsize;
+   int   x = win->_curx;
+   char* p = str;
+   bool  stop = FALSE;
+   bool  oldecho;
+   bool  oldcbreak;
+   bool  oldnodelay;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("wgetnstr() - called\n");
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return (ERR);
+
+#ifdef UNIX
+/*
+ * this code is very dodgy
+ *
+   wrefresh(win);
+
+   while ((*str = wgetch(win)) != ERR && *str != '\n')
+      ;
+   if (*str == ERR) {
+      *str = '\0';
+      waddstr(win,p);
+      return ERR;
+   }
+   *str = '\0';
+   waddstr(win,p);
+   return OK;
+*/
+#else
+   oldcbreak = PDC_SP->cbreak; /* remember states    */
+   oldecho = PDC_SP->echo;
+   oldnodelay = win->_nodelay;
+
+   PDC_SP->echo = FALSE;    /* we do echo ourselves */
+   cbreak();      /* ensure each key is returned immediately */
+   win->_nodelay = FALSE;     /* don't return   -1  */
+
+   wrefresh (win);
+
+   while (!stop)
+   {
+      ch = wgetch (win);
+      /* ignore modifier keys on their own */
+      if ( ch == KEY_SHIFT_L
+      ||   ch == KEY_SHIFT_R
+      ||   ch == KEY_CONTROL_L
+      ||   ch == KEY_CONTROL_R
+      ||   ch == KEY_ALT_L
+      ||   ch == KEY_ALT_R )
+         continue;
+      ch = ch & A_CHARTEXT;
+      switch( ch )
+      {
+         case '\t':
+            ch = ' ';
+            num = t - (win->_curx - x)%t;
+            for (i=0; i<num; i++)
+            {
+               if (chars < n)
+               {
+                  if (oldecho) 
+                     waddch (win, ch);
+                  *p++ = ch;
+                  ++chars;
+               }
+               else
+                  beep();
+            }
+            break;
+
+         case _ECHAR:  /* CTRL-H */  /* Delete character */
+            if (p > str)
+            {
+               if (oldecho) 
+                  waddstr (win, "\b \b");
+               ch = *--p;
+               if ((ch < ' ') && (oldecho))
+                  waddstr (win, "\b \b");
+            }
+            chars--;
+            break;
+
+         case _DLCHAR:  /* CTRL-U */    /* Delete line   */
+            while (p > str)
+            {
+               if (oldecho) 
+                  waddstr (win, "\b \b");
+               ch = *--p;
+               if ((ch < ' ') && (oldecho))
+                  waddstr (win, "\b \b");
+            }
+            chars = 0;
+            break;
+
+         case _DWCHAR: /* CTRL-W */ /* Delete word */
+            while ((p > str) && (*(p-1) == ' '))
+            {
+               if (oldecho) 
+                  waddstr (win, "\b \b");
+               --p; /* remove space */
+               chars--;
+            }
+            while ((p > str) && (*(p-1) != ' '))
+            {
+               if (oldecho) 
+                  waddstr (win, "\b \b");
+               ch = *--p;
+               if ((ch < ' ') && (oldecho))
+                  waddstr (win, "\b \b");
+               chars--;
+            }
+            break;
+
+         case '\n':
+         case '\r':
+            stop = TRUE;
+            if (oldecho) 
+               waddch (win, '\n');
+            break;
+
+         default:
+            if (chars < n)
+            {
+               *p++ = ch;
+               if (oldecho) 
+                  waddch (win, ch);
+               chars ++;
+            }
+            else
+               beep();
+            break;
+      }
+      wrefresh (win);
+   }
+   *p = '\0';
+
+   PDC_SP->echo = oldecho;  /* restore old settings */
+   PDC_SP->cbreak = oldcbreak;
+   win->_nodelay = oldnodelay;
+
+   return (OK);
+#endif
+}
Index: PDCurses/pdcurses/inchstr.c
===================================================================
--- PDCurses/pdcurses/inchstr.c	(revision 1)
+++ PDCurses/pdcurses/inchstr.c	(working copy)
@@ -1,285 +1,285 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	inchstr
-#undef	inchnstr
-#undef	winchstr
-#undef	winchnstr
-#undef	mvinchstr
-#undef	mvinchnstr
-#undef	mvwinchstr
-#undef	mvwinchnstr
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef	move
-#  undef	wmove
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_inchstr  = "$Id: inchstr.c,v 1.1 2001/01/10 08:27:05 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                        inchstr
-
-  Synopsis:
-  	int inchstr(chtype *ch);
-  	int inchnstr(chtype *ch, int n);
-  	int winchstr(WINDOW *win, chtype *ch);
-  	int winchnstr(WINDOW *win, chtype *ch, int n);
-  	int mvinchstr(int y, int x, chtype *ch);
-  	int mvinchnstr(int y, int x, chtype *ch, int n);
-  	int mvwinchstr(WINDOW *, int y, int x, chtype *ch);
-  	int mvwinchnstr(WINDOW *, int y, int x, chtype *ch, int n);
-
-  X/Open Description:
- 	These routines read a chtype string directly from the window structure
- 	starting at the current position and ending at the right margin.
- 	The four routines with n as the last argument copy at most n
- 	elements, but no more than will fit on the line.
-
- 	NOTE:	inchstr(), mvinchstr(), mvwinchstr() inchnstr(), 
- 		mvinchnstr(), and mvwinchnstr() are implemented as macros.
-
-  X/Open Return Value:
- 	All functions return ERR on error and an integer value other than
- 	ERR on success. 
-
-  X/Open Errors:
- 	Normally the value returned indicates the number of chtypes
- 	returned.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      inchstr                               -        -      4.0
-      winchstr                              -        -      4.0
-      mvinchstr                             -        -      4.0
-      mvwinchstr                            -        -      4.0
-      inchnstr                              -        -      4.0
-      winchnstr                             -        -      4.0
-      mvinchnstr                            -        -      4.0
-      mvwinchnstr                           -        -      4.0
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	inchstr(chtype *ch)
-#else
-int	PDC_CDECL	inchstr(ch)
-chtype *ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("inchstr() - called\n");
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	return( inchnstr( ch, stdscr->_maxx - stdscr->_curx ) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	inchnstr(chtype *ch, int n)
-#else
-int	PDC_CDECL	inchnstr(ch,n)
-chtype *ch;
-int n;
-#endif
-/***********************************************************************/
-{
-	chtype	*ptr = &(stdscr->_y[stdscr->_cury][stdscr->_curx]);
-	int	i;
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("inchnstr() - called\n");
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	if (n < 0)
-		return( ERR );
-
-	if ((stdscr->_curx + n) > stdscr->_maxx)
-		n = stdscr->_maxx - stdscr->_curx;
-
-	for(i=0;i<n;i++)
-		*ch++ = *ptr++;
-
-	*ch = (chtype)0;
-	return(i);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	winchstr(WINDOW *win, chtype *ch)
-#else
-int	PDC_CDECL	winchstr(win,ch)
-WINDOW *win;
-chtype *ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("winchstr() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	return(winchnstr(win,ch,win->_maxx - win->_curx));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	winchnstr(WINDOW *win, chtype *ch, int n)
-#else
-int	PDC_CDECL	winchnstr(win,ch,n)
-WINDOW *win;
-chtype *ch;
-int n;
-#endif
-/***********************************************************************/
-{
-	chtype	*ptr = &(win->_y[win->_cury][win->_curx]);
-	int	i;
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("winchnstr() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if (n < 0)
-		return( ERR );
-
-	if ((win->_curx + n) > win->_maxx)
-		n = win->_maxx - win->_curx;
-
-	for(i=0;i<n;i++)
-		*ch++ = *ptr++;
-
-	*ch = (chtype)0;
-	return(i);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvinchstr(int y, int x, chtype *ch)
-#else
-int	PDC_CDECL	mvinchstr(y,x,ch)
-int y;
-int x;
-chtype *ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvinchstr() - called: y %d x %d\n",y,x);
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	if (wmove(stdscr,y,x) == ERR)
-		return( ERR );
-
-	return( inchnstr( ch, stdscr->_maxx - stdscr->_curx) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvinchnstr(int y, int x, chtype *ch, int n)
-#else
-int	PDC_CDECL	mvinchnstr(y,x,ch,n)
-int y;
-int x;
-chtype *ch;
-int n;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvinchnstr() - called: y %d x %d n %d\n",y,x,n);
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	if (wmove(stdscr,y,x) == ERR)
-		return( ERR );
-
-	return( inchnstr( ch, n) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvwinchstr(WINDOW *win, int y, int x, chtype *ch)
-#else
-int	PDC_CDECL	mvwinchstr(win,y,x,ch)
-WINDOW *win;
-int y;
-int x;
-chtype *ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("winchstr() - called:\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if (wmove(win,y,x) == ERR)
-		return( ERR );
-
-	return( winchnstr( win, ch, win->_maxx - win->_curx) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvwinchnstr(WINDOW *win,int y, int x, chtype *ch, int n)
-#else
-int	PDC_CDECL	mvwinchnstr(win,y,x,ch,n)
-WINDOW *win;
-int y;
-int x;
-chtype *ch;
-int n;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvwinchnstr() - called: y %d x %d n %d \n",y,x,n);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if (wmove(win,y,x) == ERR)
-		return( ERR );
-
-	return( winchnstr( win, ch, n) );
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	inchstr
+#undef	inchnstr
+#undef	winchstr
+#undef	winchnstr
+#undef	mvinchstr
+#undef	mvinchnstr
+#undef	mvwinchstr
+#undef	mvwinchnstr
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	move
+#  undef	wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_inchstr  = "$Id: inchstr.c,v 1.1 2001/01/10 08:27:05 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        inchstr
+
+  Synopsis:
+  	int inchstr(chtype *ch);
+  	int inchnstr(chtype *ch, int n);
+  	int winchstr(WINDOW *win, chtype *ch);
+  	int winchnstr(WINDOW *win, chtype *ch, int n);
+  	int mvinchstr(int y, int x, chtype *ch);
+  	int mvinchnstr(int y, int x, chtype *ch, int n);
+  	int mvwinchstr(WINDOW *, int y, int x, chtype *ch);
+  	int mvwinchnstr(WINDOW *, int y, int x, chtype *ch, int n);
+
+  X/Open Description:
+ 	These routines read a chtype string directly from the window structure
+ 	starting at the current position and ending at the right margin.
+ 	The four routines with n as the last argument copy at most n
+ 	elements, but no more than will fit on the line.
+
+ 	NOTE:	inchstr(), mvinchstr(), mvwinchstr() inchnstr(), 
+ 		mvinchnstr(), and mvwinchnstr() are implemented as macros.
+
+  X/Open Return Value:
+ 	All functions return ERR on error and an integer value other than
+ 	ERR on success. 
+
+  X/Open Errors:
+ 	Normally the value returned indicates the number of chtypes
+ 	returned.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      inchstr                               -        -      4.0
+      winchstr                              -        -      4.0
+      mvinchstr                             -        -      4.0
+      mvwinchstr                            -        -      4.0
+      inchnstr                              -        -      4.0
+      winchnstr                             -        -      4.0
+      mvinchnstr                            -        -      4.0
+      mvwinchnstr                           -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	inchstr(chtype *ch)
+#else
+int	PDC_CDECL	inchstr(ch)
+chtype *ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("inchstr() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	return( inchnstr( ch, stdscr->_maxx - stdscr->_curx ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	inchnstr(chtype *ch, int n)
+#else
+int	PDC_CDECL	inchnstr(ch,n)
+chtype *ch;
+int n;
+#endif
+/***********************************************************************/
+{
+	chtype	*ptr = &(stdscr->_y[stdscr->_cury][stdscr->_curx]);
+	int	i;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("inchnstr() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (n < 0)
+		return( ERR );
+
+	if ((stdscr->_curx + n) > stdscr->_maxx)
+		n = stdscr->_maxx - stdscr->_curx;
+
+	for(i=0;i<n;i++)
+		*ch++ = *ptr++;
+
+	*ch = (chtype)0;
+	return(i);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	winchstr(WINDOW *win, chtype *ch)
+#else
+int	PDC_CDECL	winchstr(win,ch)
+WINDOW *win;
+chtype *ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winchstr() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(winchnstr(win,ch,win->_maxx - win->_curx));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	winchnstr(WINDOW *win, chtype *ch, int n)
+#else
+int	PDC_CDECL	winchnstr(win,ch,n)
+WINDOW *win;
+chtype *ch;
+int n;
+#endif
+/***********************************************************************/
+{
+	chtype	*ptr = &(win->_y[win->_cury][win->_curx]);
+	int	i;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winchnstr() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (n < 0)
+		return( ERR );
+
+	if ((win->_curx + n) > win->_maxx)
+		n = win->_maxx - win->_curx;
+
+	for(i=0;i<n;i++)
+		*ch++ = *ptr++;
+
+	*ch = (chtype)0;
+	return(i);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvinchstr(int y, int x, chtype *ch)
+#else
+int	PDC_CDECL	mvinchstr(y,x,ch)
+int y;
+int x;
+chtype *ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvinchstr() - called: y %d x %d\n",y,x);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(stdscr,y,x) == ERR)
+		return( ERR );
+
+	return( inchnstr( ch, stdscr->_maxx - stdscr->_curx) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvinchnstr(int y, int x, chtype *ch, int n)
+#else
+int	PDC_CDECL	mvinchnstr(y,x,ch,n)
+int y;
+int x;
+chtype *ch;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvinchnstr() - called: y %d x %d n %d\n",y,x,n);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(stdscr,y,x) == ERR)
+		return( ERR );
+
+	return( inchnstr( ch, n) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwinchstr(WINDOW *win, int y, int x, chtype *ch)
+#else
+int	PDC_CDECL	mvwinchstr(win,y,x,ch)
+WINDOW *win;
+int y;
+int x;
+chtype *ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winchstr() - called:\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(win,y,x) == ERR)
+		return( ERR );
+
+	return( winchnstr( win, ch, win->_maxx - win->_curx) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwinchnstr(WINDOW *win,int y, int x, chtype *ch, int n)
+#else
+int	PDC_CDECL	mvwinchnstr(win,y,x,ch,n)
+WINDOW *win;
+int y;
+int x;
+chtype *ch;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwinchnstr() - called: y %d x %d n %d \n",y,x,n);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(win,y,x) == ERR)
+		return( ERR );
+
+	return( winchnstr( win, ch, n) );
+}
Index: PDCurses/pdcurses/scanw.c
===================================================================
--- PDCurses/pdcurses/scanw.c	(revision 1)
+++ PDCurses/pdcurses/scanw.c	(working copy)
@@ -1,276 +1,276 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-#include <string.h>
-
-#if defined(HAVE_STDARG_H) && defined(HAVE_PROTO)
-#  include <stdarg.h>
-#  define HAVE_STDARG_H_HAVE_PROTO
-#else
-#  include <varargs.h>
-#endif
-
-/* undefine any macros for functions defined in this module */
-#undef	scanw
-#undef	wscanw
-#undef	mvscanw
-#undef	mvwscanw
-#undef	vwscanw
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef	wgetstr
-#  undef	wrefresh
-#  undef	wmove
-#endif
-
-#ifndef HAVE_VSSCANF
-#  define vsscanf PDC_vsscanf
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_scanw  = "$Id: scanw.c,v 1.1 2001/01/10 08:27:26 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                         scanw
-
-  Synopsis:
-  	int scanw(char *fmt, ...);
-  	int wscanw(WINDOW *win, char *fmt, ...);
-  	int mvscanw(int y, int x, char *fmt, ...);
-  	int mvwscanw(WINDOW *win, int y, int x, char *fmt,...);
-  ***	int vwscanw(WINDOW *win, char *fmt, va_list varglist);
-
-  X/Open Description:
- 	These routines correspond to scanf(). The function scanw() reads
- 	input from the default window. The function wscanw() reads
- 	input from the specified window. The function mvscanw() moves
- 	the cursor to the specified position and then reads input from
- 	the default window. The function mvwscanw() moves the cursor to
- 	the specified position and then reads input from the specified
- 	window.
-
- 	For all the functions, the routine wgetstr() is called to get a
- 	string from the window, and the resulting line is used as
- 	input for the scan.  All character interpretation is carried
- 	out according to the scanf function rules.
-
-  PDCurses Description:
- 	The old Bjorn Larssen code for the 68K platform has been removed
- 	from this module.
-
-  X/Open Return Value:
- 	Upon successful completion, the scanw, mvscanw, mvwscanw and
- 	wscanw functions return the number of items successfully
- 	matched.  On end-of-file, they return EOF.  Otherwise they
- 	return ERR.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      scanw                                 Y        Y       Y
-      wscanw                                Y        Y       Y
-      mvscanw                               Y        Y       Y
-      mvwscanw                              Y        Y       Y
-      vwscanw                               -        -      4.0
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_STDARG_H_HAVE_PROTO
-int	PDC_CDECL	scanw(char *fmt, ...)
-#else
-int	PDC_CDECL	scanw(fmt,va_alist)
-char *fmt;
-va_dcl
-#endif
-/***********************************************************************/
-{
-	va_list args;
-	int	retval = ERR;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("scanw() - called\n");
-#endif
-
-#if	!defined (HC)
-	if (stdscr == (WINDOW *)NULL)
-		return( retval );
-
-	wrefresh(stdscr);	/* set cursor position */
-
-	/*
-	 * get string
-	 */
-	c_printscanbuf[0] = '\0';  /* reset to empty string */
-	if (wgetstr(stdscr, c_printscanbuf) == ERR)
-		return( retval );
-#ifdef HAVE_STDARG_H_HAVE_PROTO
-	va_start(args, fmt);
-#else
-	va_start(args);
-#endif
-
-	retval = vsscanf(c_printscanbuf, fmt, args);
-	va_end(args);
-#endif
-
-	return( retval );
-}
-
-/***********************************************************************/
-#ifdef HAVE_STDARG_H_HAVE_PROTO
-int	PDC_CDECL	wscanw(WINDOW *win, char *fmt, ...)
-#else
-int	PDC_CDECL	wscanw(win,fmt,va_alist)
-WINDOW *win;
-char *fmt;
-va_dcl
-# endif
-/***********************************************************************/
-{
-	va_list args;
-	int	retval = ERR;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wscanw() - called\n");
-#endif
-
-#if	!defined (HC)
-	if (win == (WINDOW *)NULL)
-		return (retval);
-
-	wrefresh(win);		/* set cursor position */
-
-	/*
-	 * get string
-	 */
-	c_printscanbuf[0] = '\0';  /* reset to empty string */
-	if (wgetstr(win, c_printscanbuf) == ERR)
-		return( retval );
-# ifdef HAVE_STDARG_H_HAVE_PROTO
-	va_start(args, fmt);
-# else
-	va_start(args);
-# endif
-	retval = vsscanf(c_printscanbuf, fmt, args);
-	va_end(args);
-#endif
-
-	return( retval );
-}
-
-/***********************************************************************/
-#ifdef HAVE_STDARG_H_HAVE_PROTO
-int	PDC_CDECL	mvscanw(int y, int x, char *fmt, ... )
-#else
-int	PDC_CDECL	mvscanw(y,x,fmt,va_alist)
-int y,x;
-char *fmt;
-va_dcl
-#endif
-/***********************************************************************/
-{
-	va_list args;
-	int	retval = ERR;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvscanw() - called\n");
-#endif
-
-#if	!defined (HC)
-	if (stdscr == (WINDOW *)NULL)
-		return( retval );
-
-	if (wmove(stdscr, y, x) == ERR)
-		return( retval );
-
-	wrefresh(stdscr);			/* set cursor position */
-
-	/*
-	 * get string
-	 */
-	c_printscanbuf[0] = '\0';  /* reset to empty string */
-	if (wgetstr(stdscr, c_printscanbuf) == ERR)
-		return( retval );
-# ifdef HAVE_STDARG_H_HAVE_PROTO
-	va_start(args, fmt);
-# else
-	va_start(args);
-# endif
-	retval = vsscanf(c_printscanbuf, fmt, args);
-	va_end(args);
-#endif
-
-	return( retval );
-}
-
-/***********************************************************************/
-#ifdef HAVE_STDARG_H_HAVE_PROTO
-int	PDC_CDECL	mvwscanw(WINDOW *win, int y, int x, char *fmt,...)
-#else
-int	PDC_CDECL	mvwscanw(win,y,x,fmt,va_alist)
-WINDOW *win;
-int y,x;
-char *fmt;
-va_dcl
-#endif
-/***********************************************************************/
-{
-	va_list args;
-	int	retval = ERR;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvscanw() - called\n");
-#endif
-
-#if	!defined (HC)
-	if (win == (WINDOW *)NULL)
-		return( retval );
-
-	if (wmove(win, y, x) == ERR)
-		return( retval );
-
-	wrefresh(win);		/* set cursor position */
-
-	/*
-	 * get string
-	 */
-	c_printscanbuf[0] = '\0';  /* reset to empty string */
-	if (wgetstr(win, c_printscanbuf) == ERR)
-		return( retval );
-# ifdef HAVE_STDARG_H_HAVE_PROTO
-	va_start(args, fmt);
-# else
-	va_start(args);
-# endif
-	retval = vsscanf(c_printscanbuf, fmt, args);
-	va_end(args);
-#endif
-	return( retval );
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+#include <string.h>
+
+#if defined(HAVE_STDARG_H) && defined(HAVE_PROTO)
+#  include <stdarg.h>
+#  define HAVE_STDARG_H_HAVE_PROTO
+#else
+#  include <varargs.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef	scanw
+#undef	wscanw
+#undef	mvscanw
+#undef	mvwscanw
+#undef	vwscanw
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	wgetstr
+#  undef	wrefresh
+#  undef	wmove
+#endif
+
+#ifndef HAVE_VSSCANF
+#  define vsscanf PDC_vsscanf
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_scanw  = "$Id: scanw.c,v 1.1 2001/01/10 08:27:26 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         scanw
+
+  Synopsis:
+  	int scanw(char *fmt, ...);
+  	int wscanw(WINDOW *win, char *fmt, ...);
+  	int mvscanw(int y, int x, char *fmt, ...);
+  	int mvwscanw(WINDOW *win, int y, int x, char *fmt,...);
+  ***	int vwscanw(WINDOW *win, char *fmt, va_list varglist);
+
+  X/Open Description:
+ 	These routines correspond to scanf(). The function scanw() reads
+ 	input from the default window. The function wscanw() reads
+ 	input from the specified window. The function mvscanw() moves
+ 	the cursor to the specified position and then reads input from
+ 	the default window. The function mvwscanw() moves the cursor to
+ 	the specified position and then reads input from the specified
+ 	window.
+
+ 	For all the functions, the routine wgetstr() is called to get a
+ 	string from the window, and the resulting line is used as
+ 	input for the scan.  All character interpretation is carried
+ 	out according to the scanf function rules.
+
+  PDCurses Description:
+ 	The old Bjorn Larssen code for the 68K platform has been removed
+ 	from this module.
+
+  X/Open Return Value:
+ 	Upon successful completion, the scanw, mvscanw, mvwscanw and
+ 	wscanw functions return the number of items successfully
+ 	matched.  On end-of-file, they return EOF.  Otherwise they
+ 	return ERR.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      scanw                                 Y        Y       Y
+      wscanw                                Y        Y       Y
+      mvscanw                               Y        Y       Y
+      mvwscanw                              Y        Y       Y
+      vwscanw                               -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+int	PDC_CDECL	scanw(char *fmt, ...)
+#else
+int	PDC_CDECL	scanw(fmt,va_alist)
+char *fmt;
+va_dcl
+#endif
+/***********************************************************************/
+{
+	va_list args;
+	int	retval = ERR;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("scanw() - called\n");
+#endif
+
+#if	!defined (HC)
+	if (stdscr == (WINDOW *)NULL)
+		return( retval );
+
+	wrefresh(stdscr);	/* set cursor position */
+
+	/*
+	 * get string
+	 */
+	c_printscanbuf[0] = '\0';  /* reset to empty string */
+	if (wgetstr(stdscr, c_printscanbuf) == ERR)
+		return( retval );
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+	va_start(args, fmt);
+#else
+	va_start(args);
+#endif
+
+	retval = vsscanf(c_printscanbuf, fmt, args);
+	va_end(args);
+#endif
+
+	return( retval );
+}
+
+/***********************************************************************/
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+int	PDC_CDECL	wscanw(WINDOW *win, char *fmt, ...)
+#else
+int	PDC_CDECL	wscanw(win,fmt,va_alist)
+WINDOW *win;
+char *fmt;
+va_dcl
+# endif
+/***********************************************************************/
+{
+	va_list args;
+	int	retval = ERR;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wscanw() - called\n");
+#endif
+
+#if	!defined (HC)
+	if (win == (WINDOW *)NULL)
+		return (retval);
+
+	wrefresh(win);		/* set cursor position */
+
+	/*
+	 * get string
+	 */
+	c_printscanbuf[0] = '\0';  /* reset to empty string */
+	if (wgetstr(win, c_printscanbuf) == ERR)
+		return( retval );
+# ifdef HAVE_STDARG_H_HAVE_PROTO
+	va_start(args, fmt);
+# else
+	va_start(args);
+# endif
+	retval = vsscanf(c_printscanbuf, fmt, args);
+	va_end(args);
+#endif
+
+	return( retval );
+}
+
+/***********************************************************************/
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+int	PDC_CDECL	mvscanw(int y, int x, char *fmt, ... )
+#else
+int	PDC_CDECL	mvscanw(y,x,fmt,va_alist)
+int y,x;
+char *fmt;
+va_dcl
+#endif
+/***********************************************************************/
+{
+	va_list args;
+	int	retval = ERR;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvscanw() - called\n");
+#endif
+
+#if	!defined (HC)
+	if (stdscr == (WINDOW *)NULL)
+		return( retval );
+
+	if (wmove(stdscr, y, x) == ERR)
+		return( retval );
+
+	wrefresh(stdscr);			/* set cursor position */
+
+	/*
+	 * get string
+	 */
+	c_printscanbuf[0] = '\0';  /* reset to empty string */
+	if (wgetstr(stdscr, c_printscanbuf) == ERR)
+		return( retval );
+# ifdef HAVE_STDARG_H_HAVE_PROTO
+	va_start(args, fmt);
+# else
+	va_start(args);
+# endif
+	retval = vsscanf(c_printscanbuf, fmt, args);
+	va_end(args);
+#endif
+
+	return( retval );
+}
+
+/***********************************************************************/
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+int	PDC_CDECL	mvwscanw(WINDOW *win, int y, int x, char *fmt,...)
+#else
+int	PDC_CDECL	mvwscanw(win,y,x,fmt,va_alist)
+WINDOW *win;
+int y,x;
+char *fmt;
+va_dcl
+#endif
+/***********************************************************************/
+{
+	va_list args;
+	int	retval = ERR;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvscanw() - called\n");
+#endif
+
+#if	!defined (HC)
+	if (win == (WINDOW *)NULL)
+		return( retval );
+
+	if (wmove(win, y, x) == ERR)
+		return( retval );
+
+	wrefresh(win);		/* set cursor position */
+
+	/*
+	 * get string
+	 */
+	c_printscanbuf[0] = '\0';  /* reset to empty string */
+	if (wgetstr(win, c_printscanbuf) == ERR)
+		return( retval );
+# ifdef HAVE_STDARG_H_HAVE_PROTO
+	va_start(args, fmt);
+# else
+	va_start(args);
+# endif
+	retval = vsscanf(c_printscanbuf, fmt, args);
+	va_end(args);
+#endif
+	return( retval );
+}
Index: PDCurses/pdcurses/beep.c
===================================================================
--- PDCurses/pdcurses/beep.c	(revision 1)
+++ PDCurses/pdcurses/beep.c	(working copy)
@@ -1,128 +1,128 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-#ifdef UNIX
-#include <defs.h>
-#include <term.h>
-#endif
-
-/* undefine any macros for functions defined in this module */
-#undef	beep
-#undef	flash
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef	delay_output
-#  undef	wrefresh
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_beep  = "$Id: beep.c,v 1.1 2001/01/10 08:26:49 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                          beep
-
-  Synopsis:
-  	int beep(void);
-  	int flash(void);
-
-  X/Open Description:
- 	These routines are used to signal the terminal user.  The beep()
- 	function will sound the audible bell on the terminal, if possible
- 	and if not, will flash the screen (visible bell), if possible.
- 	The flash() function will flash the screen, and if that is not
- 	possible, will sound the audible signal.  If neither signal is
- 	possible, nothing will happen.  Nearly all terminals have an
- 	audible signal (bell or beep), but only some can flash the screen.
-
-  X/Open Return Value:
- 	These functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for these functions.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      beep                                  Y        Y       Y
-      flash                                 Y        Y       Y
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	beep(void)
-#else
-int	PDC_CDECL	beep()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("beep() - called\n");
-#endif
-
-	if (!SP->audible)
-	{
-		flash();
-		return( ERR );		/* We try to flash instead...*/
-	}
-
-	PDC_beep();
-
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	flash(void)
-#else
-int	PDC_CDECL	flash()
-#endif
-/***********************************************************************/
-{
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("flash() - called\n");
-#endif
-
-#ifdef UNIX
-	if (flash_screen != NULL)
-		putp(flash_screen);
-	return(OK);
-#endif
-
-#if defined(DOS) || defined(OS2) || defined(WIN32)
-	PDC_scroll(0, 0, LINES - 1, COLS - 1, 0, A_NORMAL);
-	delay_output( 50 );
-	PDC_scroll(0, 0, LINES - 1, COLS - 1, 0, A_REVERSE);
-	wrefresh(curscr);
-	return( OK );
-#endif
-
-#if defined(XCURSES)
-	XCursesInstructAndWait(CURSES_FLASH);
-	return( OK );
-#endif
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef UNIX
+#include <defs.h>
+#include <term.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef	beep
+#undef	flash
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	delay_output
+#  undef	wrefresh
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_beep  = "$Id: beep.c,v 1.1 2001/01/10 08:26:49 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                          beep
+
+  Synopsis:
+  	int beep(void);
+  	int flash(void);
+
+  X/Open Description:
+ 	These routines are used to signal the terminal user.  The beep()
+ 	function will sound the audible bell on the terminal, if possible
+ 	and if not, will flash the screen (visible bell), if possible.
+ 	The flash() function will flash the screen, and if that is not
+ 	possible, will sound the audible signal.  If neither signal is
+ 	possible, nothing will happen.  Nearly all terminals have an
+ 	audible signal (bell or beep), but only some can flash the screen.
+
+  X/Open Return Value:
+ 	These functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for these functions.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      beep                                  Y        Y       Y
+      flash                                 Y        Y       Y
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	beep(void)
+#else
+int	PDC_CDECL	beep()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("beep() - called\n");
+#endif
+
+	if (!PDC_SP->audible)
+	{
+		flash();
+		return( ERR );		/* We try to flash instead...*/
+	}
+
+	PDC_beep();
+
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	flash(void)
+#else
+int	PDC_CDECL	flash()
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("flash() - called\n");
+#endif
+
+#ifdef UNIX
+	if (flash_screen != NULL)
+		putp(flash_screen);
+	return(OK);
+#endif
+
+#if defined(DOS) || defined(OS2) || defined(WIN32)
+	PDC_scroll(0, 0, LINES - 1, COLS - 1, 0, A_NORMAL);
+	delay_output( 50 );
+	PDC_scroll(0, 0, LINES - 1, COLS - 1, 0, A_REVERSE);
+	wrefresh(curscr);
+	return( OK );
+#endif
+
+#if defined(XCURSES)
+	XCursesInstructAndWait(CURSES_FLASH);
+	return( OK );
+#endif
+}
Index: PDCurses/pdcurses/util.c
===================================================================
--- PDCurses/pdcurses/util.c	(revision 1)
+++ PDCurses/pdcurses/util.c	(working copy)
@@ -1,390 +1,390 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-#if defined(DOS) && defined(MSC)
-#include <time.h>
-#endif
-
-#ifdef TIME_WITH_SYS_TIME
-# include <sys/time.h>
-# include <time.h>
-#else
-# ifdef HAVE_SYS_TIME_H
-#  include <sys/time.h>
-# else
-#  include <time.h>
-# endif
-#endif
-
-#ifdef HAVE_UNISTD_H
-#  include <unistd.h>
-#endif
-
-#ifdef OS2
-# ifdef EMXVIDEO
-#include <termios.h>
-# else
-	APIRET APIENTRY DosSleep(ULONG ulTime);
-# endif
-#endif
-
-/* undefine any macros for functions defined in this module */
-#undef	unctrl
-#undef	keyname
-#undef	filter
-#undef	use_env
-#undef	put_win
-#undef	get_win
-#undef	delay_output
-#undef	flushinp
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_util  = "$Id: util.c,v 1.3 2001/04/22 05:53:22 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                          util
-
-  Synopsis:
-  	char *unctrl(chtype c);
-  	char *keyname(int key);
-  ***	int filter(void);
-  ***	void use_env(void);
-  ***	int putwin(WINDOW *win, FILE *filep);
-  ***	WINDOW *getwin(FILE *filep);
-  	int delay_output( int ms );
-  	int flushinp(void);
-
-  X/Open Description:
- 	The unctrl() routine expands the character c into a character
- 	string which is a printable representation of the character.
- 	Control characters are displayed in the ^X notation.  Printing
- 	characters are displayed normally.
-
- 	The keyname() function returns a pointer to a character string 
- 	containing a symbolic name corresponding to that specified in 
- 	the argument key. key may be any key returned by wgetch().
-
- 	The delay_output() function inserts ms millisecond pause in output.
- 	On some systems, this has no effect.
-
- 	The flushinp() routine throws away any type-ahead that has been 
- 	typed by the user and has not yet been read by the program.
-
-  PDCurses Description:
- 	The conversion from a control character to a two-character
- 	sequence is done by the unctrl() function. In the BSD version
- 	of curses it is done by a macro, which uses a publicly
- 	available translation table. Some ill-behaved application
- 	programs use the table directly, and since it does not exist
- 	in this curses version such application will link with an
- 	error message complaining about undefined symbols.
-
- 	If the PDCurses library is compiled under DOS with the FAST_VIDEO
- 	define true, then we will poke the BIOS keyboard buffer head and
- 	tail pointers, resetting the typeahead to implement flushinp().
- 	If this is not true, then we will be unable to reliably flush
- 	the typeahead.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      unctrl                                Y        Y       Y
-      keyname                               Y        -      3.0
-      filter                                Y        -      3.0
-      use_env                               -        -      4.0
-      put_win                               -        -      4.0
-      get_win                               -        -      4.0
-      delay_output                          Y        Y       Y
-      flushinp                              Y        Y       Y
-
-**man-end**********************************************************************/
-
-static char strbuf[3] = {0, 0, 0};
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-char*	PDC_CDECL	unctrl(chtype c)
-#else
-char*	PDC_CDECL	unctrl(c)
-chtype c;
-#endif
-/***********************************************************************/
-{
-	chtype	ic = c;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("unctrl() - called\n");
-#endif
-
-	ic &= A_CHARTEXT;
-	if (ic >= 0x20 && ic != 0x7f)		/* normal characters */
-	{
-		strbuf[0] = (char) ic;
-		strbuf[1] = '\0';
-		return( strbuf );
-	}
-	strbuf[0] = '^';	/* '^' prefix */
-	if (c == 0x7f)
-	{
-		/*
-		 * 0x7f == DEL
-		 */
-		strbuf[1] = '?';
-	}
-	else
-	{
-		/*
-		 * other control
-		 */
-		strbuf[1] = (char)(ic + '@');
-	}
-	return( strbuf );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-char *	PDC_CDECL	keyname(int key)
-#else
-char *	PDC_CDECL	keyname(key)
-int key;
-#endif
-/***********************************************************************/
-{
-	static char *key_name[] =
-	{
- "KEY_BREAK","KEY_DOWN","KEY_UP","KEY_LEFT","KEY_RIGHT","KEY_HOME","KEY_BACKSPACE",
- "KEY_F0","KEY_F(1)","KEY_F(2)","KEY_F(3)","KEY_F(4)","KEY_F(5)",
- "KEY_F(6)","KEY_F(7)","KEY_F(8)","KEY_F(9)","KEY_F(10)",
- "KEY_F(11)","KEY_F(12)","KEY_F(13)","KEY_F(14)","KEY_F(15)",
- "KEY_F(16)","KEY_F(17)","KEY_F(18)","KEY_F(19)","KEY_F(20)",
- "KEY_F(21)","KEY_F(22)","KEY_F(23)","KEY_F(24)","KEY_F(25)",
- "KEY_F(26)","KEY_F(27)","KEY_F(28)","KEY_F(29)","KEY_F(30)",
- "KEY_F(31)","KEY_F(32)","KEY_F(33)","KEY_F(34)","KEY_F(35)",
- "KEY_F(36)","KEY_F(37)","KEY_F(38)","KEY_F(39)","KEY_F(40)",
- "KEY_F(41)","KEY_F(42)","KEY_F(43)","KEY_F(44)","KEY_F(45)",
- "KEY_F(46)","KEY_F(47)","KEY_F(48)","KEY_F(49)","KEY_F(50)",
- "KEY_F(51)","KEY_F(52)","KEY_F(53)","KEY_F(54)","KEY_F(55)",
- "KEY_F(56)","KEY_F(57)","KEY_F(58)","KEY_F(59)","KEY_F(60)",
- "KEY_F(61)","KEY_F(62)","KEY_F(63)",
- "KEY_DL","KEY_IL","KEY_DC","KEY_IC","KEY_EIC","KEY_CLEAR","KEY_EOS","KEY_EOL",
- "KEY_SF","KEY_SR","KEY_NPAGE","KEY_PPAGE","KEY_STAB","KEY_CTAB","KEY_CATAB",
- "KEY_ENTER","KEY_SRESET","KEY_RESET","KEY_PRINT","KEY_LL","KEY_ABORT","KEY_SHELP",
- "KEY_LHELP","KEY_BTAB","KEY_BEG","KEY_CANCEL","KEY_CLOSE","KEY_COMMAND","KEY_COPY",
- "KEY_CREATE","KEY_END","KEY_EXIT","KEY_FIND","KEY_HELP","KEY_MARK","KEY_MESSAGE",
- "KEY_MOVE","KEY_NEXT","KEY_OPEN","KEY_OPTIONS","KEY_PREVIOUS","KEY_REDO",
- "KEY_REFERENCE","KEY_REFRESH","KEY_REPLACE","KEY_RESTART","KEY_RESUME","KEY_SAVE",
- "KEY_SBEG","KEY_SCANCEL","KEY_SCOMMAND","KEY_SCOPY","KEY_SCREATE","KEY_SDC","KEY_SDL",
- "KEY_SELECT","KEY_SEND","KEY_SEOL","KEY_SEXIT","KEY_SFIND","KEY_SHOME","KEY_SIC",
- "NO KEY NAME",
- "KEY_SLEFT","KEY_SMESSAGE","KEY_SMOVE","KEY_SNEXT","KEY_SOPTIONS","KEY_SPREVIOUS",
- "KEY_SPRINT","KEY_SREDO","KEY_SREPLACE","KEY_SRIGHT","KEY_SRSUME","KEY_SSAVE",
- "KEY_SSUSPEND","KEY_SUNDO","KEY_SUSPEND","KEY_UNDO",
- "ALT_0","ALT_1","ALT_2","ALT_3","ALT_4","ALT_5","ALT_6","ALT_7","ALT_8","ALT_9",
- "ALT_A","ALT_B","ALT_C","ALT_D","ALT_E","ALT_F","ALT_G","ALT_H","ALT_I","ALT_J",
- "ALT_K","ALT_L","ALT_M","ALT_N","ALT_O","ALT_P","ALT_Q","ALT_R","ALT_S","ALT_T",
- "ALT_U","ALT_V","ALT_W","ALT_X","ALT_Y","ALT_Z","CTL_LEFT","CTL_RIGHT","CTL_PGUP",
- "CTL_PGDN","CTL_HOME","CTL_END","KEY_A1","KEY_A2","KEY_A3","KEY_B1",
- "KEY_B2","KEY_B3","KEY_C1","KEY_C2","KEY_C3","PADSLASH","PADENTER","CTL_PADENTER",
- "ALT_PADENTER","PADSTOP","PADSTAR","PADMINUS","PADPLUS","CTL_PADSTOP",
- "CTL_PADCENTER","CTL_PADPLUS","CTL_PADMINUS","CTL_PADSLASH","CTL_PADSTAR","ALT_PADPLUS",
- "ALT_PADMINUS","ALT_PADSLASH","ALT_PADSTAR","ALT_PADSTOP","CTL_INS","ALT_DEL","ALT_INS","CTL_UP",
- "CTL_DOWN","CTL_TAB","ALT_TAB","ALT_MINUS","ALT_EQUAL","ALT_HOME","ALT_PGUP","ALT_PGDN",
- "ALT_END","ALT_UP","ALT_DOWN","ALT_RIGHT","ALT_LEFT","ALT_ENTER","ALT_ESC","ALT_BQUOTE",
- "ALT_LBRACKET","ALT_RBRACKET","ALT_SEMICOLON","ALT_FQUOTE","ALT_COMMA","ALT_STOP",
- "ALT_FSLASH","ALT_BKSP","CTL_BKSP","PAD0",
- "CTL_PAD0","CTL_PAD1","CTL_PAD2","CTL_PAD3","CTL_PAD4",
- "CTL_PAD5","CTL_PAD6","CTL_PAD7","CTL_PAD8","CTL_PAD9",
- "ALT_PAD0","ALT_PAD1","ALT_PAD2","ALT_PAD3","ALT_PAD4",
- "ALT_PAD5","ALT_PAD6","ALT_PAD7","ALT_PAD8","ALT_PAD9",
- "CTL_DEL","ALT_BSLASH","CTL_ENTER","SHF_PADENTER","SHF_PADSLASH",
- "SHF_PADSTAR","SHF_PADPLUS","SHF_PADMINUS","SHF_UP","SHF_DOWN",
- "SHF_IC","SHF_DC","KEY_MOUSE",
- "KEY_SHIFT_L","KEY_SHIFT_R",
- "KEY_CONTROL_L","KEY_CONTROL_R",
- "KEY_ALT_L","KEY_ALT_R",
- "KEY_RESIZE", "KEY_SUP", "KEY_SDOWN"
-	};
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("keyname() - called: key %d\n",key);
-#endif
-
-
-	key -= KEY_MIN;
-	if (key >= 0
-	&& key <= sizeof(key_name) / sizeof(key_name[0]))
-		return( key_name[key] );
-	else
-		return("NO KEY NAME");
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	delay_output( int ms )
-#else
-int	PDC_CDECL	delay_output(ms)
-int ms;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("delay_output() - called: ms %d\n",ms);
-#endif
-
-#if (defined(TC) || defined(__WATCOMC__)) && defined(DOS)
-	delay( ms );
-	return( OK );
-#endif
-
-#if defined(WIN32)
-	PDC_usleep( ms );
-	return( OK );
-#endif
-
-#if	defined(OS2)
-# if defined(EMX)
-	_sleep2(ms);
-# else
-	DosSleep(ms);
-# endif
-	return( OK );
-#endif
-
-#if	defined(DOS) && defined(MSC)
-	PDC_usleep((clock_t)ms);
-	return( OK );
-#endif
-
-#if	defined(DOS) && defined(NDP)
-	clock_t goal;
-	goal = ms + (float)( (float)clock()/(float)CLOCKS_PER_SEC )*1000;
-	while (goal > (float)( (float)clock()/(float)CLOCKS_PER_SEC )*1000)
-	;
-	return( OK );
-#endif
-
-#if defined(UNIX) || defined(GO32)
-	usleep(1000*ms);
-	return( OK );
-#endif
-
-#if defined(XCURSES)
-	PDC_usleep(ms*1000);
-	return( OK );
-#endif
-
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	flushinp(void)
-#else
-int	PDC_CDECL	flushinp()
-#endif
-/***********************************************************************/
-{
-extern int	c_pindex;		/* putter index */
-extern int	c_gindex;		/* getter index */
-extern int	c_ungind;		/* wungetch() push index */
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("flushinp() - called\n");
-#endif
-
-#if defined(DOS) && defined(FAST_VIDEO)
-	setdosmemword (0x41a, getdosmemword (0x41c)); /* Force the BIOS kbd buf       */
-					/* head/tail pointers to be the */
-					/* same...  Real nasty trick... */
-#  if defined(NDP)
-/*
-	int *KB_HEAD = (int *) mapdev( 0x041aL, sizeof(short) );
-	int *KB_TAIL = (int *) mapdev( 0x041cL, sizeof(short) );
-
-	memcpy( KB_HEAD, KB_TAIL, sizeof(short) );
-*/
-#  endif
-#endif
-
-#ifdef OS2
-#  ifdef EMXVIDEO
-	tcflush(0,TCIFLUSH);
-#  else
-	KbdFlushBuffer(0);
-#  endif
-#endif
-
-#ifdef UNIX
-/* INCOMPLETE */
-#endif
-
-#ifdef XCURSES
-	while(XCurses_kbhit())
-		(void)XCurses_rawgetch(0);
-#endif
-
-	c_gindex = 1;			/* set indices to kill buffer	 */
-	c_pindex = 0;
-	c_ungind = 0;			/* clear c_ungch array		 */
-	return( OK );
-}
-
-#undef traceon
-#undef traceoff
-/***********************************************************************/
-#ifdef HAVE_PROTO
-void	PDC_CDECL	traceon(void)
-#else
-void	PDC_CDECL	traceon()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("traceon() - called\n");
-#endif
-	trace_on = TRUE;
-	return;
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-void	PDC_CDECL	traceoff(void)
-#else
-void	PDC_CDECL	traceoff()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("traceoff() - called\n");
-#endif
-	trace_on = FALSE;
-	return;
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#if defined(DOS) && defined(MSC)
+#include <time.h>
+#endif
+
+#ifdef TIME_WITH_SYS_TIME
+# include <sys/time.h>
+# include <time.h>
+#else
+# ifdef HAVE_SYS_TIME_H
+#  include <sys/time.h>
+# else
+#  include <time.h>
+# endif
+#endif
+
+#ifdef HAVE_UNISTD_H
+#  include <unistd.h>
+#endif
+
+#ifdef OS2
+# ifdef EMXVIDEO
+#include <termios.h>
+# else
+	APIRET APIENTRY DosSleep(ULONG ulTime);
+# endif
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef	unctrl
+#undef	keyname
+#undef	filter
+#undef	use_env
+#undef	put_win
+#undef	get_win
+#undef	delay_output
+#undef	flushinp
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_util  = "$Id: util.c,v 1.3 2001/04/22 05:53:22 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                          util
+
+  Synopsis:
+  	char *unctrl(chtype c);
+  	char *keyname(int key);
+  ***	int filter(void);
+  ***	void use_env(void);
+  ***	int putwin(WINDOW *win, FILE *filep);
+  ***	WINDOW *getwin(FILE *filep);
+  	int delay_output( int ms );
+  	int flushinp(void);
+
+  X/Open Description:
+ 	The unctrl() routine expands the character c into a character
+ 	string which is a printable representation of the character.
+ 	Control characters are displayed in the ^X notation.  Printing
+ 	characters are displayed normally.
+
+ 	The keyname() function returns a pointer to a character string 
+ 	containing a symbolic name corresponding to that specified in 
+ 	the argument key. key may be any key returned by wgetch().
+
+ 	The delay_output() function inserts ms millisecond pause in output.
+ 	On some systems, this has no effect.
+
+ 	The flushinp() routine throws away any type-ahead that has been 
+ 	typed by the user and has not yet been read by the program.
+
+  PDCurses Description:
+ 	The conversion from a control character to a two-character
+ 	sequence is done by the unctrl() function. In the BSD version
+ 	of curses it is done by a macro, which uses a publicly
+ 	available translation table. Some ill-behaved application
+ 	programs use the table directly, and since it does not exist
+ 	in this curses version such application will link with an
+ 	error message complaining about undefined symbols.
+
+ 	If the PDCurses library is compiled under DOS with the FAST_VIDEO
+ 	define true, then we will poke the BIOS keyboard buffer head and
+ 	tail pointers, resetting the typeahead to implement flushinp().
+ 	If this is not true, then we will be unable to reliably flush
+ 	the typeahead.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      unctrl                                Y        Y       Y
+      keyname                               Y        -      3.0
+      filter                                Y        -      3.0
+      use_env                               -        -      4.0
+      put_win                               -        -      4.0
+      get_win                               -        -      4.0
+      delay_output                          Y        Y       Y
+      flushinp                              Y        Y       Y
+
+**man-end**********************************************************************/
+
+static char strbuf[3] = {0, 0, 0};
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char*	PDC_CDECL	unctrl(chtype c)
+#else
+char*	PDC_CDECL	unctrl(c)
+chtype c;
+#endif
+/***********************************************************************/
+{
+	chtype	ic = c;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("unctrl() - called\n");
+#endif
+
+	ic &= A_CHARTEXT;
+	if (ic >= 0x20 && ic != 0x7f)		/* normal characters */
+	{
+		strbuf[0] = (char) ic;
+		strbuf[1] = '\0';
+		return( strbuf );
+	}
+	strbuf[0] = '^';	/* '^' prefix */
+	if (c == 0x7f)
+	{
+		/*
+		 * 0x7f == DEL
+		 */
+		strbuf[1] = '?';
+	}
+	else
+	{
+		/*
+		 * other control
+		 */
+		strbuf[1] = (char)(ic + '@');
+	}
+	return( strbuf );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char *	PDC_CDECL	keyname(int key)
+#else
+char *	PDC_CDECL	keyname(key)
+int key;
+#endif
+/***********************************************************************/
+{
+	static char *key_name[] =
+	{
+ "KEY_BREAK","KEY_DOWN","KEY_UP","KEY_LEFT","KEY_RIGHT","KEY_HOME","KEY_BACKSPACE",
+ "KEY_F0","KEY_F(1)","KEY_F(2)","KEY_F(3)","KEY_F(4)","KEY_F(5)",
+ "KEY_F(6)","KEY_F(7)","KEY_F(8)","KEY_F(9)","KEY_F(10)",
+ "KEY_F(11)","KEY_F(12)","KEY_F(13)","KEY_F(14)","KEY_F(15)",
+ "KEY_F(16)","KEY_F(17)","KEY_F(18)","KEY_F(19)","KEY_F(20)",
+ "KEY_F(21)","KEY_F(22)","KEY_F(23)","KEY_F(24)","KEY_F(25)",
+ "KEY_F(26)","KEY_F(27)","KEY_F(28)","KEY_F(29)","KEY_F(30)",
+ "KEY_F(31)","KEY_F(32)","KEY_F(33)","KEY_F(34)","KEY_F(35)",
+ "KEY_F(36)","KEY_F(37)","KEY_F(38)","KEY_F(39)","KEY_F(40)",
+ "KEY_F(41)","KEY_F(42)","KEY_F(43)","KEY_F(44)","KEY_F(45)",
+ "KEY_F(46)","KEY_F(47)","KEY_F(48)","KEY_F(49)","KEY_F(50)",
+ "KEY_F(51)","KEY_F(52)","KEY_F(53)","KEY_F(54)","KEY_F(55)",
+ "KEY_F(56)","KEY_F(57)","KEY_F(58)","KEY_F(59)","KEY_F(60)",
+ "KEY_F(61)","KEY_F(62)","KEY_F(63)",
+ "KEY_DL","KEY_IL","KEY_DC","KEY_IC","KEY_EIC","KEY_CLEAR","KEY_EOS","KEY_EOL",
+ "KEY_SF","KEY_SR","KEY_NPAGE","KEY_PPAGE","KEY_STAB","KEY_CTAB","KEY_CATAB",
+ "KEY_ENTER","KEY_SRESET","KEY_RESET","KEY_PRINT","KEY_LL","KEY_ABORT","KEY_SHELP",
+ "KEY_LHELP","KEY_BTAB","KEY_BEG","KEY_CANCEL","KEY_CLOSE","KEY_COMMAND","KEY_COPY",
+ "KEY_CREATE","KEY_END","KEY_EXIT","KEY_FIND","KEY_HELP","KEY_MARK","KEY_MESSAGE",
+ "KEY_MOVE","KEY_NEXT","KEY_OPEN","KEY_OPTIONS","KEY_PREVIOUS","KEY_REDO",
+ "KEY_REFERENCE","KEY_REFRESH","KEY_REPLACE","KEY_RESTART","KEY_RESUME","KEY_SAVE",
+ "KEY_SBEG","KEY_SCANCEL","KEY_SCOMMAND","KEY_SCOPY","KEY_SCREATE","KEY_SDC","KEY_SDL",
+ "KEY_SELECT","KEY_SEND","KEY_SEOL","KEY_SEXIT","KEY_SFIND","KEY_SHOME","KEY_SIC",
+ "NO KEY NAME",
+ "KEY_SLEFT","KEY_SMESSAGE","KEY_SMOVE","KEY_SNEXT","KEY_SOPTIONS","KEY_SPREVIOUS",
+ "KEY_SPRINT","KEY_SREDO","KEY_SREPLACE","KEY_SRIGHT","KEY_SRSUME","KEY_SSAVE",
+ "KEY_SSUSPEND","KEY_SUNDO","KEY_SUSPEND","KEY_UNDO",
+ "ALT_0","ALT_1","ALT_2","ALT_3","ALT_4","ALT_5","ALT_6","ALT_7","ALT_8","ALT_9",
+ "ALT_A","ALT_B","ALT_C","ALT_D","ALT_E","ALT_F","ALT_G","ALT_H","ALT_I","ALT_J",
+ "ALT_K","ALT_L","ALT_M","ALT_N","ALT_O","ALT_P","ALT_Q","ALT_R","ALT_S","ALT_T",
+ "ALT_U","ALT_V","ALT_W","ALT_X","ALT_Y","ALT_Z","CTL_LEFT","CTL_RIGHT","CTL_PGUP",
+ "CTL_PGDN","CTL_HOME","CTL_END","KEY_A1","KEY_A2","KEY_A3","KEY_B1",
+ "KEY_B2","KEY_B3","KEY_C1","KEY_C2","KEY_C3","PADSLASH","PADENTER","CTL_PADENTER",
+ "ALT_PADENTER","PADSTOP","PADSTAR","PADMINUS","PADPLUS","CTL_PADSTOP",
+ "CTL_PADCENTER","CTL_PADPLUS","CTL_PADMINUS","CTL_PADSLASH","CTL_PADSTAR","ALT_PADPLUS",
+ "ALT_PADMINUS","ALT_PADSLASH","ALT_PADSTAR","ALT_PADSTOP","CTL_INS","ALT_DEL","ALT_INS","CTL_UP",
+ "CTL_DOWN","CTL_TAB","ALT_TAB","ALT_MINUS","ALT_EQUAL","ALT_HOME","ALT_PGUP","ALT_PGDN",
+ "ALT_END","ALT_UP","ALT_DOWN","ALT_RIGHT","ALT_LEFT","ALT_ENTER","ALT_ESC","ALT_BQUOTE",
+ "ALT_LBRACKET","ALT_RBRACKET","ALT_SEMICOLON","ALT_FQUOTE","ALT_COMMA","ALT_STOP",
+ "ALT_FSLASH","ALT_BKSP","CTL_BKSP","PAD0",
+ "CTL_PAD0","CTL_PAD1","CTL_PAD2","CTL_PAD3","CTL_PAD4",
+ "CTL_PAD5","CTL_PAD6","CTL_PAD7","CTL_PAD8","CTL_PAD9",
+ "ALT_PAD0","ALT_PAD1","ALT_PAD2","ALT_PAD3","ALT_PAD4",
+ "ALT_PAD5","ALT_PAD6","ALT_PAD7","ALT_PAD8","ALT_PAD9",
+ "CTL_DEL","ALT_BSLASH","CTL_ENTER","SHF_PADENTER","SHF_PADSLASH",
+ "SHF_PADSTAR","SHF_PADPLUS","SHF_PADMINUS","SHF_UP","SHF_DOWN",
+ "SHF_IC","SHF_DC","KEY_MOUSE",
+ "KEY_SHIFT_L","KEY_SHIFT_R",
+ "KEY_CONTROL_L","KEY_CONTROL_R",
+ "KEY_ALT_L","KEY_ALT_R",
+ "KEY_RESIZE", "KEY_SUP", "KEY_SDOWN"
+	};
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("keyname() - called: key %d\n",key);
+#endif
+
+
+	key -= KEY_MIN;
+	if (key >= 0
+	&& key <= sizeof(key_name) / sizeof(key_name[0]))
+		return( key_name[key] );
+	else
+		return("NO KEY NAME");
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	delay_output( int ms )
+#else
+int	PDC_CDECL	delay_output(ms)
+int ms;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("delay_output() - called: ms %d\n",ms);
+#endif
+
+#if (defined(TC) || defined(__WATCOMC__)) && defined(DOS)
+	delay( ms );
+	return( OK );
+#endif
+
+#if defined(WIN32)
+	PDC_usleep( ms );
+	return( OK );
+#endif
+
+#if	defined(OS2)
+# if defined(EMX)
+	_sleep2(ms);
+# else
+	DosSleep(ms);
+# endif
+	return( OK );
+#endif
+
+#if	defined(DOS) && defined(MSC)
+	PDC_usleep((clock_t)ms);
+	return( OK );
+#endif
+
+#if	defined(DOS) && defined(NDP)
+	clock_t goal;
+	goal = ms + (float)( (float)clock()/(float)CLOCKS_PER_SEC )*1000;
+	while (goal > (float)( (float)clock()/(float)CLOCKS_PER_SEC )*1000)
+	;
+	return( OK );
+#endif
+
+#if defined(UNIX) || defined(GO32)
+	usleep(1000*ms);
+	return( OK );
+#endif
+
+#if defined(XCURSES)
+	PDC_usleep(ms*1000);
+	return( OK );
+#endif
+
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	flushinp(void)
+#else
+int	PDC_CDECL	flushinp()
+#endif
+/***********************************************************************/
+{
+extern int	c_pindex;		/* putter index */
+extern int	c_gindex;		/* getter index */
+extern int	c_ungind;		/* wungetch() push index */
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("flushinp() - called\n");
+#endif
+
+#if defined(DOS) && defined(FAST_VIDEO)
+	setdosmemword (0x41a, getdosmemword (0x41c)); /* Force the BIOS kbd buf       */
+					/* head/tail pointers to be the */
+					/* same...  Real nasty trick... */
+#  if defined(NDP)
+/*
+	int *KB_HEAD = (int *) mapdev( 0x041aL, sizeof(short) );
+	int *KB_TAIL = (int *) mapdev( 0x041cL, sizeof(short) );
+
+	memcpy( KB_HEAD, KB_TAIL, sizeof(short) );
+*/
+#  endif
+#endif
+
+#ifdef OS2
+#  ifdef EMXVIDEO
+	tcflush(0,TCIFLUSH);
+#  else
+	KbdFlushBuffer(0);
+#  endif
+#endif
+
+#ifdef UNIX
+/* INCOMPLETE */
+#endif
+
+#ifdef XCURSES
+	while(XCurses_kbhit())
+		(void)XCurses_rawgetch(0);
+#endif
+
+	c_gindex = 1;			/* set indices to kill buffer	 */
+	c_pindex = 0;
+	c_ungind = 0;			/* clear c_ungch array		 */
+	return( OK );
+}
+
+#undef traceon
+#undef traceoff
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	traceon(void)
+#else
+void	PDC_CDECL	traceon()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("traceon() - called\n");
+#endif
+	trace_on = TRUE;
+	return;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	traceoff(void)
+#else
+void	PDC_CDECL	traceoff()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("traceoff() - called\n");
+#endif
+	trace_on = FALSE;
+	return;
+}
Index: PDCurses/pdcurses/delch.c
===================================================================
--- PDCurses/pdcurses/delch.c	(revision 1)
+++ PDCurses/pdcurses/delch.c	(working copy)
@@ -1,190 +1,190 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-#include <string.h>
-
-#ifdef HAVE_MEMORY_H
-#  include <memory.h>
-#endif
-
-/* undefine any macros for functions defined in this module */
-#undef	delch
-#undef	wdelch
-#undef	mvdelch
-#undef	mvwdelch
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef	move
-#  undef	wmove
-#endif
-
-#ifndef HAVE_MEMMOVE
-#  define memmove PDC_memmove
-#endif
-
-
-#ifdef PDCDEBUG
-char *rcsid_delch  = "$Id: delch.c,v 1.1 2001/01/10 08:26:57 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                         delch
-
-  Synopsis:
-  	int delch(void);
-  	int wdelch(WINDOW *win);
-  	int mvdelch(int y, int x);
-  	int mvwdelch(WINDOW *win, int y, int x);
-
-  X/Open Description:
- 	The character under the cursor in the window is deleted.  All
- 	characters to the right on the same line are moved to the left
- 	one position and the last character on the line is filled with
- 	a blank.  The cursor position does not change (after moving to
- 	y, x if coordinates are specified).
-
- 	NOTE: delch(), mvdelch(), and mvwdelch() are implemented as macros.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  NOTE:
- 	The behaviour of Unix curses is to display a blank in the last
- 	column of the window with the A_NORMAL attribute. PDCurses
- 	displays the blank with the window's current attributes 
- 	(including current colour). To get the behaviour of PDCurses,
- 	#define PDCURSES_WCLR in curses.h or add -DPDCURSES_WCLR to the 
- 	compile switches.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      delch                                 Y        Y       Y
-      wdelch                                Y        Y       Y
-      mvdelch                               Y        Y       Y
-      mvwdelch                              Y        Y       Y
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	delch(void)
-#else
-int	PDC_CDECL	delch()
-#endif
-/***********************************************************************/
-{
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("delch() - called\n");
-#endif
-
-	return (wdelch(stdscr));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	wdelch(WINDOW *win)
-#else
-int	PDC_CDECL	wdelch(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-	int		y;
-	int		x;
-	int		maxx;
-	chtype*		temp1;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wdelch() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return (ERR);
-
-	y	= win->_cury;
-	x	= win->_curx;
-	maxx	= win->_maxx - 1;
-	temp1	= &win->_y[y][x];
-
-	memmove( temp1, temp1 + 1, (maxx - x) * sizeof(chtype) );
-
-#if defined(PDCURSES_WCLR)
-	win->_y[y][maxx]	= win->_blank | win->_attrs;
-#else
-/* wrs (4/10/93) account for window background */
-	win->_y[y][maxx]	= win->_bkgd;
-#endif
-
-	win->_lastch[y] = maxx;
-
-	if ((win->_firstch[y] == _NO_CHANGE) ||
-	    (win->_firstch[y] > x))
-	{
-		win->_firstch[y] = x;
-	}
-	PDC_sync(win);
-	return (OK);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvdelch(int y, int x)
-#else
-int	PDC_CDECL	mvdelch(y,x)
-int y;
-int x;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvdelch() - called\n");
-#endif
-
-	if (move(y,x) == ERR)
-		return(ERR);
-	return(delch());
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvwdelch(WINDOW *win, int y, int x)
-#else
-int	PDC_CDECL	mvwdelch(win,y,x)
-WINDOW *win;
-int y;
-int x;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvwdelch() - called\n");
-#endif
-
-	if (wmove(win,y,x) == ERR)
-		return(ERR);
-	return(wdelch(win));
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+#include <string.h>
+
+#ifdef HAVE_MEMORY_H
+#  include <memory.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef	delch
+#undef	wdelch
+#undef	mvdelch
+#undef	mvwdelch
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	move
+#  undef	wmove
+#endif
+
+#ifndef HAVE_MEMMOVE
+#  define memmove PDC_memmove
+#endif
+
+
+#ifdef PDCDEBUG
+char *rcsid_delch  = "$Id: delch.c,v 1.1 2001/01/10 08:26:57 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         delch
+
+  Synopsis:
+  	int delch(void);
+  	int wdelch(WINDOW *win);
+  	int mvdelch(int y, int x);
+  	int mvwdelch(WINDOW *win, int y, int x);
+
+  X/Open Description:
+ 	The character under the cursor in the window is deleted.  All
+ 	characters to the right on the same line are moved to the left
+ 	one position and the last character on the line is filled with
+ 	a blank.  The cursor position does not change (after moving to
+ 	y, x if coordinates are specified).
+
+ 	NOTE: delch(), mvdelch(), and mvwdelch() are implemented as macros.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  NOTE:
+ 	The behaviour of Unix curses is to display a blank in the last
+ 	column of the window with the A_NORMAL attribute. PDCurses
+ 	displays the blank with the window's current attributes 
+ 	(including current colour). To get the behaviour of PDCurses,
+ 	#define PDCURSES_WCLR in curses.h or add -DPDCURSES_WCLR to the 
+ 	compile switches.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      delch                                 Y        Y       Y
+      wdelch                                Y        Y       Y
+      mvdelch                               Y        Y       Y
+      mvwdelch                              Y        Y       Y
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	delch(void)
+#else
+int	PDC_CDECL	delch()
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("delch() - called\n");
+#endif
+
+	return (wdelch(stdscr));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wdelch(WINDOW *win)
+#else
+int	PDC_CDECL	wdelch(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	int		y;
+	int		x;
+	int		maxx;
+	chtype*		temp1;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wdelch() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return (ERR);
+
+	y	= win->_cury;
+	x	= win->_curx;
+	maxx	= win->_maxx - 1;
+	temp1	= &win->_y[y][x];
+
+	memmove( temp1, temp1 + 1, (maxx - x) * sizeof(chtype) );
+
+#if defined(PDCURSES_WCLR)
+	win->_y[y][maxx]	= win->_blank | win->_attrs;
+#else
+/* wrs (4/10/93) account for window background */
+	win->_y[y][maxx]	= win->_bkgd;
+#endif
+
+	win->_lastch[y] = maxx;
+
+	if ((win->_firstch[y] == _NO_CHANGE) ||
+	    (win->_firstch[y] > x))
+	{
+		win->_firstch[y] = x;
+	}
+	PDC_sync(win);
+	return (OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvdelch(int y, int x)
+#else
+int	PDC_CDECL	mvdelch(y,x)
+int y;
+int x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvdelch() - called\n");
+#endif
+
+	if (move(y,x) == ERR)
+		return(ERR);
+	return(delch());
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwdelch(WINDOW *win, int y, int x)
+#else
+int	PDC_CDECL	mvwdelch(win,y,x)
+WINDOW *win;
+int y;
+int x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwdelch() - called\n");
+#endif
+
+	if (wmove(win,y,x) == ERR)
+		return(ERR);
+	return(wdelch(win));
+}
Index: PDCurses/pdcurses/kernel.c
===================================================================
--- PDCurses/pdcurses/kernel.c	(revision 1)
+++ PDCurses/pdcurses/kernel.c	(working copy)
@@ -1,507 +1,507 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define  CURSES_LIBRARY 1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-#ifdef HAVE_MEMORY_H
-#include <memory.h>
-#endif
-
-#ifdef UNIX
-#include <defs.h>
-#include <term.h>
-#endif
-
-/* undefine any macros for functions defined in this module */
-#undef   def_prog_mode
-#undef   def_shell_mode
-#undef   reset_prog_mode
-#undef   reset_shell_mode
-#undef   resetty
-#undef   savetty
-#undef   ripoffline
-#undef   curs_set
-#undef   napms
-#undef   draino
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef move
-#  undef wmove
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_kernel  = "$Id: kernel.c,v 1.3 2002/11/27 11:24:31 mark Exp $";
-#endif
-
-RIPPEDOFFLINE linesripped[5];
-char linesrippedoff=0;
-
-/*man-start*********************************************************************
-
-  Name:                                                        kernel
-
-  Synopsis:
-   int def_prog_mode(void);
-   int def_shell_mode(void);
-   int reset_prog_mode(void);
-   int reset_shell_mode(void);
-   int resetty(void);
-   int savetty(void);
-   void getsyx(int y, int x);
-   void setsyx(int y, int x);
-   int ripoffline(int line, int (*init)(WINDOW *,int));
-   int curs_set(int visibility);
-   int napms(int ms);
-   int draino(int ms);
-
-  X/Open Description:
-   The def_prog_mode() and def_shell_mode() functions save the 
-   current terminal modes as the "program" (in curses) or
-   "shell" (not in curses) state for use by the reset_prog_mode()
-   and reset_shell_mode() functions.  This is done automatically by
-   initscr().
-
-   The reset_prog_mode() and reset_shell_mode() functions restore 
-   the terminal to "program" (in curses) or "shell" (not in curses)
-   state.  These are done automatically by endwin()
-   and doupdate() after an endwin(), so they would normally not
-   be called before these functions.
-
-   The savetty() and resetty() routines save and restore the state of 
-   the terminal modes. The savetty() function saves the current state 
-   in a buffer and resetty() restores the state to what it was at the 
-   last call to savetty().
-
-   The getsyx() routine obtains the coordinates of the virtual screen
-   cursor. If leaveok() is currently TRUE, then -1, -1 is returned. If
-   lines have been removed from the top of the screen with ripoffline()
-   then getsyx() includes those lines, so y and x should only be used
-   by setyx().
-   The setyx() routine sets the cursor position of the virtual screen
-   to the y,x coordinates. If y,x are -1,-1, leaveok() is set TRUE.
-   The getsyx() and setsyx() routines are designed to be used by a
-   library routine that manipulates curses windows, but does not want
-   to change the position of the cursor.
-
-   Note that getsyx() and setsyx() are defined as macros only. System VR4
-   defines these as having a return type of int, but that is misleading as
-   there is no documented sematics for the return value.
-
-   The curs_set() function enables the appearance of the text cursor
-   to be altered. A value of 0 for visibility makes the cursor
-   disappear; a value of 1 makes the cursor appear "normal" (usually
-   an underline) and 2 makes the cursor "highly visible"; a block.
-
-   The ripoffline() function allows the user to reduce the size of
-   stdscr by 1 line.  If the value of line is positive, the line is 
-   removed from the top of the screen; negative from the bottom. Up to
-   5 lines can be ripped off stdscr by calling ripoffline()
-   consecutively.
-   The function argument, init, is called from within initscr() or
-   newterm(), so ripoffline() must be called before either of these
-   functions.  The init function is passed a pointer to a 1 line
-   WINDOW and the width of the window. Calling ripoffline() with a
-   NULL initialise function pointer is not advisable!
-
-   The napms() and draino() functions, suspends the program for the
-   specified number of milliseconds.
-
-  PDCurses Description:
-   FYI: It is very unclear whether savetty() and resetty() functions
-   are a duplication of the reset_prog_mode() and reset_shell_mode() 
-   functions or whether this is a backing store type of operation.  
-   At this time, they are implemented similar to the reset_*_mode() 
-   routines.
-
-   The curs_set() routine is used to set the visibility of the cursor.
-   The cursor can be made invisible, normal or highly visible by setting
-   the parameter to 0, 1 or 2 respectively. If an invalid value is passed
-   the function will set the cursor to "normal".
-
-  X/Open Return Value:
-   All functions return OK on success and ERR on error except curs_set()
-   which returns the previous visibility.
-
-  X/Open Errors:
-   No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      def_prog_mode                         Y        Y       Y
-      def_shell_mode                        Y        Y       Y
-      reset_prog_mode                       Y        Y       Y
-      reset_shell_mode                      Y        Y       Y
-      resetty                               Y        Y       Y
-      savetty                               Y        Y       Y
-      getsyx                                -        -      3.0
-      setsyx                                -        -      3.0
-      ripoffline                            -        -      3.0
-      curs_set                              -        -      3.0
-      napms                                 Y        Y       Y
-
-**man-end**********************************************************************/
-
-#ifndef UNIX
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   def_prog_mode(void)
-#else
-int   PDC_CDECL   def_prog_mode()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("def_prog_mode() - called\n");
-#endif
-
-#ifdef   FLEXOS
-   _flexos_16bitmode();
-#endif
-   c_pr_tty.been_set = TRUE;
-
-   memcpy(&c_pr_tty.saved, SP, sizeof(SCREEN));
-
-   return( OK );
-}
-#endif
-
-#ifndef UNIX
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   def_shell_mode(void)
-#else
-int   PDC_CDECL   def_shell_mode()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("def_shell_mode() - called\n");
-#endif
-
-#ifdef   FLEXOS
-   _flexos_8bitmode();
-#endif
-   c_sh_tty.been_set = TRUE;
-
-   memcpy(&c_sh_tty.saved, SP, sizeof(SCREEN));
-
-   return( OK );
-}
-#endif
-
-#ifndef UNIX
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_CDECL reset_prog_mode(void)
-#else
-int PDC_CDECL reset_prog_mode()
-#endif
-/***********************************************************************/
-{
-#if defined(OS2) && !defined(EMXVIDEO)
-   VIOMODEINFO modeInfo;
-#endif
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("reset_prog_mode() - called\n");
-#endif
-   if (c_pr_tty.been_set == TRUE)
-   {
-      memcpy(SP, &c_pr_tty.saved, sizeof(SCREEN));
-
-      mvcur(0, 0, c_pr_tty.saved.cursrow, c_pr_tty.saved.curscol);
-      if (PDC_get_ctrl_break() != c_pr_tty.saved.orgcbr)
-         PDC_set_ctrl_break(c_pr_tty.saved.orgcbr);
-      if (c_pr_tty.saved.raw_out)
-         raw();
-      if (c_pr_tty.saved.visible_cursor)
-         PDC_cursor_on();
-      SP->font = PDC_get_font();
-      PDC_set_font(c_pr_tty.saved.font);
-#if !defined (XCURSES)
-# if !defined(EMXVIDEO)
-#  if defined(OS2)
-      (void)PDC_get_scrn_mode( &modeInfo );
-      if ( !PDC_scrn_modes_equal( modeInfo, c_pr_tty.saved.scrnmode ) )
-         PDC_set_scrn_mode( c_pr_tty.saved.scrnmode );
-#  else
-      if ( !PDC_scrn_modes_equal( PDC_get_scrn_mode(), c_pr_tty.saved.scrnmode ) )
-         PDC_set_scrn_mode( c_pr_tty.saved.scrnmode );
-#  endif
-# endif
-#endif
-      PDC_set_rows(c_pr_tty.saved.lines);
-   }
-#ifdef FLEXOS
-   _flexos_16bitmode();
-#endif
-
-#if defined(WIN32) || (defined(OS2) && !defined(EMXVIDEO))
-   PDC_reset_prog_mode();
-#endif
-   return( OK );
-}
-#endif
-
-#ifndef UNIX
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_CDECL reset_shell_mode(void)
-#else
-int PDC_CDECL reset_shell_mode()
-#endif
-/***********************************************************************/
-{
-#if defined(OS2) && !defined(EMXVIDEO)
-   VIOMODEINFO modeInfo;
-#endif
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("reset_shell_mode() - called\n");
-#endif
-
-#ifndef WIN32
-   if (c_sh_tty.been_set == TRUE)
-   {
-      memcpy(SP, &c_sh_tty.saved, sizeof(SCREEN));
-
-      mvcur(0, 0, c_sh_tty.saved.cursrow, c_sh_tty.saved.curscol);
-      if (PDC_get_ctrl_break() != c_sh_tty.saved.orgcbr)
-         PDC_set_ctrl_break(c_sh_tty.saved.orgcbr);
-      if (c_sh_tty.saved.raw_out)
-         raw();
-      if (c_sh_tty.saved.visible_cursor)
-         PDC_cursor_on();
-      SP->font = PDC_get_font();
-      PDC_set_font(c_sh_tty.saved.font);
-#if !defined (XCURSES)
-# if !defined(EMXVIDEO)
-#  if defined(OS2)
-      (void)PDC_get_scrn_mode( &modeInfo );
-      if ( !PDC_scrn_modes_equal( modeInfo, c_sh_tty.saved.scrnmode ) )
-         PDC_set_scrn_mode( c_sh_tty.saved.scrnmode );
-#  else
-      if ( !PDC_scrn_modes_equal( PDC_get_scrn_mode(), c_sh_tty.saved.scrnmode ) )
-         PDC_set_scrn_mode( c_sh_tty.saved.scrnmode );
-#  endif
-# endif
-#endif
-#if defined(OS2) || defined(WIN32)
-      PDC_resize_screen(c_sh_tty.saved.lines,c_sh_tty.saved.cols);
-#else
-      PDC_set_rows(c_sh_tty.saved.lines);
-#endif
-   }
-#endif
-
-#ifdef   FLEXOS
-   _flexos_8bitmode();
-#endif
-
-#if defined(WIN32) || (defined(OS2) && !defined(EMXVIDEO))
-   PDC_reset_shell_mode();
-#endif
-
-   return( OK );
-}
-#endif
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_CDECL resetty(void)
-#else
-int PDC_CDECL resetty()
-#endif
-/***********************************************************************/
-{
-#if defined(OS2) && !defined(EMXVIDEO)
-   VIOMODEINFO modeInfo;
-#endif
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("resetty() - called\n");
-#endif
-
-#ifndef UNIX
-   if (c_save_tty.been_set == TRUE)
-   {
-      memcpy(SP, &c_save_tty.saved, sizeof(SCREEN));
-      mvcur(0, 0, c_save_tty.saved.cursrow, c_save_tty.saved.curscol);
-      if (PDC_get_ctrl_break() != c_save_tty.saved.orgcbr)
-         PDC_set_ctrl_break(c_save_tty.saved.orgcbr);
-      if (c_save_tty.saved.raw_out)
-         raw();
-      if (c_save_tty.saved.visible_cursor)
-         PDC_cursor_on();
-      SP->font = PDC_get_font();
-      PDC_set_font(c_save_tty.saved.font);
-# if !defined (XCURSES)
-#  if !defined(EMXVIDEO)
-#   if defined(OS2)
-      (void)PDC_get_scrn_mode( &modeInfo );
-      if ( !PDC_scrn_modes_equal( modeInfo, c_save_tty.saved.scrnmode ) )
-         PDC_set_scrn_mode( c_save_tty.saved.scrnmode );
-#   else
-      if ( !PDC_scrn_modes_equal( PDC_get_scrn_mode(), c_save_tty.saved.scrnmode ) )
-         PDC_set_scrn_mode( c_save_tty.saved.scrnmode );
-#   endif
-#  endif
-# endif
-# if defined(OS2)
-      PDC_resize_screen(c_save_tty.saved.lines,c_save_tty.saved.cols);
-# else
-      PDC_set_rows(c_save_tty.saved.lines);
-# endif
-   }
-#endif
-   return( c_save_tty.been_set ? OK : ERR );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   savetty(void)
-#else
-int   PDC_CDECL   savetty()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("savetty() - called\n");
-#endif
-
-   c_save_tty.been_set = TRUE;
-   memcpy(&c_save_tty.saved, SP, sizeof(SCREEN));
-   return( OK );
-}
-#if 0
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   getsyx(int *y, int *x)
-#else
-int   PDC_CDECL   getsyx(y,x)
-int *y,*x;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("getsyx() - called\n");
-#endif
-
-   if (curscr->_leaveit)
-      *y = *x = (-1);
-   else
-   {
-      *y = curscr->_cury - SP->linesrippedoffontop;
-      *x = curscr->_curx;
-   }
-   return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   setsyx(int y, int x)
-#else
-int   PDC_CDECL   setsyx(y,x)
-int y,x;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("setsyx() - called\n");
-#endif
-
-   if (y < 0 && x < 0)
-      curscr->_leaveit = TRUE;
-   else
-   {
-      curscr->_cury = y + SP->linesrippedoffontop;
-      curscr->_curx = x;
-      curscr->_leaveit = FALSE;
-   }
-   return( OK );
-}
-#endif
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   curs_set(int visibility)
-#else
-int   PDC_CDECL   curs_set(visibility)
-int visibility;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("curs_set() - called: visibility=%d\n",visibility);
-#endif
-
-   return(PDC_curs_set(visibility));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   ripoffline(int line, int (*init)(WINDOW *,int))
-#else
-int   PDC_CDECL   ripoffline(line, init)
-int line;
-int (*init)();
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("ripoffline() - called: line=%d\n",line);
-#endif
-
-   if (linesrippedoff < 5
-   &&  line != 0)
-   {
-   linesripped[(int)linesrippedoff].line = line;
-   linesripped[(int)linesrippedoff++].init = init;
-   }
-   return(OK);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   napms(int ms)
-#else
-int   PDC_CDECL   napms(ms)
-int ms;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("napms() - called: ms=%d\n",ms);
-#endif
-   return(delay_output(ms));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   draino(int ms)
-#else
-int   PDC_CDECL   draino(ms)
-int ms;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("draino() - called: ms=%d\n",ms);
-#endif
-   return(delay_output(ms));
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define  CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef HAVE_MEMORY_H
+#include <memory.h>
+#endif
+
+#ifdef UNIX
+#include <defs.h>
+#include <term.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef   def_prog_mode
+#undef   def_shell_mode
+#undef   reset_prog_mode
+#undef   reset_shell_mode
+#undef   resetty
+#undef   savetty
+#undef   ripoffline
+#undef   curs_set
+#undef   napms
+#undef   draino
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef move
+#  undef wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_kernel  = "$Id: kernel.c,v 1.3 2002/11/27 11:24:31 mark Exp $";
+#endif
+
+RIPPEDOFFLINE linesripped[5];
+char linesrippedoff=0;
+
+/*man-start*********************************************************************
+
+  Name:                                                        kernel
+
+  Synopsis:
+   int def_prog_mode(void);
+   int def_shell_mode(void);
+   int reset_prog_mode(void);
+   int reset_shell_mode(void);
+   int resetty(void);
+   int savetty(void);
+   void getsyx(int y, int x);
+   void setsyx(int y, int x);
+   int ripoffline(int line, int (*init)(WINDOW *,int));
+   int curs_set(int visibility);
+   int napms(int ms);
+   int draino(int ms);
+
+  X/Open Description:
+   The def_prog_mode() and def_shell_mode() functions save the 
+   current terminal modes as the "program" (in curses) or
+   "shell" (not in curses) state for use by the reset_prog_mode()
+   and reset_shell_mode() functions.  This is done automatically by
+   initscr().
+
+   The reset_prog_mode() and reset_shell_mode() functions restore 
+   the terminal to "program" (in curses) or "shell" (not in curses)
+   state.  These are done automatically by endwin()
+   and doupdate() after an endwin(), so they would normally not
+   be called before these functions.
+
+   The savetty() and resetty() routines save and restore the state of 
+   the terminal modes. The savetty() function saves the current state 
+   in a buffer and resetty() restores the state to what it was at the 
+   last call to savetty().
+
+   The getsyx() routine obtains the coordinates of the virtual screen
+   cursor. If leaveok() is currently TRUE, then -1, -1 is returned. If
+   lines have been removed from the top of the screen with ripoffline()
+   then getsyx() includes those lines, so y and x should only be used
+   by setyx().
+   The setyx() routine sets the cursor position of the virtual screen
+   to the y,x coordinates. If y,x are -1,-1, leaveok() is set TRUE.
+   The getsyx() and setsyx() routines are designed to be used by a
+   library routine that manipulates curses windows, but does not want
+   to change the position of the cursor.
+
+   Note that getsyx() and setsyx() are defined as macros only. System VR4
+   defines these as having a return type of int, but that is misleading as
+   there is no documented sematics for the return value.
+
+   The curs_set() function enables the appearance of the text cursor
+   to be altered. A value of 0 for visibility makes the cursor
+   disappear; a value of 1 makes the cursor appear "normal" (usually
+   an underline) and 2 makes the cursor "highly visible"; a block.
+
+   The ripoffline() function allows the user to reduce the size of
+   stdscr by 1 line.  If the value of line is positive, the line is 
+   removed from the top of the screen; negative from the bottom. Up to
+   5 lines can be ripped off stdscr by calling ripoffline()
+   consecutively.
+   The function argument, init, is called from within initscr() or
+   newterm(), so ripoffline() must be called before either of these
+   functions.  The init function is passed a pointer to a 1 line
+   WINDOW and the width of the window. Calling ripoffline() with a
+   NULL initialise function pointer is not advisable!
+
+   The napms() and draino() functions, suspends the program for the
+   specified number of milliseconds.
+
+  PDCurses Description:
+   FYI: It is very unclear whether savetty() and resetty() functions
+   are a duplication of the reset_prog_mode() and reset_shell_mode() 
+   functions or whether this is a backing store type of operation.  
+   At this time, they are implemented similar to the reset_*_mode() 
+   routines.
+
+   The curs_set() routine is used to set the visibility of the cursor.
+   The cursor can be made invisible, normal or highly visible by setting
+   the parameter to 0, 1 or 2 respectively. If an invalid value is passed
+   the function will set the cursor to "normal".
+
+  X/Open Return Value:
+   All functions return OK on success and ERR on error except curs_set()
+   which returns the previous visibility.
+
+  X/Open Errors:
+   No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      def_prog_mode                         Y        Y       Y
+      def_shell_mode                        Y        Y       Y
+      reset_prog_mode                       Y        Y       Y
+      reset_shell_mode                      Y        Y       Y
+      resetty                               Y        Y       Y
+      savetty                               Y        Y       Y
+      getsyx                                -        -      3.0
+      setsyx                                -        -      3.0
+      ripoffline                            -        -      3.0
+      curs_set                              -        -      3.0
+      napms                                 Y        Y       Y
+
+**man-end**********************************************************************/
+
+#ifndef UNIX
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   def_prog_mode(void)
+#else
+int   PDC_CDECL   def_prog_mode()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("def_prog_mode() - called\n");
+#endif
+
+#ifdef   FLEXOS
+   _flexos_16bitmode();
+#endif
+   c_pr_tty.been_set = TRUE;
+
+   memcpy(&c_pr_tty.saved, PDC_SP, sizeof(SCREEN));
+
+   return( OK );
+}
+#endif
+
+#ifndef UNIX
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   def_shell_mode(void)
+#else
+int   PDC_CDECL   def_shell_mode()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("def_shell_mode() - called\n");
+#endif
+
+#ifdef   FLEXOS
+   _flexos_8bitmode();
+#endif
+   c_sh_tty.been_set = TRUE;
+
+   memcpy(&c_sh_tty.saved, PDC_SP, sizeof(SCREEN));
+
+   return( OK );
+}
+#endif
+
+#ifndef UNIX
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL reset_prog_mode(void)
+#else
+int PDC_CDECL reset_prog_mode()
+#endif
+/***********************************************************************/
+{
+#if defined(OS2) && !defined(EMXVIDEO)
+   VIOMODEINFO modeInfo;
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("reset_prog_mode() - called\n");
+#endif
+   if (c_pr_tty.been_set == TRUE)
+   {
+      memcpy(PDC_SP, &c_pr_tty.saved, sizeof(SCREEN));
+
+      mvcur(0, 0, c_pr_tty.saved.cursrow, c_pr_tty.saved.curscol);
+      if (PDC_get_ctrl_break() != c_pr_tty.saved.orgcbr)
+         PDC_set_ctrl_break(c_pr_tty.saved.orgcbr);
+      if (c_pr_tty.saved.raw_out)
+         raw();
+      if (c_pr_tty.saved.visible_cursor)
+         PDC_cursor_on();
+      PDC_SP->font = PDC_get_font();
+      PDC_set_font(c_pr_tty.saved.font);
+#if !defined (XCURSES)
+# if !defined(EMXVIDEO)
+#  if defined(OS2)
+      (void)PDC_get_scrn_mode( &modeInfo );
+      if ( !PDC_scrn_modes_equal( modeInfo, c_pr_tty.saved.scrnmode ) )
+         PDC_set_scrn_mode( c_pr_tty.saved.scrnmode );
+#  else
+      if ( !PDC_scrn_modes_equal( PDC_get_scrn_mode(), c_pr_tty.saved.scrnmode ) )
+         PDC_set_scrn_mode( c_pr_tty.saved.scrnmode );
+#  endif
+# endif
+#endif
+      PDC_set_rows(c_pr_tty.saved.lines);
+   }
+#ifdef FLEXOS
+   _flexos_16bitmode();
+#endif
+
+#if defined(WIN32) || (defined(OS2) && !defined(EMXVIDEO))
+   PDC_reset_prog_mode();
+#endif
+   return( OK );
+}
+#endif
+
+#ifndef UNIX
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL reset_shell_mode(void)
+#else
+int PDC_CDECL reset_shell_mode()
+#endif
+/***********************************************************************/
+{
+#if defined(OS2) && !defined(EMXVIDEO)
+   VIOMODEINFO modeInfo;
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("reset_shell_mode() - called\n");
+#endif
+
+#ifndef WIN32
+   if (c_sh_tty.been_set == TRUE)
+   {
+      memcpy(PDC_SP, &c_sh_tty.saved, sizeof(SCREEN));
+
+      mvcur(0, 0, c_sh_tty.saved.cursrow, c_sh_tty.saved.curscol);
+      if (PDC_get_ctrl_break() != c_sh_tty.saved.orgcbr)
+         PDC_set_ctrl_break(c_sh_tty.saved.orgcbr);
+      if (c_sh_tty.saved.raw_out)
+         raw();
+      if (c_sh_tty.saved.visible_cursor)
+         PDC_cursor_on();
+      PDC_SP->font = PDC_get_font();
+      PDC_set_font(c_sh_tty.saved.font);
+#if !defined (XCURSES)
+# if !defined(EMXVIDEO)
+#  if defined(OS2)
+      (void)PDC_get_scrn_mode( &modeInfo );
+      if ( !PDC_scrn_modes_equal( modeInfo, c_sh_tty.saved.scrnmode ) )
+         PDC_set_scrn_mode( c_sh_tty.saved.scrnmode );
+#  else
+      if ( !PDC_scrn_modes_equal( PDC_get_scrn_mode(), c_sh_tty.saved.scrnmode ) )
+         PDC_set_scrn_mode( c_sh_tty.saved.scrnmode );
+#  endif
+# endif
+#endif
+#if defined(OS2) || defined(WIN32)
+      PDC_resize_screen(c_sh_tty.saved.lines,c_sh_tty.saved.cols);
+#else
+      PDC_set_rows(c_sh_tty.saved.lines);
+#endif
+   }
+#endif
+
+#ifdef   FLEXOS
+   _flexos_8bitmode();
+#endif
+
+#if defined(WIN32) || (defined(OS2) && !defined(EMXVIDEO))
+   PDC_reset_shell_mode();
+#endif
+
+   return( OK );
+}
+#endif
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL resetty(void)
+#else
+int PDC_CDECL resetty()
+#endif
+/***********************************************************************/
+{
+#if defined(OS2) && !defined(EMXVIDEO)
+   VIOMODEINFO modeInfo;
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("resetty() - called\n");
+#endif
+
+#ifndef UNIX
+   if (c_save_tty.been_set == TRUE)
+   {
+      memcpy(PDC_SP, &c_save_tty.saved, sizeof(SCREEN));
+      mvcur(0, 0, c_save_tty.saved.cursrow, c_save_tty.saved.curscol);
+      if (PDC_get_ctrl_break() != c_save_tty.saved.orgcbr)
+         PDC_set_ctrl_break(c_save_tty.saved.orgcbr);
+      if (c_save_tty.saved.raw_out)
+         raw();
+      if (c_save_tty.saved.visible_cursor)
+         PDC_cursor_on();
+      PDC_SP->font = PDC_get_font();
+      PDC_set_font(c_save_tty.saved.font);
+# if !defined (XCURSES)
+#  if !defined(EMXVIDEO)
+#   if defined(OS2)
+      (void)PDC_get_scrn_mode( &modeInfo );
+      if ( !PDC_scrn_modes_equal( modeInfo, c_save_tty.saved.scrnmode ) )
+         PDC_set_scrn_mode( c_save_tty.saved.scrnmode );
+#   else
+      if ( !PDC_scrn_modes_equal( PDC_get_scrn_mode(), c_save_tty.saved.scrnmode ) )
+         PDC_set_scrn_mode( c_save_tty.saved.scrnmode );
+#   endif
+#  endif
+# endif
+# if defined(OS2)
+      PDC_resize_screen(c_save_tty.saved.lines,c_save_tty.saved.cols);
+# else
+      PDC_set_rows(c_save_tty.saved.lines);
+# endif
+   }
+#endif
+   return( c_save_tty.been_set ? OK : ERR );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   savetty(void)
+#else
+int   PDC_CDECL   savetty()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("savetty() - called\n");
+#endif
+
+   c_save_tty.been_set = TRUE;
+   memcpy(&c_save_tty.saved, PDC_SP, sizeof(SCREEN));
+   return( OK );
+}
+#if 0
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   getsyx(int *y, int *x)
+#else
+int   PDC_CDECL   getsyx(y,x)
+int *y,*x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("getsyx() - called\n");
+#endif
+
+   if (curscr->_leaveit)
+      *y = *x = (-1);
+   else
+   {
+      *y = curscr->_cury - PDC_SP->linesrippedoffontop;
+      *x = curscr->_curx;
+   }
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   setsyx(int y, int x)
+#else
+int   PDC_CDECL   setsyx(y,x)
+int y,x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("setsyx() - called\n");
+#endif
+
+   if (y < 0 && x < 0)
+      curscr->_leaveit = TRUE;
+   else
+   {
+      curscr->_cury = y + PDC_SP->linesrippedoffontop;
+      curscr->_curx = x;
+      curscr->_leaveit = FALSE;
+   }
+   return( OK );
+}
+#endif
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   curs_set(int visibility)
+#else
+int   PDC_CDECL   curs_set(visibility)
+int visibility;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("curs_set() - called: visibility=%d\n",visibility);
+#endif
+
+   return(PDC_curs_set(visibility));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   ripoffline(int line, int (*init)(WINDOW *,int))
+#else
+int   PDC_CDECL   ripoffline(line, init)
+int line;
+int (*init)();
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("ripoffline() - called: line=%d\n",line);
+#endif
+
+   if (linesrippedoff < 5
+   &&  line != 0)
+   {
+   linesripped[(int)linesrippedoff].line = line;
+   linesripped[(int)linesrippedoff++].init = init;
+   }
+   return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   napms(int ms)
+#else
+int   PDC_CDECL   napms(ms)
+int ms;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("napms() - called: ms=%d\n",ms);
+#endif
+   return(delay_output(ms));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   draino(int ms)
+#else
+int   PDC_CDECL   draino(ms)
+int ms;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("draino() - called: ms=%d\n",ms);
+#endif
+   return(delay_output(ms));
+}
Index: PDCurses/pdcurses/terminfo.c
===================================================================
--- PDCurses/pdcurses/terminfo.c	(revision 1)
+++ PDCurses/pdcurses/terminfo.c	(working copy)
@@ -1,93 +1,93 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	mvcur
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_terminfo  = "$Id: terminfo.c,v 1.1 2001/01/10 08:27:31 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                      terminfo
-
-  Synopsis:
-  	int mvcur(int oldrow, int oldcol, int newrow, int newcol)
-
-  X/Open Description:
- 	The mvcur() function controls low-level cursor motion with 
- 	optimization.
-
- 	NOTE: The remainer of the terminfo functions have not been
- 			implemented.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      mvcur                                 Y        Y       Y
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvcur(int oldrow, int oldcol, int newrow, int newcol)
-#else
-int	PDC_CDECL	mvcur(oldrow,oldcol,newrow,newcol)
-int oldrow;
-int oldcol;
-int newrow;
-int newcol;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvcur() - called: oldrow %d oldcol %d newrow %d newcol %d\n",oldrow,oldcol,newrow,newcol);
-#endif
-
-#ifdef	TC
-#  pragma argsused
-#endif
-	if ((newrow >= LINES)	||
-	    (newcol >= COLS)	||
-	    (newrow < 0)	||
-	    (newcol < 0))
-	{
-		return( ERR );
-	}
-	PDC_gotoxy( newrow, newcol );
-	SP->cursrow = newrow;
-	SP->curscol = newcol;
-	return( OK );
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	mvcur
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_terminfo  = "$Id: terminfo.c,v 1.1 2001/01/10 08:27:31 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                      terminfo
+
+  Synopsis:
+  	int mvcur(int oldrow, int oldcol, int newrow, int newcol)
+
+  X/Open Description:
+ 	The mvcur() function controls low-level cursor motion with 
+ 	optimization.
+
+ 	NOTE: The remainer of the terminfo functions have not been
+ 			implemented.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      mvcur                                 Y        Y       Y
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvcur(int oldrow, int oldcol, int newrow, int newcol)
+#else
+int	PDC_CDECL	mvcur(oldrow,oldcol,newrow,newcol)
+int oldrow;
+int oldcol;
+int newrow;
+int newcol;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvcur() - called: oldrow %d oldcol %d newrow %d newcol %d\n",oldrow,oldcol,newrow,newcol);
+#endif
+
+#ifdef	TC
+#  pragma argsused
+#endif
+	if ((newrow >= LINES)	||
+	    (newcol >= COLS)	||
+	    (newrow < 0)	||
+	    (newcol < 0))
+	{
+		return( ERR );
+	}
+	PDC_gotoxy( newrow, newcol );
+	PDC_SP->cursrow = newrow;
+	PDC_SP->curscol = newcol;
+	return( OK );
+}
Index: PDCurses/pdcurses/printw.c
===================================================================
--- PDCurses/pdcurses/printw.c	(revision 1)
+++ PDCurses/pdcurses/printw.c	(working copy)
@@ -1,248 +1,248 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-#include <string.h>
-
-#if defined(HAVE_STDARG_H) && defined(HAVE_PROTO)
-#  include <stdarg.h>
-#  define HAVE_STDARG_H_HAVE_PROTO
-#else
-#  include <varargs.h>
-#endif
-
-/* undefine any macros for functions defined in this module */
-#undef	printw
-#undef	wprintw
-#undef	mvprintw
-#undef	mvwprintw
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef	waddstr
-#  undef	wmove
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_printw  = "$Id: printw.c,v 1.1 2001/01/10 08:27:24 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                        printw
-
-  Synopsis:
-  	int printw(char *fmt, ...);
-  	int wprintw(WINDOW *win, char *fmt, ...);
-  	int mvprintw(int y, int x, char *fmt, ...);
-  	int mvwprintw(WINDOW *win, int y, int x, char *fmt,...);
-  ***	int vwprintw(WINDOW *win, char *fmt, va_list varglist);
-
-  X/Open Description:
- 	The printw() routine adds a string to the default window
- 	starting at the current cursor position.  This routine causes
- 	the string that would normally be output by printf() to be
- 	output by addstr().
-
- 	The routine wprintw() adds a string to the specified window
- 	starting at the current cursor position.  This routine causes
- 	the string that would normally be output by printf() to be
- 	output by waddstr().
-
- 	The routine mvprintw() adds a string to the default window
- 	starting at the specified cursor position.  This routine
- 	causes the string that would normally be output by printf() to
- 	be output by addstr().
-
- 	The routine mvwprintw() adds a string to the specified window
- 	starting at the specified cursor position.  This routine
- 	causes the string that would normally be output by printf() to
- 	be output by waddstr().
-
- 	All these routines are analogous to printf().  It is advisable
- 	to use the field width options of printf() to avoid leaving
- 	unwanted characters on the screen from earlier calls.
-
-  PDCurses Description:
- 	The old Bjorn Larssen code for the 68K platform has been removed
- 	from this module.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      printw                                Y        Y       Y
-      wprintw                               Y        Y       Y
-      mvprintw                              Y        Y       Y
-      mvwprintw                             Y        Y       Y
-      vwprintw                              -        -      4.0
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_STDARG_H_HAVE_PROTO
-int	PDC_CDECL	printw(char *fmt,...)
-#else
-int	PDC_CDECL	printw(fmt,va_alist)
-char *fmt;
-va_dcl
-#endif
-/***********************************************************************/
-{
-	int	retval = ERR;
-	va_list args;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("printw() - called\n");
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return (retval);
-
-#ifdef HAVE_STDARG_H_HAVE_PROTO
-	va_start(args, fmt);
-#else
-	va_start(args);
-#endif
-
-	vsprintf(c_printscanbuf, fmt, args);
-	va_end(args);
-	if (waddstr(stdscr, c_printscanbuf) == ERR)
-		return (retval);
-	retval = (strlen(c_printscanbuf));
-	return (retval);
-}
-/***********************************************************************/
-#ifdef HAVE_STDARG_H_HAVE_PROTO
-int	PDC_CDECL	wprintw(WINDOW *win,char *fmt,...)
-#else
-int	PDC_CDECL	wprintw(win,fmt,va_alist)
-WINDOW *win;
-char *fmt;
-va_dcl
-#endif
-/***********************************************************************/
-{
-	int	retval = ERR;
-	va_list args;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wprintw() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return (retval);
-
-#ifdef HAVE_STDARG_H_HAVE_PROTO
-	va_start(args, fmt);
-#else
-	va_start(args);
-#endif
-
-	vsprintf(c_printscanbuf, fmt, args);
-	va_end(args);
-	if (waddstr(win, c_printscanbuf) == ERR)
-		return (retval);
-	retval = (strlen(c_printscanbuf));
-	return (retval);
-}
-/***********************************************************************/
-#ifdef HAVE_STDARG_H_HAVE_PROTO
-int	PDC_CDECL	mvprintw(int y, int x,char *fmt,...)
-#else
-int	PDC_CDECL	mvprintw(y,x,fmt,va_alist)
-int y,x;
-char *fmt;
-va_dcl
-#endif
-/***********************************************************************/
-{
-	int	retval = ERR;
-	va_list args;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvprintw() - called\n");
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return (retval);
-
-	if (wmove(stdscr, y, x) == ERR)
-		return( retval );
-
-#ifdef HAVE_STDARG_H_HAVE_PROTO
-	va_start(args, fmt);
-#else
-	va_start(args);
-#endif
-
-	vsprintf(c_printscanbuf, fmt, args);
-	va_end(args);
-
-	if (waddstr(stdscr, c_printscanbuf) == ERR)
-		return( retval );
-	retval = (strlen(c_printscanbuf));
-	return( retval );
-}
-/***********************************************************************/
-#ifdef HAVE_STDARG_H_HAVE_PROTO
-int	PDC_CDECL	mvwprintw(WINDOW *win,int y, int x,char *fmt,...)
-#else
-int	PDC_CDECL	mvwprintw(win,y,x,fmt,va_alist)
-WINDOW *win;
-int y,x;
-char *fmt;
-va_dcl
-#endif
-/***********************************************************************/
-{
-	int	retval = ERR;
-	va_list args;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvwprintw() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return (retval);
-	if (wmove(win, y, x) == ERR)
-		return( retval );
-
-#ifdef HAVE_STDARG_H_HAVE_PROTO
-	va_start(args, fmt);
-#else
-	va_start(args);
-#endif
-
-	vsprintf(c_printscanbuf, fmt, args);
-	va_end(args);
-
-	if (waddstr(win, c_printscanbuf) == ERR)
-		return (retval);
-	retval = (strlen(c_printscanbuf));
-	return (retval);
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+#include <string.h>
+
+#if defined(HAVE_STDARG_H) && defined(HAVE_PROTO)
+#  include <stdarg.h>
+#  define HAVE_STDARG_H_HAVE_PROTO
+#else
+#  include <varargs.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef	printw
+#undef	wprintw
+#undef	mvprintw
+#undef	mvwprintw
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	waddstr
+#  undef	wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_printw  = "$Id: printw.c,v 1.1 2001/01/10 08:27:24 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        printw
+
+  Synopsis:
+  	int printw(char *fmt, ...);
+  	int wprintw(WINDOW *win, char *fmt, ...);
+  	int mvprintw(int y, int x, char *fmt, ...);
+  	int mvwprintw(WINDOW *win, int y, int x, char *fmt,...);
+  ***	int vwprintw(WINDOW *win, char *fmt, va_list varglist);
+
+  X/Open Description:
+ 	The printw() routine adds a string to the default window
+ 	starting at the current cursor position.  This routine causes
+ 	the string that would normally be output by printf() to be
+ 	output by addstr().
+
+ 	The routine wprintw() adds a string to the specified window
+ 	starting at the current cursor position.  This routine causes
+ 	the string that would normally be output by printf() to be
+ 	output by waddstr().
+
+ 	The routine mvprintw() adds a string to the default window
+ 	starting at the specified cursor position.  This routine
+ 	causes the string that would normally be output by printf() to
+ 	be output by addstr().
+
+ 	The routine mvwprintw() adds a string to the specified window
+ 	starting at the specified cursor position.  This routine
+ 	causes the string that would normally be output by printf() to
+ 	be output by waddstr().
+
+ 	All these routines are analogous to printf().  It is advisable
+ 	to use the field width options of printf() to avoid leaving
+ 	unwanted characters on the screen from earlier calls.
+
+  PDCurses Description:
+ 	The old Bjorn Larssen code for the 68K platform has been removed
+ 	from this module.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      printw                                Y        Y       Y
+      wprintw                               Y        Y       Y
+      mvprintw                              Y        Y       Y
+      mvwprintw                             Y        Y       Y
+      vwprintw                              -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+int	PDC_CDECL	printw(char *fmt,...)
+#else
+int	PDC_CDECL	printw(fmt,va_alist)
+char *fmt;
+va_dcl
+#endif
+/***********************************************************************/
+{
+	int	retval = ERR;
+	va_list args;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("printw() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return (retval);
+
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+	va_start(args, fmt);
+#else
+	va_start(args);
+#endif
+
+	vsprintf(c_printscanbuf, fmt, args);
+	va_end(args);
+	if (waddstr(stdscr, c_printscanbuf) == ERR)
+		return (retval);
+	retval = (strlen(c_printscanbuf));
+	return (retval);
+}
+/***********************************************************************/
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+int	PDC_CDECL	wprintw(WINDOW *win,char *fmt,...)
+#else
+int	PDC_CDECL	wprintw(win,fmt,va_alist)
+WINDOW *win;
+char *fmt;
+va_dcl
+#endif
+/***********************************************************************/
+{
+	int	retval = ERR;
+	va_list args;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wprintw() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return (retval);
+
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+	va_start(args, fmt);
+#else
+	va_start(args);
+#endif
+
+	vsprintf(c_printscanbuf, fmt, args);
+	va_end(args);
+	if (waddstr(win, c_printscanbuf) == ERR)
+		return (retval);
+	retval = (strlen(c_printscanbuf));
+	return (retval);
+}
+/***********************************************************************/
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+int	PDC_CDECL	mvprintw(int y, int x,char *fmt,...)
+#else
+int	PDC_CDECL	mvprintw(y,x,fmt,va_alist)
+int y,x;
+char *fmt;
+va_dcl
+#endif
+/***********************************************************************/
+{
+	int	retval = ERR;
+	va_list args;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvprintw() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return (retval);
+
+	if (wmove(stdscr, y, x) == ERR)
+		return( retval );
+
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+	va_start(args, fmt);
+#else
+	va_start(args);
+#endif
+
+	vsprintf(c_printscanbuf, fmt, args);
+	va_end(args);
+
+	if (waddstr(stdscr, c_printscanbuf) == ERR)
+		return( retval );
+	retval = (strlen(c_printscanbuf));
+	return( retval );
+}
+/***********************************************************************/
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+int	PDC_CDECL	mvwprintw(WINDOW *win,int y, int x,char *fmt,...)
+#else
+int	PDC_CDECL	mvwprintw(win,y,x,fmt,va_alist)
+WINDOW *win;
+int y,x;
+char *fmt;
+va_dcl
+#endif
+/***********************************************************************/
+{
+	int	retval = ERR;
+	va_list args;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwprintw() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return (retval);
+	if (wmove(win, y, x) == ERR)
+		return( retval );
+
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+	va_start(args, fmt);
+#else
+	va_start(args);
+#endif
+
+	vsprintf(c_printscanbuf, fmt, args);
+	va_end(args);
+
+	if (waddstr(win, c_printscanbuf) == ERR)
+		return (retval);
+	retval = (strlen(c_printscanbuf));
+	return (retval);
+}
Index: PDCurses/pdcurses/pdcwin.c
===================================================================
--- PDCurses/pdcurses/pdcwin.c	(revision 1)
+++ PDCurses/pdcurses/pdcwin.c	(working copy)
@@ -1,1117 +1,1117 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define  CURSES_LIBRARY 1
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif
-#include <curses.h>
-
-#ifdef HAVE_MEMORY_H
-# include <memory.h>
-#endif
-
-#ifndef HAVE_MEMMOVE
-# define memmove PDC_memmove
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_PDCwin  = "$Id: pdcwin.c,v 1.2 2002/05/26 01:13:31 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  PDC_copy_win()  - Common routine for copywin(), overlay() and overwrite()
-    functions.
-
-  PDCurses Description:
-    This function copies the region of the source window specified
-    over the specified region of the destination window. All validation
-    of limits are done by the calling function.
-
-    Thanks to Andreas Otte (venn@uni-paderborn.de) for the code changes.
-
-  PDCurses Errors:
-    ERR is returned if either src or dst windows are NULL;
-
-  Portability:
-    PDCurses int   PDC_copy_win( WINDOW* src_w, WINDOW* dst_w
-         int src_tr,int src_tc,int src_br,int src_bc,
-         int dst_tr,int dst_tc,int dst_br,int dst_bc,bool overlay);
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_copy_win(WINDOW *src_w, WINDOW *dst_w,int src_tr,int src_tc,int 
-   src_br,int src_bc,int dst_tr,int dst_tc,int dst_br,int dst_bc,bool overlay)
-#else
-int PDC_copy_win(src_w,dst_w,src_tr,src_tc,src_br,src_bc,dst_tr,dst_tc,dst_br,dst_bc,overlay)
-WINDOW *src_w;
-WINDOW *dst_w;
-int src_tr;
-int src_tc;
-int src_br;
-int src_bc;
-int dst_tr;
-int dst_tc;
-int dst_br;
-int dst_bc;
-bool overlay;
-#endif
-/***********************************************************************/
-{
-   register int fc=0;
-   register int lc=0;
-   int*  minchng=0;
-   int*  maxchng=0;
-   chtype*  w1ptr=NULL;
-   chtype*  w2ptr=NULL;
-   int   col=0;
-   int   line=0;
-   int   xdiff = src_bc - src_tc;
-   int   ydiff = src_br - src_tr;
-   int   y1=0;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_copy_win() - called\n");
-#endif
-
-   if (src_w == (WINDOW *)NULL)  return( ERR );
-   if (dst_w == (WINDOW *)NULL)  return( ERR );
-
-   minchng = dst_w->_firstch;
-   maxchng = dst_w->_lastch;
-
-
-   for (y1 = 0; y1 < dst_tr; y1++)
-   {
-      minchng++;
-      maxchng++;
-   }
-
-   for (line = 0; line < ydiff; line++)
-   {
-
-      w1ptr = src_w->_y[line+src_tr]+src_tc;
-      w2ptr = dst_w->_y[line+dst_tr]+dst_tc;
-      fc    = _NO_CHANGE;
-
-      for (col = 0; col < xdiff; col++)
-      {
-         if ((*w1ptr) != (*w2ptr)
-         &&  !((*w1ptr & A_CHARTEXT) == src_w->_blank && overlay))
-         {
-            *w2ptr = *w1ptr;
-            if (fc == _NO_CHANGE)
-            {
-               fc = col+dst_tc;
-            }
-            lc = col+dst_tc;
-         }
-         w1ptr++;
-         w2ptr++;
-      }
-
-      if (*minchng == _NO_CHANGE)
-      {
-         *minchng = fc;
-         *maxchng = lc;
-      }
-      else  if (fc != _NO_CHANGE)
-      {
-         if (fc < *minchng)   *minchng = fc;
-         if (lc > *maxchng)   *maxchng = lc;
-      }
-      minchng++;
-      maxchng++;
-   }
-   return( OK );
-}
-
-/*man-start*********************************************************************
-
-  PDC_makenew()   - Create a WINDOW* (sans line allocation)
-
-  PDCurses Description:
-    This is a private PDCurses routine.
-
-    Allocates all data for a new WINDOW* except the actual lines
-    themselves.
-
-  PDCurses Return Value:
-    This function returns a valid WINDOW* on success and NULL on error.
-
-  PDCurses Errors:
-    If PDC_makenew() is unable to allocate memory for the window
-    structure, it will free all allocated memory and return
-    a NULL pointer.
-
-  Portability:
-    PDCurses WINDOW* PDC_makenew( int num_lines, int num_columns,
-                int begy, int begx );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-WINDOW* PDC_makenew(int num_lines, int num_columns, int begy, int begx)
-#else
-WINDOW* PDC_makenew(num_lines,num_columns,begy,begx)
-int num_lines;
-int num_columns;
-int begy;
-int begx;
-#endif
-/***********************************************************************/
-{
-#ifdef HAVE_PROTO
-extern   void* (*mallc)( size_t );
-extern   void* (*callc)( size_t, size_t );
-extern   void  (*fre)( void* );
-#else
-extern   void* (*mallc)();
-extern   void* (*callc)();
-extern   void  (*fre)();
-#endif
-
-   short i=0;
-   WINDOW *win=NULL;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_makenew() - called: lines %d cols %d begy %d begx %d\n",num_lines,num_columns,begy,begx);
-#endif
-
-   /*
-   *  Use the standard runtime malloc/calloc package or use
-   *  the user's emalloc/ecalloc package.
-   *
-   *  Allocate the window structure itself
-   */
-   if ((win = (*mallc)(sizeof(WINDOW))) == (WINDOW *)NULL)
-   {
-      return( win );
-   }
-
-   /*
-   * allocate the line pointer array
-   */
-   if ((win->_y = (*callc)(num_lines, sizeof(chtype *))) == NULL)
-   {
-      (*fre)(win);
-      return( (WINDOW *)NULL );
-   }
-
-   /*
-   * allocate the minchng and maxchng arrays
-   */
-   if ((win->_firstch = (*callc)(num_lines, sizeof(int))) == NULL)
-   {
-      (*fre)(win->_y);
-      (*fre)(win);
-      return( (WINDOW *)NULL );
-   }
-   if ((win->_lastch = (*callc)(num_lines, sizeof(int))) == NULL)
-   {
-      (*fre)(win->_firstch);
-      (*fre)(win->_y);
-      (*fre)(win);
-      return( (WINDOW *)NULL );
-   }
-
-   /*
-   * initialize window variables
-   */
-   win->_curx = 0;
-   win->_cury = 0;
-   win->_maxy = num_lines;    /* real max screen size */
-   win->_maxx = num_columns;  /* real max screen size */
-   win->_pmaxy = num_lines;   /* real max window size */
-   win->_pmaxx = num_columns; /* real max window size */
-   win->_begy = begy;
-   win->_begx = begx;
-   win->_lastpy = 0;
-   win->_lastpx = 0;
-   win->_lastsy1 = 0;
-   win->_lastsx1 = 0;
-   win->_lastsy2 = LINES-1;
-   win->_lastsx2 = COLS-1;
-   win->_flags = 0;
-   win->_attrs = 0;     /* No attributes */
-   win->_bkgd = ' '; /* wrs 4/10/93 -- initialize background to blank */
-   win->_tabsize = 8;
-   win->_clear = (bool) ((num_lines == LINES) && (num_columns == COLS));
-   win->_leaveit = FALSE;
-   win->_scroll = FALSE;
-   win->_nodelay = FALSE;
-   win->_immed = FALSE;
-   win->_sync = FALSE;
-   win->_use_keypad = FALSE;
-   win->_use_idl = FALSE;
-   win->_use_idc = TRUE;
-   win->_tmarg = 0;
-   win->_bmarg = num_lines - 1;
-   win->_title = NULL;
-   win->_title_ofs = 1;
-   win->_title_attr = win->_attrs;
-   win->_blank = ' ';
-   win->_parx = win->_pary = -1;
-   win->_parent = NULL;
-   /*
-   * init to say window unchanged
-   */
-   for (i = 0; i < num_lines; i++)
-   {
-      win->_firstch[i] = 0;
-      win->_lastch[i] = num_columns - 1;
-   }
-
-   /*
-   * set flags for window properties
-   */
-   if ((begy + num_lines) == LINES)
-   {
-      win->_flags |= _ENDLINE;
-      if ((begx == 0) &&
-          (num_columns == COLS) &&
-          (begy == 0))
-      {
-         win->_flags |= _FULLWIN;
-      }
-   }
-
-   if (((begy + num_lines) == LINES) &&
-       ((begx + num_columns) == COLS))
-   {
-      win->_flags |= _SCROLLWIN;
-   }
-   return( win );
-}
-
-/*man-start*********************************************************************
-
-  PDC_sync()   - Cause window synchronisation to occur
-
-  PDCurses Description:
-    This is a private PDCurses routine, NOT to be called by an application.
-
-    Handles wrefresh() and wsyncup() calls when a window is changed.
-
-  PDCurses Return Value:
-    This function returns void.
-
-  PDCurses Errors:
-
-  Portability:
-    PDCurses WINDOW* PDC_sync( WINDOW *win );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-void PDC_sync(WINDOW *win)
-#else
-void PDC_sync(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_sync() - called:\n");
-#endif
-
-   if (win->_immed) 
-      wrefresh(win);
-   if (win->_sync) 
-      wsyncup(win);
-   return;
-}
-
-/*man-start*********************************************************************
-
-  PDC_backchar()  - Visually erase character in window
-
-  PDCurses Description:
-    This is a private PDCurses function
-
-    This routine will visually erase a character.  It is called by
-    the PDCurses character I/O routines.
-
-  PDCurses Return Value:
-    This routine will return OK upon success and otherwise ERR will be
-    returned.
-
-  PDCurses Errors:
-    It is an error to pass a NULL WINDOW pointer.
-
-  Portability:
-    PDCurses int   PDC_backchar( WINDOW* w, char* ch, int* len );
-
-**man-end**********************************************************************/
-
-#ifdef THESE_FUNCTIONS_ARENT_USED
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_backchar(WINDOW *w, char *ch, int *len)
-#else
-int PDC_backchar(w,ch,len)
-WINDOW *w;
-char *ch;
-int *len;
-#endif
-/***********************************************************************/
-{
-   int   nbs = 0;
-   int   x = w->_curx;
-   int   ts = w->_tabsize;
-   chtype   s = (w->_y[w->_cury][x - 1] & CHR_MSK);
-   char* p = c_strbeg;
-   bool  save_raw_out = SP->raw_out;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_backchar() - called\n");
-#endif
-
-   if (w == (WINDOW *)NULL)
-      return( ERR );
-
-   (*len)--;      /* Now we are zero relative */
-   (*len)--;      /* Now we are looking at the previous
-             * character */
-   if( *len >= 0 ) 
-   {
-      nbs++;
-      /*
-       * Determine number of characters to erase...
-       */
-      if ((ch[*len] < ' ') || (s == 0x7f))   /* ctrl-char has size 2  */
-      {
-         nbs++;
-         (*len)--;
-      }
-
-      if( *len >= 0 )
-      {
-         if (ch[*len] == '\t')   /* tabs are very special */
-         {
-            for (; p < ch; p++)
-            {
-               if (*p == '\t')
-                  x = ((x / ts) + 1) * ts;
-               else
-               {
-                  if ((*p < ' ') || (*p == 0x7f))
-                     x += 2;
-                  else
-                     x++;
-               }
-               if (x >= w->_maxx)   /* go to next line? */
-                  x = 0;
-            }
-            if (!(w->_curx))
-               nbs = w->_maxx - x;
-            else
-               nbs = w->_curx - x;
-         }
-      }
-   }
-   if( *len < 0 )
-   {
-      beep();
-      *len = 0;
-   }
-   /*
-    * Erase the characters and update...
-    */
-   SP->raw_out = FALSE;  /* ensure backspace handled in xlat mode */
-   while ( nbs-- > 0 )
-   {
-      if (w->_curx > 0)
-      {
-/*       waddstr(w, "\b \b");*/
-         mvwaddch(w, w->_cury, w->_curx-1, ' ');
-         wmove(w, w->_cury, w->_curx-1);
-      }
-      else
-      if (w->_cury)
-      {
-         mvwaddch(w, w->_cury - 1, w->_maxx - 1, ' ');
-         wmove(w, w->_cury - 1, w->_maxx - 1);
-      }
-   }
-   ch[*len] = '\0';
-   SP->raw_out = save_raw_out;
-   wrefresh(w);
-   return( OK );
-}
-
-/*man-start*********************************************************************
-
-  PDC_chg_attr_pair()   - Writes character and attribute to physical screen
-
-  PDCurses Description:
-    This is a private PDCurses function.
-
-    Writes a single character 'chr' with attribute 'attr' to the
-    current cursor location.
-
-    NOTE: Though passed as 16 bit quantities, only the lower 8 bits
-      will be used to create a character/attribute pair.
-
-  PDCurses Return Value:
-    This function returns OK on success and ERR on error.
-
-  PDCurses Errors:
-    No errors are defined for this function under DOS.
-
-    An ERR may be returned under FLEXOS if s_copy() fails.  See the
-    Flexos Programmer's Reference Manual for details on the error.
-
-  Portability:
-    PDCurses int PDC_chg_attr_pair( chtype chr, chtype attr );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_chg_attr_pair(chtype chr, chtype attr)
-#else
-int PDC_chg_attr_pair(chr,attr)
-chtype chr;
-chtype attr;
-#endif
-/***********************************************************************/
-{
-   extern unsigned   char atrtab[MAX_ATRTAB];
-   int   phys_attr=chtype_attr(attr);
-
-#ifdef   OS2
-# ifdef  EMXVIDEO
-   int curCol, curRow,cell;
-# else
-   USHORT curCol, curRow, cell;
-# endif
-#endif
-
-#ifdef   FLEXOS
-   UBYTE c = (UBYTE) chr;
-   UBYTE a = (UBYTE) phys_attr;
-#endif
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_chg_attr_pair() - called\n");
-#endif
-
-#ifdef   FLEXOS
-   drect.r_row = PDC_get_cur_row();
-   drect.r_col = PDC_get_cur_col();
-   drect.r_nrow = 1;
-   drect.r_ncol = 1;
-
-   sframe.fr_pl[0] = (UBYTE *) & c;
-   sframe.fr_pl[1] = (UBYTE *) & a;
-   sframe.fr_pl[2] = (UBYTE *) " ";
-   sframe.fr_nrow = 1;
-   sframe.fr_ncol = 1;
-   sframe.fr_use = 0x00;
-
-   srect.r_col = 0;
-   srect.r_row = 0;
-   srect.r_nrow = 1;
-   srect.r_ncol = 1;
-
-   retcode = s_copy(0x03, 0x01L, 0L, (far unsigned short *) &drect, (far unsigned short *) &sframe, (far unsigned short *) &srect);
-   return( (retcode < 0L) ? ERR : OK );
-#endif
-
-#ifdef   DOS
-   regs.h.ah = 0x09;
-   regs.h.al = chr & A_CHARTEXT;
-   regs.h.bh = SP->video_page;
-   regs.h.bl = (char)(phys_attr >> 8);
-# ifdef WATCOMC
-   regs.w.cx = 0x01;
-# else
-   regs.x.cx = 0x01;
-# endif
-   int86(0x10, &regs, &regs);
-   return( OK );
-#endif
-
-#ifdef   OS2
-   /* find the current cursor position */
-# ifdef EMXVIDEO
-   cell = (int)((chr & A_CHARTEXT) | phys_attr);
-   v_getxy (&curCol, &curRow);
-   v_putline ((char*)&cell, curCol, curRow, 1);
-# else
-   cell = (USHORT)((chr & A_CHARTEXT) | phys_attr);
-   VioGetCurPos((PUSHORT) &curRow, (PUSHORT) &curCol, 0);
-   VioWrtNCell((PBYTE)&cell,1,curRow,curCol,0);
-# endif
-   return( OK );
-#endif
-
-#ifdef UNIX
-/* INCOMPLETE - check attribute and output attr and/or color */
-   putchar(chr & A_CHARTEXT);
-   return(OK);
-#endif
-}
-#endif
-
-/*man-start*********************************************************************
-
-  PDC_chadd()      - Low level; Put a character to a window
-
-  PDCurses Description:
-    This is a private PDCurses function.
-
-    This routine will insert the character 'c' at the current cursor
-    position in the passed window.
-
-    If 'xlat' is TRUE, PDC_chadd() will handle things in a cooked
-    manner (tabs, newlines, carriage returns, etc).  If 'xlat' is
-    FALSE, the characters are simply output directly.
-
-    If 'advance' is TRUE, PDC_chadd() will move the current cusor position
-    appropriately. The *addch functions call PDC_chadd() with advance TRUE,
-    while the *insch functions call PDC_chadd() with advance FALSE.
-
-    The normal curses routines (non-raw-output-mode) call PDC_chadd()
-    with 'xlat' TRUE.
-
-    If an alternate character is to be displayed, the character is
-    displayed without translation (minus the A_ALTCHARSET of course).
-
-  PDCurses Return Value:
-    This function returns OK on success and ERR on error.
-
-  PDCurses Errors:
-    It is an error to call this function with a NULL window pointer.
-
-  Portability:
-    PDCurses        int PDC_chadd( WINDOW* win, chtype ch, bool xlat, bool advance );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_CDECL PDC_chadd(register WINDOW *win, chtype ch,bool xlat, bool advance)
-#else
-int PDC_CDECL PDC_chadd(win,ch,xlat,advance)
-register WINDOW *win;
-chtype ch;
-bool xlat;
-bool advance;
-#endif
-/***********************************************************************/
-{
-   int   retval = ERR;
-   int   x=0;
-   int   y=0;
-   int   newx=0;
-   chtype   attr=0, bktmp=0;
-   int   ts=0;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_chadd() - called: win=%x ch=%x (char=%c attr=0x%x) xlat=%d advance=%d\n",win,ch,ch & A_CHARTEXT,ch & A_ATTRIBUTES,xlat,advance);
-#endif
-
-   if (win  == (WINDOW *)NULL)
-      return(  retval );
-
-   x  = win->_curx;
-   y  = win->_cury;
-   ts = win->_tabsize;
-
-   /* 
-    * Remove any A_ALTCHASET attribute from the ch before any further
-    * testing. If the character has A_ALTCHARSET, set xlat to FALSE.
-    */
-   if (ch & A_ALTCHARSET)
-   {
-      xlat = FALSE;
-      ch = ch & (~A_ALTCHARSET);
-   }
-   /*
-    * if the incoming character doesn't have its own attribute
-    * then  use the  current  attributes for the window.
-    * if the incoming character has attributes but not a colour
-    * component, or the attributes  to the current attributes
-    * for the window.
-    * if the incoming character has a colour component use  the
-    * attributes solely from the incoming character
-    */
-
-   if ((ch  & A_ATTRIBUTES)   == 0)
-      attr  = win->_attrs;
-   else
-   {
-      if ((ch & A_COLOR) == 0)
-         attr = (ch & A_ATTRIBUTES) | win->_attrs;
-      else
-         attr = (ch & A_ATTRIBUTES);
-   }
-
-   ch = (ch &  A_CHARTEXT);
-
-   /*  wrs (4/10/93) */
-   /*  apply the same sort of logic for the window background, in that it only */
-   /*  takes precedence if other color attributes are not there and that */
-   /*  the background character will only print if the printing character is */
-   /*  blank. */
-
-   if ((attr & A_COLOR) == 0)
-      attr = (attr | (win->_bkgd & A_ATTRIBUTES));
-   else 
-   {
-      bktmp = (win->_bkgd & A_COLOR);
-      attr = (attr | ( (win->_bkgd & A_ATTRIBUTES) ^ bktmp ));
-   }
-
-   if ( ch == ' ' )
-      ch = ((win->_bkgd & A_CHARTEXT));
-
-
-   if ((y > win->_maxy) ||
-       (x > win->_maxx) ||
-       (y < 0) ||
-       (x < 0))
-   {
-      return(  retval );
-   }
-
-   if (xlat)
-   {
-      switch (ch) 
-      {
-         case '\t':
-            for (newx = ((x   / ts) +  1) * ts; x < newx; x++)
-            {
-               if (waddch(win,   ' ') ==  ERR)
-               {
-                  PDC_sync(win);
-                  return(  retval );
-               }
-               /*
-                * if tab to next line
-                */
-               if (win->_curx == 0)
-               {
-                  /*
-                   * exit  the loop
-                   */
-                  PDC_sync(win);
-                  return(  OK );
-               }
-            }
-            PDC_sync(win);
-            return(  OK );
-
-         case '\n':
-            if (SP->autocr && !(SP->raw_out))
-            {
-               /*
-                * if lf -> crlf
-                */
-               x = 0;
-            }
-            wclrtoeol( win );
-            if ((y = PDC_newline(win, y)) < 0)
-            {
-               PDC_sync(win);
-               return(  retval );
-            }
-            if (advance)
-            {
-               win->_cury =   y;
-               win->_curx =   x;
-            }
-            PDC_sync(win);
-            return(  OK );
-
-         case '\r':
-            if (advance)
-               win->_curx =   x = 0;
-            PDC_sync(win);
-            return(  OK );
-
-         case '\b':
-            if (--x  < 0)
-            {
-               /*
-                * no back over   left margin
-                */
-               x = 0;
-            }
-            if (advance)
-               win->_curx =   x;
-            PDC_sync(win);
-            return(  OK );
-
-         case 0x7f:
-            if (waddch(win,   '^') ==  ERR)
-            {
-               PDC_sync(win);
-               return(  retval );
-            }
-            retval = waddch(win, '?');
-            PDC_sync(win);
-            return(  retval );
-
-         default:
-            break;
-      }     /* switch */
-
-      if (ch < ' ')
-      {
-         /*
-          * handle control chars
-          */
-         if (waddch(win,   '^') ==  ERR)
-         {
-            PDC_sync(win);
-            return(  retval );
-         }
-
-         retval = (waddch(win, ch + '@'));
-         PDC_sync(win);
-         return(  retval );
-      }
-   }
-
-   /*
-    * Add the  attribute back into the character.
-    */
-   ch |= attr;
-   /*********************************************************************/
-   /* only change _firstch/_lastch if character to be added is different */
-   /* to the character/attribute that is already in that position in the */
-   /* window.                                                            */
-   /* Removing this fixes display problems with different windows in the */
-   /* same physical position. MH 20-03-93                                */
-   /* Restored again.         MH 02-04-93                                */
-   /*********************************************************************/
-   if (win->_y[y][x] != ch)
-   {
-      /*
-       * only  if data  change
-       */
-      if (win->_firstch[y] == _NO_CHANGE)
-      {
-         win->_firstch[y] = win->_lastch[y] = x;
-      }
-      else
-      {
-         if (x <  win->_firstch[y])
-         {
-            win->_firstch[y] = x;
-         }
-         else
-         {
-            if (x >  win->_lastch[y])
-            {
-               win->_lastch[y] = x;
-            }
-         }
-      }
-   }
-   win->_y[y][x++] = ch;
-   if (x >= win->_maxx)
-   {
-      /*
-       * wrap  around test
-       */
-      x = 0;
-      if ((y = PDC_newline(win, y)) < 0)
-      {
-         PDC_sync(win);
-         return(  retval );
-      }
-   }
-   if (advance)
-   {
-      win->_curx =   x;
-      win->_cury =   y;
-   }
-   PDC_sync(win);
-   return(  OK );
-}
-
-/*man-start*********************************************************************
-
-  PDC_chg_attrs() - Change attributes in a rectangle
-
-  PDCurses Description:
-    This routine will change the attribute(s) from a starting (y,x)
-    position to an ending (y,x) position to the specified attribute.
-
-  PDCurses Return Value:
-    This function returns OK on success and ERR on error.
-
-  PDCurses Errors:
-    It is an error to call this function with a NULL window pointer.
-    It is also an error to pass rectangular coordinates that lay
-    outside of window.
-
-  Portability:
-    PDCurses int PDC_chg_attrs( WINDOW* w, chtype attr,
-               int sy, int sx,
-               int ey, int ex );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_chg_attrs(WINDOW *win, chtype attr, int sy, int sx, int ey, int ex)
-#else
-int PDC_chg_attrs(win,attr,sy,sx,ey,ex)
-WINDOW *win;
-chtype attr;
-int sy;
-int sx;
-int ey;
-int ex;
-#endif
-/***********************************************************************/
-{
-   chtype   oldattr = win->_attrs;
-   int   c=0;
-   int   l=0;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_chr_attrs() - called\n");
-#endif
-
-   if (win == (WINDOW *)NULL)    return( ERR );
-   if (sy > win->_maxy) return( ERR );
-   if (sx > win->_maxx) return( ERR );
-   if (ey >= win->_maxy)   ey = win->_maxy - 1;
-   if (ex >= win->_maxx)   ex = win->_maxx - 1;
-
-   wattrset(win, attr);
-   for (l = sy; l <= ey; l++)
-   {
-      for (c = sx; c <= ex; c++)
-         win->_y[l][c] = (win->_y[l][c] & A_CHARTEXT) | attr;
-
-      if (win->_firstch[l] == _NO_CHANGE)
-      {
-         win->_firstch[l] = sx;
-         win->_lastch[l] = ex;
-      }
-      else if (win->_firstch[l] != _NO_CHANGE)
-      {
-         if (sx < win->_firstch[l])
-            win->_firstch[l] = sx;
-         if (ex > win->_lastch[l])
-            win->_lastch[l] = ex;
-      }
-   }
-   win->_attrs = oldattr;
-   PDC_sync(win);
-   return( OK );
-}
-
-/*man-start*********************************************************************
-
-  PDC_chins()  - Low-level insert character in window
-
-  PDCurses Description:
-    This is a private PDCurses routine.
-
-    This routine provides the basic functionality for the X/Open
-    [mv][w]insch() routines.  The xlat flag indicates that normal
-    character translation is performed or not.  If not, then the
-    character is output as is.
-
-    The 'xlat' flag is TRUE for the normal curses routines.
-
-  PDCurses Return Value:
-    This function returns OK on success and ERR on error.
-
-  PDCurses Errors:
-    It is an error to call this function with a NULL window pointer.
-
-  Portability:
-    PDCurses int PDC_chins( WINDOW* win, chtype c, bool xlat );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_chins(WINDOW *win, chtype c, bool xlat)
-#else
-int PDC_chins(win,c,xlat)
-WINDOW *win;
-chtype c;
-bool xlat;
-#endif
-/***********************************************************************/
-{
-   int   retval = ERR;
-   int   x=0;
-   int   y=0;
-   int   maxx=0;
-   int   offset=0;
-   chtype *temp1;
-   char  ch = (c & A_CHARTEXT);
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_chins() - called: win=%x ch=%x (char=%c attr=0x%x) xlat=%d\n",win,ch,ch & A_CHARTEXT,ch & A_ATTRIBUTES,xlat);
-#endif
-
-   if (win == (WINDOW *)NULL)
-      return( retval );
-
-   x  = win->_curx;
-   y  = win->_cury;
-   maxx  = win->_maxx;
-   offset   = 1;
-   temp1 = &win->_y[y][x];
-
-   if ((ch < ' ') && xlat)
-   {
-      offset++;
-   }
-
-   memmove( temp1+offset, temp1, (maxx - x -offset) * sizeof(chtype) );
-
-   win->_lastch[y] = maxx-1;
-
-   if ((win->_firstch[y] == _NO_CHANGE) ||
-       (win->_firstch[y] > x))
-   {
-      win->_firstch[y] = x;
-   }
-   /*
-    * PDC_chadd() fixes CTRL-chars too
-    */
-   retval = (PDC_chadd(win, c, xlat,FALSE));
-   return( retval );
-}
-
-/*man-start*********************************************************************
-
-  PDC_clr_scrn()  - Clears the physical screen and homes the cursor.
-
-  PDCurses Description:
-    This is an internal routine called by the doupdate() routines.
-
-  PDCurses Return Value:
-    This routine always returns OK.
-
-  Portability:
-    PDCurses int PDC_clr_scrn( WINDOW* win );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_clr_scrn(WINDOW *win)
-#else
-int PDC_clr_scrn(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-#if !defined(XCURSES)
-# if defined(UNIX_WCLR)
-   chtype   attrs = win->_attrs;
-# else
-   chtype   attrs = win->_bkgd;
-# endif
-#endif
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_clr_scrn() - called\n");
-#endif
-
-#if defined(XCURSES)
-   XCursesInstruct(CURSES_CLEAR);
-#else
-   PDC_scroll(0, 0, LINES - 1, COLS - 1, 0, attrs);
-   PDC_gotoxy(0, 0);
-#endif
-
-   return( OK );
-}
-
-/*man-start*********************************************************************
-
-  PDC_newline()   - Advances 1 newline from supplied line number.
-
-  PDCurses Description:
-    This is a private PDCurses routine.
-
-    Does line advance and returns the new cursor line.  If error,
-    return -1.
-
-  PDCurses Return Value:
-    This function returns OK on success and ERR on error.
-
-  PDCurses Errors:
-    No errors are defined for this function.
-
-  Portability:
-    PDCurses int PDC_newline( WINDOW* win, int lin );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_newline(WINDOW *win, int lin)
-#else
-int PDC_newline(win,lin)
-WINDOW *win;
-int lin;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_newline() - called: line %d\n",lin);
-#endif
-
-   if (win == (WINDOW *)NULL)
-      return( -1 );
-
-   if (++lin > win->_bmarg)
-   {
-      lin--;
-      if (win->_scroll)
-      {
-         scroll(win);
-
-         /* wrs -- 7/11/93 ** it seems that System V Curses automatically refreshes
-          *                   a window when scrolling occurs via a newline.  This
-          *                   could be a feature that isn't intended, but I'll
-          *                   implement it here as well for consistency.
-          * fh -- 7/30/99 ** but it causes problems with panels -- a lower panel
-          *                  might be refreshed without updating the obscuring
-          *                  parts of other panels.
-          */
-         /*         wrefresh(win); */
-      }
-      else
-         return( -1 );
-   }
-   return( lin );
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define  CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef HAVE_MEMORY_H
+# include <memory.h>
+#endif
+
+#ifndef HAVE_MEMMOVE
+# define memmove PDC_memmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_PDCwin  = "$Id: pdcwin.c,v 1.2 2002/05/26 01:13:31 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_copy_win()  - Common routine for copywin(), overlay() and overwrite()
+    functions.
+
+  PDCurses Description:
+    This function copies the region of the source window specified
+    over the specified region of the destination window. All validation
+    of limits are done by the calling function.
+
+    Thanks to Andreas Otte (venn@uni-paderborn.de) for the code changes.
+
+  PDCurses Errors:
+    ERR is returned if either src or dst windows are NULL;
+
+  Portability:
+    PDCurses int   PDC_copy_win( WINDOW* src_w, WINDOW* dst_w
+         int src_tr,int src_tc,int src_br,int src_bc,
+         int dst_tr,int dst_tc,int dst_br,int dst_bc,bool overlay);
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_copy_win(WINDOW *src_w, WINDOW *dst_w,int src_tr,int src_tc,int 
+   src_br,int src_bc,int dst_tr,int dst_tc,int dst_br,int dst_bc,bool overlay)
+#else
+int PDC_copy_win(src_w,dst_w,src_tr,src_tc,src_br,src_bc,dst_tr,dst_tc,dst_br,dst_bc,overlay)
+WINDOW *src_w;
+WINDOW *dst_w;
+int src_tr;
+int src_tc;
+int src_br;
+int src_bc;
+int dst_tr;
+int dst_tc;
+int dst_br;
+int dst_bc;
+bool overlay;
+#endif
+/***********************************************************************/
+{
+   register int fc=0;
+   register int lc=0;
+   int*  minchng=0;
+   int*  maxchng=0;
+   chtype*  w1ptr=NULL;
+   chtype*  w2ptr=NULL;
+   int   col=0;
+   int   line=0;
+   int   xdiff = src_bc - src_tc;
+   int   ydiff = src_br - src_tr;
+   int   y1=0;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_copy_win() - called\n");
+#endif
+
+   if (src_w == (WINDOW *)NULL)  return( ERR );
+   if (dst_w == (WINDOW *)NULL)  return( ERR );
+
+   minchng = dst_w->_firstch;
+   maxchng = dst_w->_lastch;
+
+
+   for (y1 = 0; y1 < dst_tr; y1++)
+   {
+      minchng++;
+      maxchng++;
+   }
+
+   for (line = 0; line < ydiff; line++)
+   {
+
+      w1ptr = src_w->_y[line+src_tr]+src_tc;
+      w2ptr = dst_w->_y[line+dst_tr]+dst_tc;
+      fc    = _NO_CHANGE;
+
+      for (col = 0; col < xdiff; col++)
+      {
+         if ((*w1ptr) != (*w2ptr)
+         &&  !((*w1ptr & A_CHARTEXT) == src_w->_blank && overlay))
+         {
+            *w2ptr = *w1ptr;
+            if (fc == _NO_CHANGE)
+            {
+               fc = col+dst_tc;
+            }
+            lc = col+dst_tc;
+         }
+         w1ptr++;
+         w2ptr++;
+      }
+
+      if (*minchng == _NO_CHANGE)
+      {
+         *minchng = fc;
+         *maxchng = lc;
+      }
+      else  if (fc != _NO_CHANGE)
+      {
+         if (fc < *minchng)   *minchng = fc;
+         if (lc > *maxchng)   *maxchng = lc;
+      }
+      minchng++;
+      maxchng++;
+   }
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_makenew()   - Create a WINDOW* (sans line allocation)
+
+  PDCurses Description:
+    This is a private PDCurses routine.
+
+    Allocates all data for a new WINDOW* except the actual lines
+    themselves.
+
+  PDCurses Return Value:
+    This function returns a valid WINDOW* on success and NULL on error.
+
+  PDCurses Errors:
+    If PDC_makenew() is unable to allocate memory for the window
+    structure, it will free all allocated memory and return
+    a NULL pointer.
+
+  Portability:
+    PDCurses WINDOW* PDC_makenew( int num_lines, int num_columns,
+                int begy, int begx );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW* PDC_makenew(int num_lines, int num_columns, int begy, int begx)
+#else
+WINDOW* PDC_makenew(num_lines,num_columns,begy,begx)
+int num_lines;
+int num_columns;
+int begy;
+int begx;
+#endif
+/***********************************************************************/
+{
+#ifdef HAVE_PROTO
+extern   void* (*mallc)( size_t );
+extern   void* (*callc)( size_t, size_t );
+extern   void  (*fre)( void* );
+#else
+extern   void* (*mallc)();
+extern   void* (*callc)();
+extern   void  (*fre)();
+#endif
+
+   short i=0;
+   WINDOW *win=NULL;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_makenew() - called: lines %d cols %d begy %d begx %d\n",num_lines,num_columns,begy,begx);
+#endif
+
+   /*
+   *  Use the standard runtime malloc/calloc package or use
+   *  the user's emalloc/ecalloc package.
+   *
+   *  Allocate the window structure itself
+   */
+   if ((win = (*mallc)(sizeof(WINDOW))) == (WINDOW *)NULL)
+   {
+      return( win );
+   }
+
+   /*
+   * allocate the line pointer array
+   */
+   if ((win->_y = (*callc)(num_lines, sizeof(chtype *))) == NULL)
+   {
+      (*fre)(win);
+      return( (WINDOW *)NULL );
+   }
+
+   /*
+   * allocate the minchng and maxchng arrays
+   */
+   if ((win->_firstch = (*callc)(num_lines, sizeof(int))) == NULL)
+   {
+      (*fre)(win->_y);
+      (*fre)(win);
+      return( (WINDOW *)NULL );
+   }
+   if ((win->_lastch = (*callc)(num_lines, sizeof(int))) == NULL)
+   {
+      (*fre)(win->_firstch);
+      (*fre)(win->_y);
+      (*fre)(win);
+      return( (WINDOW *)NULL );
+   }
+
+   /*
+   * initialize window variables
+   */
+   win->_curx = 0;
+   win->_cury = 0;
+   win->_maxy = num_lines;    /* real max screen size */
+   win->_maxx = num_columns;  /* real max screen size */
+   win->_pmaxy = num_lines;   /* real max window size */
+   win->_pmaxx = num_columns; /* real max window size */
+   win->_begy = begy;
+   win->_begx = begx;
+   win->_lastpy = 0;
+   win->_lastpx = 0;
+   win->_lastsy1 = 0;
+   win->_lastsx1 = 0;
+   win->_lastsy2 = LINES-1;
+   win->_lastsx2 = COLS-1;
+   win->_flags = 0;
+   win->_attrs = 0;     /* No attributes */
+   win->_bkgd = ' '; /* wrs 4/10/93 -- initialize background to blank */
+   win->_tabsize = 8;
+   win->_clear = (bool) ((num_lines == LINES) && (num_columns == COLS));
+   win->_leaveit = FALSE;
+   win->_scroll = FALSE;
+   win->_nodelay = FALSE;
+   win->_immed = FALSE;
+   win->_sync = FALSE;
+   win->_use_keypad = FALSE;
+   win->_use_idl = FALSE;
+   win->_use_idc = TRUE;
+   win->_tmarg = 0;
+   win->_bmarg = num_lines - 1;
+   win->_title = NULL;
+   win->_title_ofs = 1;
+   win->_title_attr = win->_attrs;
+   win->_blank = ' ';
+   win->_parx = win->_pary = -1;
+   win->_parent = NULL;
+   /*
+   * init to say window unchanged
+   */
+   for (i = 0; i < num_lines; i++)
+   {
+      win->_firstch[i] = 0;
+      win->_lastch[i] = num_columns - 1;
+   }
+
+   /*
+   * set flags for window properties
+   */
+   if ((begy + num_lines) == LINES)
+   {
+      win->_flags |= _ENDLINE;
+      if ((begx == 0) &&
+          (num_columns == COLS) &&
+          (begy == 0))
+      {
+         win->_flags |= _FULLWIN;
+      }
+   }
+
+   if (((begy + num_lines) == LINES) &&
+       ((begx + num_columns) == COLS))
+   {
+      win->_flags |= _SCROLLWIN;
+   }
+   return( win );
+}
+
+/*man-start*********************************************************************
+
+  PDC_sync()   - Cause window synchronisation to occur
+
+  PDCurses Description:
+    This is a private PDCurses routine, NOT to be called by an application.
+
+    Handles wrefresh() and wsyncup() calls when a window is changed.
+
+  PDCurses Return Value:
+    This function returns void.
+
+  PDCurses Errors:
+
+  Portability:
+    PDCurses WINDOW* PDC_sync( WINDOW *win );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void PDC_sync(WINDOW *win)
+#else
+void PDC_sync(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_sync() - called:\n");
+#endif
+
+   if (win->_immed) 
+      wrefresh(win);
+   if (win->_sync) 
+      wsyncup(win);
+   return;
+}
+
+/*man-start*********************************************************************
+
+  PDC_backchar()  - Visually erase character in window
+
+  PDCurses Description:
+    This is a private PDCurses function
+
+    This routine will visually erase a character.  It is called by
+    the PDCurses character I/O routines.
+
+  PDCurses Return Value:
+    This routine will return OK upon success and otherwise ERR will be
+    returned.
+
+  PDCurses Errors:
+    It is an error to pass a NULL WINDOW pointer.
+
+  Portability:
+    PDCurses int   PDC_backchar( WINDOW* w, char* ch, int* len );
+
+**man-end**********************************************************************/
+
+#ifdef THESE_FUNCTIONS_ARENT_USED
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_backchar(WINDOW *w, char *ch, int *len)
+#else
+int PDC_backchar(w,ch,len)
+WINDOW *w;
+char *ch;
+int *len;
+#endif
+/***********************************************************************/
+{
+   int   nbs = 0;
+   int   x = w->_curx;
+   int   ts = w->_tabsize;
+   chtype   s = (w->_y[w->_cury][x - 1] & CHR_MSK);
+   char* p = c_strbeg;
+   bool  save_raw_out = PDC_SP->raw_out;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_backchar() - called\n");
+#endif
+
+   if (w == (WINDOW *)NULL)
+      return( ERR );
+
+   (*len)--;      /* Now we are zero relative */
+   (*len)--;      /* Now we are looking at the previous
+             * character */
+   if( *len >= 0 ) 
+   {
+      nbs++;
+      /*
+       * Determine number of characters to erase...
+       */
+      if ((ch[*len] < ' ') || (s == 0x7f))   /* ctrl-char has size 2  */
+      {
+         nbs++;
+         (*len)--;
+      }
+
+      if( *len >= 0 )
+      {
+         if (ch[*len] == '\t')   /* tabs are very special */
+         {
+            for (; p < ch; p++)
+            {
+               if (*p == '\t')
+                  x = ((x / ts) + 1) * ts;
+               else
+               {
+                  if ((*p < ' ') || (*p == 0x7f))
+                     x += 2;
+                  else
+                     x++;
+               }
+               if (x >= w->_maxx)   /* go to next line? */
+                  x = 0;
+            }
+            if (!(w->_curx))
+               nbs = w->_maxx - x;
+            else
+               nbs = w->_curx - x;
+         }
+      }
+   }
+   if( *len < 0 )
+   {
+      beep();
+      *len = 0;
+   }
+   /*
+    * Erase the characters and update...
+    */
+   PDC_SP->raw_out = FALSE;  /* ensure backspace handled in xlat mode */
+   while ( nbs-- > 0 )
+   {
+      if (w->_curx > 0)
+      {
+/*       waddstr(w, "\b \b");*/
+         mvwaddch(w, w->_cury, w->_curx-1, ' ');
+         wmove(w, w->_cury, w->_curx-1);
+      }
+      else
+      if (w->_cury)
+      {
+         mvwaddch(w, w->_cury - 1, w->_maxx - 1, ' ');
+         wmove(w, w->_cury - 1, w->_maxx - 1);
+      }
+   }
+   ch[*len] = '\0';
+   PDC_SP->raw_out = save_raw_out;
+   wrefresh(w);
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_chg_attr_pair()   - Writes character and attribute to physical screen
+
+  PDCurses Description:
+    This is a private PDCurses function.
+
+    Writes a single character 'chr' with attribute 'attr' to the
+    current cursor location.
+
+    NOTE: Though passed as 16 bit quantities, only the lower 8 bits
+      will be used to create a character/attribute pair.
+
+  PDCurses Return Value:
+    This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+    No errors are defined for this function under DOS.
+
+    An ERR may be returned under FLEXOS if s_copy() fails.  See the
+    Flexos Programmer's Reference Manual for details on the error.
+
+  Portability:
+    PDCurses int PDC_chg_attr_pair( chtype chr, chtype attr );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_chg_attr_pair(chtype chr, chtype attr)
+#else
+int PDC_chg_attr_pair(chr,attr)
+chtype chr;
+chtype attr;
+#endif
+/***********************************************************************/
+{
+   extern unsigned   char atrtab[MAX_ATRTAB];
+   int   phys_attr=chtype_attr(attr);
+
+#ifdef   OS2
+# ifdef  EMXVIDEO
+   int curCol, curRow,cell;
+# else
+   USHORT curCol, curRow, cell;
+# endif
+#endif
+
+#ifdef   FLEXOS
+   UBYTE c = (UBYTE) chr;
+   UBYTE a = (UBYTE) phys_attr;
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_chg_attr_pair() - called\n");
+#endif
+
+#ifdef   FLEXOS
+   drect.r_row = PDC_get_cur_row();
+   drect.r_col = PDC_get_cur_col();
+   drect.r_nrow = 1;
+   drect.r_ncol = 1;
+
+   sframe.fr_pl[0] = (UBYTE *) & c;
+   sframe.fr_pl[1] = (UBYTE *) & a;
+   sframe.fr_pl[2] = (UBYTE *) " ";
+   sframe.fr_nrow = 1;
+   sframe.fr_ncol = 1;
+   sframe.fr_use = 0x00;
+
+   srect.r_col = 0;
+   srect.r_row = 0;
+   srect.r_nrow = 1;
+   srect.r_ncol = 1;
+
+   retcode = s_copy(0x03, 0x01L, 0L, (far unsigned short *) &drect, (far unsigned short *) &sframe, (far unsigned short *) &srect);
+   return( (retcode < 0L) ? ERR : OK );
+#endif
+
+#ifdef   DOS
+   regs.h.ah = 0x09;
+   regs.h.al = chr & A_CHARTEXT;
+   regs.h.bh = PDC_SP->video_page;
+   regs.h.bl = (char)(phys_attr >> 8);
+# ifdef WATCOMC
+   regs.w.cx = 0x01;
+# else
+   regs.x.cx = 0x01;
+# endif
+   int86(0x10, &regs, &regs);
+   return( OK );
+#endif
+
+#ifdef   OS2
+   /* find the current cursor position */
+# ifdef EMXVIDEO
+   cell = (int)((chr & A_CHARTEXT) | phys_attr);
+   v_getxy (&curCol, &curRow);
+   v_putline ((char*)&cell, curCol, curRow, 1);
+# else
+   cell = (USHORT)((chr & A_CHARTEXT) | phys_attr);
+   VioGetCurPos((PUSHORT) &curRow, (PUSHORT) &curCol, 0);
+   VioWrtNCell((PBYTE)&cell,1,curRow,curCol,0);
+# endif
+   return( OK );
+#endif
+
+#ifdef UNIX
+/* INCOMPLETE - check attribute and output attr and/or color */
+   putchar(chr & A_CHARTEXT);
+   return(OK);
+#endif
+}
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_chadd()      - Low level; Put a character to a window
+
+  PDCurses Description:
+    This is a private PDCurses function.
+
+    This routine will insert the character 'c' at the current cursor
+    position in the passed window.
+
+    If 'xlat' is TRUE, PDC_chadd() will handle things in a cooked
+    manner (tabs, newlines, carriage returns, etc).  If 'xlat' is
+    FALSE, the characters are simply output directly.
+
+    If 'advance' is TRUE, PDC_chadd() will move the current cusor position
+    appropriately. The *addch functions call PDC_chadd() with advance TRUE,
+    while the *insch functions call PDC_chadd() with advance FALSE.
+
+    The normal curses routines (non-raw-output-mode) call PDC_chadd()
+    with 'xlat' TRUE.
+
+    If an alternate character is to be displayed, the character is
+    displayed without translation (minus the A_ALTCHARSET of course).
+
+  PDCurses Return Value:
+    This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+    It is an error to call this function with a NULL window pointer.
+
+  Portability:
+    PDCurses        int PDC_chadd( WINDOW* win, chtype ch, bool xlat, bool advance );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL PDC_chadd(register WINDOW *win, chtype ch,bool xlat, bool advance)
+#else
+int PDC_CDECL PDC_chadd(win,ch,xlat,advance)
+register WINDOW *win;
+chtype ch;
+bool xlat;
+bool advance;
+#endif
+/***********************************************************************/
+{
+   int   retval = ERR;
+   int   x=0;
+   int   y=0;
+   int   newx=0;
+   chtype   attr=0, bktmp=0;
+   int   ts=0;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_chadd() - called: win=%x ch=%x (char=%c attr=0x%x) xlat=%d advance=%d\n",win,ch,ch & A_CHARTEXT,ch & A_ATTRIBUTES,xlat,advance);
+#endif
+
+   if (win  == (WINDOW *)NULL)
+      return(  retval );
+
+   x  = win->_curx;
+   y  = win->_cury;
+   ts = win->_tabsize;
+
+   /* 
+    * Remove any A_ALTCHASET attribute from the ch before any further
+    * testing. If the character has A_ALTCHARSET, set xlat to FALSE.
+    */
+   if (ch & A_ALTCHARSET)
+   {
+      xlat = FALSE;
+      ch = ch & (~A_ALTCHARSET);
+   }
+   /*
+    * if the incoming character doesn't have its own attribute
+    * then  use the  current  attributes for the window.
+    * if the incoming character has attributes but not a colour
+    * component, or the attributes  to the current attributes
+    * for the window.
+    * if the incoming character has a colour component use  the
+    * attributes solely from the incoming character
+    */
+
+   if ((ch  & A_ATTRIBUTES)   == 0)
+      attr  = win->_attrs;
+   else
+   {
+      if ((ch & A_COLOR) == 0)
+         attr = (ch & A_ATTRIBUTES) | win->_attrs;
+      else
+         attr = (ch & A_ATTRIBUTES);
+   }
+
+   ch = (ch &  A_CHARTEXT);
+
+   /*  wrs (4/10/93) */
+   /*  apply the same sort of logic for the window background, in that it only */
+   /*  takes precedence if other color attributes are not there and that */
+   /*  the background character will only print if the printing character is */
+   /*  blank. */
+
+   if ((attr & A_COLOR) == 0)
+      attr = (attr | (win->_bkgd & A_ATTRIBUTES));
+   else 
+   {
+      bktmp = (win->_bkgd & A_COLOR);
+      attr = (attr | ( (win->_bkgd & A_ATTRIBUTES) ^ bktmp ));
+   }
+
+   if ( ch == ' ' )
+      ch = ((win->_bkgd & A_CHARTEXT));
+
+
+   if ((y > win->_maxy) ||
+       (x > win->_maxx) ||
+       (y < 0) ||
+       (x < 0))
+   {
+      return(  retval );
+   }
+
+   if (xlat)
+   {
+      switch (ch) 
+      {
+         case '\t':
+            for (newx = ((x   / ts) +  1) * ts; x < newx; x++)
+            {
+               if (waddch(win,   ' ') ==  ERR)
+               {
+                  PDC_sync(win);
+                  return(  retval );
+               }
+               /*
+                * if tab to next line
+                */
+               if (win->_curx == 0)
+               {
+                  /*
+                   * exit  the loop
+                   */
+                  PDC_sync(win);
+                  return(  OK );
+               }
+            }
+            PDC_sync(win);
+            return(  OK );
+
+         case '\n':
+            if (PDC_SP->autocr && !(PDC_SP->raw_out))
+            {
+               /*
+                * if lf -> crlf
+                */
+               x = 0;
+            }
+            wclrtoeol( win );
+            if ((y = PDC_newline(win, y)) < 0)
+            {
+               PDC_sync(win);
+               return(  retval );
+            }
+            if (advance)
+            {
+               win->_cury =   y;
+               win->_curx =   x;
+            }
+            PDC_sync(win);
+            return(  OK );
+
+         case '\r':
+            if (advance)
+               win->_curx =   x = 0;
+            PDC_sync(win);
+            return(  OK );
+
+         case '\b':
+            if (--x  < 0)
+            {
+               /*
+                * no back over   left margin
+                */
+               x = 0;
+            }
+            if (advance)
+               win->_curx =   x;
+            PDC_sync(win);
+            return(  OK );
+
+         case 0x7f:
+            if (waddch(win,   '^') ==  ERR)
+            {
+               PDC_sync(win);
+               return(  retval );
+            }
+            retval = waddch(win, '?');
+            PDC_sync(win);
+            return(  retval );
+
+         default:
+            break;
+      }     /* switch */
+
+      if (ch < ' ')
+      {
+         /*
+          * handle control chars
+          */
+         if (waddch(win,   '^') ==  ERR)
+         {
+            PDC_sync(win);
+            return(  retval );
+         }
+
+         retval = (waddch(win, ch + '@'));
+         PDC_sync(win);
+         return(  retval );
+      }
+   }
+
+   /*
+    * Add the  attribute back into the character.
+    */
+   ch |= attr;
+   /*********************************************************************/
+   /* only change _firstch/_lastch if character to be added is different */
+   /* to the character/attribute that is already in that position in the */
+   /* window.                                                            */
+   /* Removing this fixes display problems with different windows in the */
+   /* same physical position. MH 20-03-93                                */
+   /* Restored again.         MH 02-04-93                                */
+   /*********************************************************************/
+   if (win->_y[y][x] != ch)
+   {
+      /*
+       * only  if data  change
+       */
+      if (win->_firstch[y] == _NO_CHANGE)
+      {
+         win->_firstch[y] = win->_lastch[y] = x;
+      }
+      else
+      {
+         if (x <  win->_firstch[y])
+         {
+            win->_firstch[y] = x;
+         }
+         else
+         {
+            if (x >  win->_lastch[y])
+            {
+               win->_lastch[y] = x;
+            }
+         }
+      }
+   }
+   win->_y[y][x++] = ch;
+   if (x >= win->_maxx)
+   {
+      /*
+       * wrap  around test
+       */
+      x = 0;
+      if ((y = PDC_newline(win, y)) < 0)
+      {
+         PDC_sync(win);
+         return(  retval );
+      }
+   }
+   if (advance)
+   {
+      win->_curx =   x;
+      win->_cury =   y;
+   }
+   PDC_sync(win);
+   return(  OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_chg_attrs() - Change attributes in a rectangle
+
+  PDCurses Description:
+    This routine will change the attribute(s) from a starting (y,x)
+    position to an ending (y,x) position to the specified attribute.
+
+  PDCurses Return Value:
+    This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+    It is an error to call this function with a NULL window pointer.
+    It is also an error to pass rectangular coordinates that lay
+    outside of window.
+
+  Portability:
+    PDCurses int PDC_chg_attrs( WINDOW* w, chtype attr,
+               int sy, int sx,
+               int ey, int ex );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_chg_attrs(WINDOW *win, chtype attr, int sy, int sx, int ey, int ex)
+#else
+int PDC_chg_attrs(win,attr,sy,sx,ey,ex)
+WINDOW *win;
+chtype attr;
+int sy;
+int sx;
+int ey;
+int ex;
+#endif
+/***********************************************************************/
+{
+   chtype   oldattr = win->_attrs;
+   int   c=0;
+   int   l=0;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_chr_attrs() - called\n");
+#endif
+
+   if (win == (WINDOW *)NULL)    return( ERR );
+   if (sy > win->_maxy) return( ERR );
+   if (sx > win->_maxx) return( ERR );
+   if (ey >= win->_maxy)   ey = win->_maxy - 1;
+   if (ex >= win->_maxx)   ex = win->_maxx - 1;
+
+   wattrset(win, attr);
+   for (l = sy; l <= ey; l++)
+   {
+      for (c = sx; c <= ex; c++)
+         win->_y[l][c] = (win->_y[l][c] & A_CHARTEXT) | attr;
+
+      if (win->_firstch[l] == _NO_CHANGE)
+      {
+         win->_firstch[l] = sx;
+         win->_lastch[l] = ex;
+      }
+      else if (win->_firstch[l] != _NO_CHANGE)
+      {
+         if (sx < win->_firstch[l])
+            win->_firstch[l] = sx;
+         if (ex > win->_lastch[l])
+            win->_lastch[l] = ex;
+      }
+   }
+   win->_attrs = oldattr;
+   PDC_sync(win);
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_chins()  - Low-level insert character in window
+
+  PDCurses Description:
+    This is a private PDCurses routine.
+
+    This routine provides the basic functionality for the X/Open
+    [mv][w]insch() routines.  The xlat flag indicates that normal
+    character translation is performed or not.  If not, then the
+    character is output as is.
+
+    The 'xlat' flag is TRUE for the normal curses routines.
+
+  PDCurses Return Value:
+    This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+    It is an error to call this function with a NULL window pointer.
+
+  Portability:
+    PDCurses int PDC_chins( WINDOW* win, chtype c, bool xlat );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_chins(WINDOW *win, chtype c, bool xlat)
+#else
+int PDC_chins(win,c,xlat)
+WINDOW *win;
+chtype c;
+bool xlat;
+#endif
+/***********************************************************************/
+{
+   int   retval = ERR;
+   int   x=0;
+   int   y=0;
+   int   maxx=0;
+   int   offset=0;
+   chtype *temp1;
+   char  ch = (c & A_CHARTEXT);
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_chins() - called: win=%x ch=%x (char=%c attr=0x%x) xlat=%d\n",win,ch,ch & A_CHARTEXT,ch & A_ATTRIBUTES,xlat);
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( retval );
+
+   x  = win->_curx;
+   y  = win->_cury;
+   maxx  = win->_maxx;
+   offset   = 1;
+   temp1 = &win->_y[y][x];
+
+   if ((ch < ' ') && xlat)
+   {
+      offset++;
+   }
+
+   memmove( temp1+offset, temp1, (maxx - x -offset) * sizeof(chtype) );
+
+   win->_lastch[y] = maxx-1;
+
+   if ((win->_firstch[y] == _NO_CHANGE) ||
+       (win->_firstch[y] > x))
+   {
+      win->_firstch[y] = x;
+   }
+   /*
+    * PDC_chadd() fixes CTRL-chars too
+    */
+   retval = (PDC_chadd(win, c, xlat,FALSE));
+   return( retval );
+}
+
+/*man-start*********************************************************************
+
+  PDC_clr_scrn()  - Clears the physical screen and homes the cursor.
+
+  PDCurses Description:
+    This is an internal routine called by the doupdate() routines.
+
+  PDCurses Return Value:
+    This routine always returns OK.
+
+  Portability:
+    PDCurses int PDC_clr_scrn( WINDOW* win );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_clr_scrn(WINDOW *win)
+#else
+int PDC_clr_scrn(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#if !defined(XCURSES)
+# if defined(UNIX_WCLR)
+   chtype   attrs = win->_attrs;
+# else
+   chtype   attrs = win->_bkgd;
+# endif
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_clr_scrn() - called\n");
+#endif
+
+#if defined(XCURSES)
+   XCursesInstruct(CURSES_CLEAR);
+#else
+   PDC_scroll(0, 0, LINES - 1, COLS - 1, 0, attrs);
+   PDC_gotoxy(0, 0);
+#endif
+
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_newline()   - Advances 1 newline from supplied line number.
+
+  PDCurses Description:
+    This is a private PDCurses routine.
+
+    Does line advance and returns the new cursor line.  If error,
+    return -1.
+
+  PDCurses Return Value:
+    This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+    No errors are defined for this function.
+
+  Portability:
+    PDCurses int PDC_newline( WINDOW* win, int lin );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_newline(WINDOW *win, int lin)
+#else
+int PDC_newline(win,lin)
+WINDOW *win;
+int lin;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_newline() - called: line %d\n",lin);
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( -1 );
+
+   if (++lin > win->_bmarg)
+   {
+      lin--;
+      if (win->_scroll)
+      {
+         scroll(win);
+
+         /* wrs -- 7/11/93 ** it seems that System V Curses automatically refreshes
+          *                   a window when scrolling occurs via a newline.  This
+          *                   could be a feature that isn't intended, but I'll
+          *                   implement it here as well for consistency.
+          * fh -- 7/30/99 ** but it causes problems with panels -- a lower panel
+          *                  might be refreshed without updating the obscuring
+          *                  parts of other panels.
+          */
+         /*         wrefresh(win); */
+      }
+      else
+         return( -1 );
+   }
+   return( lin );
+}
Index: PDCurses/pdcurses/slk.c
===================================================================
--- PDCurses/pdcurses/slk.c	(revision 1)
+++ PDCurses/pdcurses/slk.c	(working copy)
@@ -1,760 +1,760 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-#include <string.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	slk_init
-#undef	slk_set
-#undef	slk_refresh
-#undef	slk_noutrefresh
-#undef	slk_label
-#undef	slk_clear
-#undef	slk_restore
-#undef	slk_touch
-#undef	slk_attron
-#undef	slk_attrset
-#undef	slk_attroff
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_slk  = "$Id: slk.c,v 1.1 2001/01/10 08:27:29 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                          slk
-
-  Synopsis:
-
-  	int slk_init(int fmt);
-  	int slk_set(int labnum, char *label, int fmt);
-  	int slk_refresh(void);
-  	int slk_noutrefresh(void);
-  	char *slk_label(int labnum);
-  	int slk_clear(void);
-  	int slk_restore(void);
-  	int slk_touch(void);
-  	int slk_attron(attr_t attrs);
-  	int slk_attrset(attr_t attrs);
-  	int slk_attroff(attr_t attrs);
-
-  X/Open Description:
- 	These functions manipulate a window that contain Soft Label Keys (SLK).
- 	TO use the SLK functions, a call to slk_init() must be made BEFORE
- 	initscr() or newterm(). slk_init() removes 1 or 2 lines from the
- 	useable screen, depending on the format selected.
-
- 	The line(s) removed from the screen are used as a separate window, in
- 	which SLKs are displayed.
-
- 	slk_init() requires a single parameter which describes the format of
- 	the SLKs as follows:
- 
- 		1	3-2-3 format
- 		2	4-4 format
- 		3	4-4-4 format (ncurses extension)
- 		4	4-4-4 format with index line (ncurses extension) 2 lines used
- 		55	5-5 format (pdcurses format)
-
- 	The functions slk_refresh(), slk_noutrefresh() and slk_touch() are
- 	analagous to refresh(), noutrefresh() and touch() functions.
-
-  PDCurses Description:
- 	System V compatible color support is included.
- 	See <curses.h> for further details.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	It is an error to call this function with a NULL window pointer.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      slk_init                              Y        -       Y
-      slk_set                               Y        -       Y
-      slk_refresh                           Y        -       Y
-      slk_noutrefresh                       Y        -       Y
-      slk_label                             Y        -       Y
-      slk_clear                             Y        -       Y
-      slk_restore                           Y        -       Y
-      slk_touch                             Y        -       Y
-      slk_attron                            Y        -       Y
-      slk_attrset                           Y        -       Y
-      slk_attroff
-
-**man-end**********************************************************************/
-
-
-#define LABEL_NORMAL	8
-#define LABEL_EXTENDED	10
-#define LABEL_NCURSES_EXTENDED	12
-
-static int slk_start_col[LABEL_NCURSES_EXTENDED];
-static chtype slk_attributes[LABEL_NCURSES_EXTENDED];
-char slk_temp_string[64];
-static int space_seperator=1;
-static int label_length=0;
-static int labels=0;
-static int label_fmt=0;
-static int label_line=0;
-
-#ifdef HAVE_PROTO
-void (*PDC_initial_slk)(void);
-static void PDC_slk_init(void);
-#else
-void (*PDC_initial_slk)();
-static void PDC_slk_init();
-#endif
-
-static struct {
-	char	label[32];
-	int	format;		
-} slk_save[ LABEL_NCURSES_EXTENDED ];
-
-
-/***********************************************************************/
-/*
-   slk_init()	is the slk initialization routine.
-   This must be called before initscr().
-
-   label_fmt = 0, 1 or 55.
-       0 = 3-2-3 format
-       1 = 4 - 4 format
-       2 = 4-4-4 format	(ncurses extension for PC 12 function keys)
-       3 = 4-4-4 format	(ncurses extension for PC 12 function keys - with index line)
-      55 = 5 - 5 format	(extended for PC, 10 function keys)
-
- */
-#ifdef HAVE_PROTO
-int PDC_CDECL slk_init(int fmt)
-#else
-int PDC_CDECL slk_init(fmt)
-int fmt;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
- if (trace_on) PDC_debug("slk_init() - called\n");
-#endif
-
- if (SP)
-   return (ERR);
-
- switch (fmt) 
- {
-    case 0:  /* 3 - 2 - 3 */
-       labels = LABEL_NORMAL;
-       break;
-
-    case 1:   /* 4 - 4 */
-       labels = LABEL_NORMAL;
-       break;
-
-    case 2:   /* 4 4 4 */
-       labels = LABEL_NCURSES_EXTENDED;
-       break;
-
-    case 3:   /* 4 4 4  with index */
-       labels = LABEL_NCURSES_EXTENDED;
-       break;
-
-    case 55:  /* 5 - 5 */
-       labels = LABEL_EXTENDED;
-       break;
-
-    default:
-       return (ERR);
- } /* end switch */
-
- PDC_initial_slk = PDC_slk_init;
- label_fmt = fmt;
- return(OK);
-}
-
-
-
-
-/***********************************************************************/
-/*
- PDC_slk_set() Used to set a slk label to a string.
-
-   label_num = 1 - 8 (or 10) (number of the label)
-   label_str = string (8 or 7 bytes total), NULL chars or NULL pointer
-   label_fmt =  justification
-      0 = left
-      1 = center
-      2 = right
-   save = 1 yes or 0 no
- */
-#ifdef HAVE_PROTO
-static int PDC_slk_set(int label_num, char *label_str, int label_fmt, int save)
-#else
-static int PDC_slk_set(label_num, label_str, label_fmt, save)
-int label_num;
-char *label_str;
-int label_fmt;
-int save;
-#endif
-/***********************************************************************/
-{
-register int i, num;
-int slen;
-int llen;
-int col;
-
-#ifdef PDCDEBUG
- if (trace_on) PDC_debug("PDC_slk_set() - called\n");
-#endif
-
- if (label_num < 1 
- || label_num > labels 
- || label_fmt < 0 
- || label_fmt > 2)
-    return (ERR);
-
-
-/*
-    A NULL in either the first byte or pointer
-    indicates a clearing of the label.
-*/
- num = label_num - 1;
-
- if (label_str == (char *)0 || *label_str == '\0') 
- {
-    slk_attributes[num] = SP->slk_winptr->_attrs;
-    wmove(SP->slk_winptr, label_line, slk_start_col[num]);
-
-    for (i = 0; i < label_length; ++i)
-       PDC_chadd( SP->slk_winptr, ' ', (bool)(!(SP->raw_out)), TRUE );
-
-    /* Save the string and attribute */
-    if (save)
-    {
-       *slk_save[num].label = '\0';
-       slk_save[num].format = 0;
-    }
-    wmove(SP->slk_winptr, label_line, 0);   /* park it */
-
-    return (OK);
- }
-
- /* Otherwise, format the character and put in position. */
- memset(slk_temp_string, 0, sizeof (slk_temp_string));
- strncpy(slk_temp_string, label_str, label_length);
-
- /* Save the string and attribute */
- if (save)
- {
-    strcpy(slk_save[num].label, slk_temp_string);
-    slk_save[num].format = label_fmt;
- }
-
- slk_attributes[num] = SP->slk_winptr->_attrs;
- wmove(SP->slk_winptr, label_line, slk_start_col[num]);
-
- for (i = 0; i < label_length; ++i)
-    PDC_chadd( SP->slk_winptr, ' ', (bool)(!(SP->raw_out)), TRUE );
-
- wmove(SP->slk_winptr, label_line, slk_start_col[num]);
-
- switch (label_fmt)
- {
-    case 0:  /* LEFT */
-       waddstr(SP->slk_winptr, slk_temp_string);
-       break;
-         
-    case 1:  /* CENTER */
-       slen = strlen(slk_temp_string);
-       col = slen / 2;
-       llen = label_length / 2;
-       col = llen - col;
-       if (col + slen > label_length)
-          --col;
-       mvwaddstr(SP->slk_winptr, label_line, slk_start_col[num] + col, slk_temp_string);
-       break;
-
-    default:  /* RIGHT */
-       slen = strlen(slk_temp_string);
-       col = label_length - slen;
-       mvwaddstr(SP->slk_winptr, label_line, slk_start_col[num] + col, slk_temp_string);
-       break;
- }
-
- wmove(SP->slk_winptr, label_line, 0);	/* park it */
-
- return( OK );
-}
-
-
-/***********************************************************************/
-/*
- slk_set() Used to set a slk label to a string.
-
-   label_num = 1 - 8 (or 10) (number of the label)
-   label_str = string (8 or 7 bytes total), NULL chars or NULL pointer
-   label_fmt =  justification
-      0 = left
-      1 = center
-      2 = right
- */
-#ifdef HAVE_PROTO
-int PDC_CDECL slk_set(int label_num, char *label_str, int label_fmt)
-#else
-int PDC_CDECL slk_set(label_num, label_str, label_fmt)
-int label_num;
-char *label_str;
-int label_fmt;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
- if (trace_on) PDC_debug("slk_set() - called\n");
-#endif
-
- return( PDC_slk_set( label_num, label_str, label_fmt, 1 ) );
-}
-
-
-
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	slk_refresh(void)
-#else
-int	PDC_CDECL	slk_refresh()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
- if (trace_on) PDC_debug("slk_refresh() - called\n");
-#endif
-
- if (SP->slk_winptr == (WINDOW *)NULL)
-    return (ERR);
-
- slk_noutrefresh();
- return (doupdate());
-
-}
-
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	slk_noutrefresh(void)
-#else
-int	PDC_CDECL	slk_noutrefresh()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
- if (trace_on) PDC_debug("slk_noutrefresh() - called\n");
-#endif
-
- if (SP->slk_winptr == (WINDOW *)NULL)
-    return (ERR);
-
- return (wnoutrefresh(SP->slk_winptr));
-}
-
-
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-char*	PDC_CDECL	slk_label(int labnum)
-#else
-char*	PDC_CDECL	slk_label(labnum)
-int labnum;   /* 1 - 8 (or 10) */
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
- if (trace_on) PDC_debug("slk_label() - called\n");
-#endif
-
- if (labnum < 0 || labnum > labels)
-    return ((char *)0);
-
- memset(slk_temp_string, 0, sizeof (slk_temp_string));
- strcpy(slk_temp_string, slk_save[labnum - 1].label);
-
- return (slk_temp_string);	/* only good temporarily */
-
-}
-
-
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	slk_clear(void)
-#else
-int	PDC_CDECL	slk_clear()
-#endif
-/***********************************************************************/
-{
- register int i;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("slk_clear() - called\n");
-#endif
-
- for (i = 0; i < labels; ++i)
- {
-    wattrset(SP->slk_winptr, slk_attributes[i]);
-    PDC_slk_set( i + 1, "", 0, 0 );
- }
- return wrefresh(SP->slk_winptr);
-}
-
-
-
-
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	slk_restore(void)
-#else
-int	PDC_CDECL	slk_restore()
-#endif
-/***********************************************************************/
-{
- register int i;
- chtype attr=SP->slk_winptr->_attrs;
-
-#ifdef PDCDEBUG
- if (trace_on) PDC_debug("slk_restore() - called\n");
-#endif
-
- for (i = 0; i < labels; ++i)
- {
-    wattrset(SP->slk_winptr, slk_attributes[i]);
-    PDC_slk_set(i + 1, slk_save[i].label, slk_save[i].format, 0);
- }
-
- SP->slk_winptr->_attrs = attr;
-
- return wrefresh(SP->slk_winptr);
-}
-
-
-
-
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	slk_touch(void)
-#else
-int	PDC_CDECL	slk_touch()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
- if (trace_on) PDC_debug("slk_touch() - called\n");
-#endif
-
- return touchwin(SP->slk_winptr);
-}
-
-
-
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	slk_attron(attr_t attrs)
-#else
-int	PDC_CDECL	slk_attron(attrs)
-attr_t attrs;
-#endif
-/***********************************************************************/
-{
- int i,rc;
-#ifdef PDCDEBUG
- if (trace_on) PDC_debug("slk_attron() - called\n");
-#endif
- rc = wattron(SP->slk_winptr, attrs);
- for (i = 0; i < labels; ++i)
- {
-    PDC_slk_set(i + 1, slk_save[i].label, slk_save[i].format, 0);
- }
- return rc;
-}
-
-
-
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	slk_attroff(attr_t attrs)
-#else
-int	PDC_CDECL	slk_attroff(attrs)
-attr_t attrs;
-#endif
-/***********************************************************************/
-{
- int i,rc;
-#ifdef PDCDEBUG
- if (trace_on) PDC_debug("slk_attroff() - called\n");
-#endif
- rc = wattroff(SP->slk_winptr, attrs);
- for (i = 0; i < labels; ++i)
- {
-    PDC_slk_set(i + 1, slk_save[i].label, slk_save[i].format, 0);
- }
- return rc;
-}
-
-
-
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	slk_attrset(attr_t attrs)
-#else
-int	PDC_CDECL	slk_attrset(attrs)
-attr_t attrs;
-#endif
-/***********************************************************************/
-{
- int i,rc;
-#ifdef PDCDEBUG
- if (trace_on) PDC_debug("slk_attrset() - called\n");
-#endif
-
- rc = wattrset(SP->slk_winptr, attrs);
- for (i = 0; i < labels; ++i)
- {
-    PDC_slk_set(i + 1, slk_save[i].label, slk_save[i].format, 0);
- }
-
- return rc;
-
-}
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-static void	PDC_slk_init(void)
-#else
-static void	PDC_slk_init()
-#endif
-/***********************************************************************/
-{
- register int i=0;
- attr_t save_attr;
-#ifdef PDCDEBUG
- if (trace_on) PDC_debug("PDC_slk_init() - called\n");
-#endif
-
-/*
- * Don't set this to NULL as resize_term() calls it.
- PDC_initial_slk = NULL;
- */
-      
- if ( label_fmt == 3 )
- {
-    SP->slklines = 2;
-    label_line = 1;
- }
- else
-    SP->slklines = 1;
-
- if (!SP->slk_winptr)
- {
-    if ((SP->slk_winptr = newwin(SP->slklines, COLS, LINES-SP->slklines, 0)) == (WINDOW *)0)
-       return;
-    wattrset(SP->slk_winptr,A_REVERSE);
- }
- PDC_slk_calc();
- /* if we have an index line, display it now */
- if ( label_fmt == 3 )
- {
-    save_attr = SP->slk_winptr->_attrs;
-    wattrset(SP->slk_winptr,A_NORMAL);
-    wmove( SP->slk_winptr, 0, 0 );
-    whline( SP->slk_winptr, 0, COLS );
-    for ( i = 0; i < labels; i++ )
-    {
-       mvwprintw( SP->slk_winptr, 0, slk_start_col[i], "F%d", i+1 );
-    }
-    SP->slk_winptr->_attrs = save_attr;
- }
- touchwin(SP->slk_winptr);
-}
-
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-void	PDC_slk_calc(void)
-#else
-void	PDC_slk_calc()
-#endif
-/***********************************************************************/
-{
- register int i=0;
- register int col=0, center=0;
-
-#ifdef PDCDEBUG
- if (trace_on) PDC_debug("PDC_slk_calc() - called\n");
-#endif
-
- switch (label_fmt) 
- {
-    case 0:  /* 3 - 2 - 3 */
-       label_length = ( COLS / labels ) - space_seperator - 1;
-       break;
-
-    case 1:   /* 4 - 4 */
-       label_length = ( COLS / labels ) - space_seperator;
-       break;
-
-    case 2:   /* 4 4 4 */
-    case 3:   /* 4 4 4 with index */
-       label_length = ( COLS / labels ) - space_seperator;
-       break;
-
-    case 55:  /* 5 - 5 */
-       label_length = ( COLS / labels ) - space_seperator;
-       break;
-
-    default: /* should never get here!! */
-       return;
- } /* end switch */
-
-
- /* set default attribute */
- for (i = 0; i < labels; ++i)
- {
-    slk_attributes[i] = A_REVERSE;
- }
-
- switch (label_fmt) {
-    case 0:     /* 3 - 2 - 3 F-Key layout */
-       slk_start_col[0] = col;
-       slk_start_col[1] = (col += label_length + space_seperator);
-       slk_start_col[2] = (col += label_length + space_seperator);
-
-       center = COLS/2;
-       slk_start_col[3] = center - label_length;
-       slk_start_col[4] = center + space_seperator;
-
-       col = COLS - ((label_length + space_seperator) * 2 + label_length);
-       slk_start_col[5] = col;
-       slk_start_col[6] = (col += label_length + space_seperator);
-       slk_start_col[7] = (col += label_length + space_seperator);
-       break;
-
-    case 1:     /* 4 - 4 F-Key layout */
-       slk_start_col[0] = col;
-       slk_start_col[1] = (col += label_length + space_seperator);
-       slk_start_col[2] = (col += label_length + space_seperator);
-       slk_start_col[3] = (col += label_length + space_seperator);
-
-       col = COLS - ((label_length + space_seperator) * 3 + label_length);
-       slk_start_col[4] = col;
-       slk_start_col[5] = (col += label_length + space_seperator);
-       slk_start_col[6] = (col += label_length + space_seperator);
-       slk_start_col[7] = (col += label_length + space_seperator);
-       break;
-
-    case 2:     /* 4 4 4 F-Key layout */
-    case 3:     /* 4 4 4 F-Key layout with index */
-       slk_start_col[0] = col;
-       slk_start_col[1] = (col += label_length + space_seperator);
-       slk_start_col[2] = (col += label_length + space_seperator);
-       slk_start_col[3] = (col += label_length + space_seperator);
-
-       center = COLS/2;
-       slk_start_col[4] = center - (2 * label_length) - space_seperator;
-       slk_start_col[5] = center - label_length;
-       slk_start_col[6] = center + space_seperator;
-       slk_start_col[7] = center + label_length + (2 * space_seperator);
-
-       col = COLS - ((label_length + space_seperator) * 3 + label_length);
-       slk_start_col[8] = col;
-       slk_start_col[9] = (col += label_length + space_seperator);
-       slk_start_col[10] = (col += label_length + space_seperator);
-       slk_start_col[11] = (col += label_length + space_seperator);
-       break;
-
-    default:    /* 5 - 5 F-Key layout */
-       slk_start_col[0] = col;
-       slk_start_col[1] = (col += label_length + space_seperator);
-       slk_start_col[2] = (col += label_length + space_seperator);
-       slk_start_col[3] = (col += label_length + space_seperator);
-       slk_start_col[4] = (col += label_length + space_seperator);
-
-       col = COLS - ((label_length + space_seperator) * 4 + label_length);
-       slk_start_col[5] = col;
-       slk_start_col[6] = (col += label_length + space_seperator);
-       slk_start_col[7] = (col += label_length + space_seperator);
-       slk_start_col[8] = (col += label_length + space_seperator);
-       slk_start_col[9] = (col += label_length + space_seperator);
-       break;
-
- } /* end switch */
-
- /* make sure labels are all in window */
- for (i = 0; i < labels; ++i)
- {
-    slk_set(i + 1, slk_save[i].label, slk_save[i].format);
- }
- return;
-}
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_mouse_in_slk(int y, int x)
-#else
-int	PDC_mouse_in_slk(y,x)
-int y, x;
-#endif
-/***********************************************************************/
-{
- register int i;
-
-#ifdef PDCDEBUG
- if (trace_on) PDC_debug("PDC_mouse_in_slk() - called: y->%d x->%d\n",y,x);
-#endif
-
-/*
- * If the line on which the mouse was clicked is NOT the last line of
- * the screen, we are not interested in it...
- */
- if ( SP->slk_winptr == NULL )
-    return(0);
- if ( y != ( SP->slk_winptr->_begy + label_line ) )
-    return(0);
-
- for (i=0;i<labels;i++)
- {
-    if (x >= slk_start_col[i]
-    &&  x <= slk_start_col[i] + label_length - 1)
-       return(i+1);
- }
-
- return(0);
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+#include <string.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	slk_init
+#undef	slk_set
+#undef	slk_refresh
+#undef	slk_noutrefresh
+#undef	slk_label
+#undef	slk_clear
+#undef	slk_restore
+#undef	slk_touch
+#undef	slk_attron
+#undef	slk_attrset
+#undef	slk_attroff
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_slk  = "$Id: slk.c,v 1.1 2001/01/10 08:27:29 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                          slk
+
+  Synopsis:
+
+  	int slk_init(int fmt);
+  	int slk_set(int labnum, char *label, int fmt);
+  	int slk_refresh(void);
+  	int slk_noutrefresh(void);
+  	char *slk_label(int labnum);
+  	int slk_clear(void);
+  	int slk_restore(void);
+  	int slk_touch(void);
+  	int slk_attron(attr_t attrs);
+  	int slk_attrset(attr_t attrs);
+  	int slk_attroff(attr_t attrs);
+
+  X/Open Description:
+ 	These functions manipulate a window that contain Soft Label Keys (SLK).
+ 	TO use the SLK functions, a call to slk_init() must be made BEFORE
+ 	initscr() or newterm(). slk_init() removes 1 or 2 lines from the
+ 	useable screen, depending on the format selected.
+
+ 	The line(s) removed from the screen are used as a separate window, in
+ 	which SLKs are displayed.
+
+ 	slk_init() requires a single parameter which describes the format of
+ 	the SLKs as follows:
+ 
+ 		1	3-2-3 format
+ 		2	4-4 format
+ 		3	4-4-4 format (ncurses extension)
+ 		4	4-4-4 format with index line (ncurses extension) 2 lines used
+ 		55	5-5 format (pdcurses format)
+
+ 	The functions slk_refresh(), slk_noutrefresh() and slk_touch() are
+ 	analagous to refresh(), noutrefresh() and touch() functions.
+
+  PDCurses Description:
+ 	System V compatible color support is included.
+ 	See <curses.h> for further details.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	It is an error to call this function with a NULL window pointer.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      slk_init                              Y        -       Y
+      slk_set                               Y        -       Y
+      slk_refresh                           Y        -       Y
+      slk_noutrefresh                       Y        -       Y
+      slk_label                             Y        -       Y
+      slk_clear                             Y        -       Y
+      slk_restore                           Y        -       Y
+      slk_touch                             Y        -       Y
+      slk_attron                            Y        -       Y
+      slk_attrset                           Y        -       Y
+      slk_attroff
+
+**man-end**********************************************************************/
+
+
+#define LABEL_NORMAL	8
+#define LABEL_EXTENDED	10
+#define LABEL_NCURSES_EXTENDED	12
+
+static int slk_start_col[LABEL_NCURSES_EXTENDED];
+static chtype slk_attributes[LABEL_NCURSES_EXTENDED];
+char slk_temp_string[64];
+static int space_seperator=1;
+static int label_length=0;
+static int labels=0;
+static int label_fmt=0;
+static int label_line=0;
+
+#ifdef HAVE_PROTO
+void (*PDC_initial_slk)(void);
+static void PDC_slk_init(void);
+#else
+void (*PDC_initial_slk)();
+static void PDC_slk_init();
+#endif
+
+static struct {
+	char	label[32];
+	int	format;		
+} slk_save[ LABEL_NCURSES_EXTENDED ];
+
+
+/***********************************************************************/
+/*
+   slk_init()	is the slk initialization routine.
+   This must be called before initscr().
+
+   label_fmt = 0, 1 or 55.
+       0 = 3-2-3 format
+       1 = 4 - 4 format
+       2 = 4-4-4 format	(ncurses extension for PC 12 function keys)
+       3 = 4-4-4 format	(ncurses extension for PC 12 function keys - with index line)
+      55 = 5 - 5 format	(extended for PC, 10 function keys)
+
+ */
+#ifdef HAVE_PROTO
+int PDC_CDECL slk_init(int fmt)
+#else
+int PDC_CDECL slk_init(fmt)
+int fmt;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_init() - called\n");
+#endif
+
+ if (PDC_SP)
+   return (ERR);
+
+ switch (fmt) 
+ {
+    case 0:  /* 3 - 2 - 3 */
+       labels = LABEL_NORMAL;
+       break;
+
+    case 1:   /* 4 - 4 */
+       labels = LABEL_NORMAL;
+       break;
+
+    case 2:   /* 4 4 4 */
+       labels = LABEL_NCURSES_EXTENDED;
+       break;
+
+    case 3:   /* 4 4 4  with index */
+       labels = LABEL_NCURSES_EXTENDED;
+       break;
+
+    case 55:  /* 5 - 5 */
+       labels = LABEL_EXTENDED;
+       break;
+
+    default:
+       return (ERR);
+ } /* end switch */
+
+ PDC_initial_slk = PDC_slk_init;
+ label_fmt = fmt;
+ return(OK);
+}
+
+
+
+
+/***********************************************************************/
+/*
+ PDC_slk_set() Used to set a slk label to a string.
+
+   label_num = 1 - 8 (or 10) (number of the label)
+   label_str = string (8 or 7 bytes total), NULL chars or NULL pointer
+   label_fmt =  justification
+      0 = left
+      1 = center
+      2 = right
+   save = 1 yes or 0 no
+ */
+#ifdef HAVE_PROTO
+static int PDC_slk_set(int label_num, char *label_str, int label_fmt, int save)
+#else
+static int PDC_slk_set(label_num, label_str, label_fmt, save)
+int label_num;
+char *label_str;
+int label_fmt;
+int save;
+#endif
+/***********************************************************************/
+{
+register int i, num;
+int slen;
+int llen;
+int col;
+
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("PDC_slk_set() - called\n");
+#endif
+
+ if (label_num < 1 
+ || label_num > labels 
+ || label_fmt < 0 
+ || label_fmt > 2)
+    return (ERR);
+
+
+/*
+    A NULL in either the first byte or pointer
+    indicates a clearing of the label.
+*/
+ num = label_num - 1;
+
+ if (label_str == (char *)0 || *label_str == '\0') 
+ {
+    slk_attributes[num] = PDC_SP->slk_winptr->_attrs;
+    wmove(PDC_SP->slk_winptr, label_line, slk_start_col[num]);
+
+    for (i = 0; i < label_length; ++i)
+       PDC_chadd( PDC_SP->slk_winptr, ' ', (bool)(!(PDC_SP->raw_out)), TRUE );
+
+    /* Save the string and attribute */
+    if (save)
+    {
+       *slk_save[num].label = '\0';
+       slk_save[num].format = 0;
+    }
+    wmove(PDC_SP->slk_winptr, label_line, 0);   /* park it */
+
+    return (OK);
+ }
+
+ /* Otherwise, format the character and put in position. */
+ memset(slk_temp_string, 0, sizeof (slk_temp_string));
+ strncpy(slk_temp_string, label_str, label_length);
+
+ /* Save the string and attribute */
+ if (save)
+ {
+    strcpy(slk_save[num].label, slk_temp_string);
+    slk_save[num].format = label_fmt;
+ }
+
+ slk_attributes[num] = PDC_SP->slk_winptr->_attrs;
+ wmove(PDC_SP->slk_winptr, label_line, slk_start_col[num]);
+
+ for (i = 0; i < label_length; ++i)
+    PDC_chadd( PDC_SP->slk_winptr, ' ', (bool)(!(PDC_SP->raw_out)), TRUE );
+
+ wmove(PDC_SP->slk_winptr, label_line, slk_start_col[num]);
+
+ switch (label_fmt)
+ {
+    case 0:  /* LEFT */
+       waddstr(PDC_SP->slk_winptr, slk_temp_string);
+       break;
+         
+    case 1:  /* CENTER */
+       slen = strlen(slk_temp_string);
+       col = slen / 2;
+       llen = label_length / 2;
+       col = llen - col;
+       if (col + slen > label_length)
+          --col;
+       mvwaddstr(PDC_SP->slk_winptr, label_line, slk_start_col[num] + col, slk_temp_string);
+       break;
+
+    default:  /* RIGHT */
+       slen = strlen(slk_temp_string);
+       col = label_length - slen;
+       mvwaddstr(PDC_SP->slk_winptr, label_line, slk_start_col[num] + col, slk_temp_string);
+       break;
+ }
+
+ wmove(PDC_SP->slk_winptr, label_line, 0);	/* park it */
+
+ return( OK );
+}
+
+
+/***********************************************************************/
+/*
+ slk_set() Used to set a slk label to a string.
+
+   label_num = 1 - 8 (or 10) (number of the label)
+   label_str = string (8 or 7 bytes total), NULL chars or NULL pointer
+   label_fmt =  justification
+      0 = left
+      1 = center
+      2 = right
+ */
+#ifdef HAVE_PROTO
+int PDC_CDECL slk_set(int label_num, char *label_str, int label_fmt)
+#else
+int PDC_CDECL slk_set(label_num, label_str, label_fmt)
+int label_num;
+char *label_str;
+int label_fmt;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_set() - called\n");
+#endif
+
+ return( PDC_slk_set( label_num, label_str, label_fmt, 1 ) );
+}
+
+
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	slk_refresh(void)
+#else
+int	PDC_CDECL	slk_refresh()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_refresh() - called\n");
+#endif
+
+ if (PDC_SP->slk_winptr == (WINDOW *)NULL)
+    return (ERR);
+
+ slk_noutrefresh();
+ return (doupdate());
+
+}
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	slk_noutrefresh(void)
+#else
+int	PDC_CDECL	slk_noutrefresh()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_noutrefresh() - called\n");
+#endif
+
+ if (PDC_SP->slk_winptr == (WINDOW *)NULL)
+    return (ERR);
+
+ return (wnoutrefresh(PDC_SP->slk_winptr));
+}
+
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char*	PDC_CDECL	slk_label(int labnum)
+#else
+char*	PDC_CDECL	slk_label(labnum)
+int labnum;   /* 1 - 8 (or 10) */
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_label() - called\n");
+#endif
+
+ if (labnum < 0 || labnum > labels)
+    return ((char *)0);
+
+ memset(slk_temp_string, 0, sizeof (slk_temp_string));
+ strcpy(slk_temp_string, slk_save[labnum - 1].label);
+
+ return (slk_temp_string);	/* only good temporarily */
+
+}
+
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	slk_clear(void)
+#else
+int	PDC_CDECL	slk_clear()
+#endif
+/***********************************************************************/
+{
+ register int i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("slk_clear() - called\n");
+#endif
+
+ for (i = 0; i < labels; ++i)
+ {
+    wattrset(PDC_SP->slk_winptr, slk_attributes[i]);
+    PDC_slk_set( i + 1, "", 0, 0 );
+ }
+ return wrefresh(PDC_SP->slk_winptr);
+}
+
+
+
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	slk_restore(void)
+#else
+int	PDC_CDECL	slk_restore()
+#endif
+/***********************************************************************/
+{
+ register int i;
+ chtype attr=PDC_SP->slk_winptr->_attrs;
+
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_restore() - called\n");
+#endif
+
+ for (i = 0; i < labels; ++i)
+ {
+    wattrset(PDC_SP->slk_winptr, slk_attributes[i]);
+    PDC_slk_set(i + 1, slk_save[i].label, slk_save[i].format, 0);
+ }
+
+ PDC_SP->slk_winptr->_attrs = attr;
+
+ return wrefresh(PDC_SP->slk_winptr);
+}
+
+
+
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	slk_touch(void)
+#else
+int	PDC_CDECL	slk_touch()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_touch() - called\n");
+#endif
+
+ return touchwin(PDC_SP->slk_winptr);
+}
+
+
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	slk_attron(attr_t attrs)
+#else
+int	PDC_CDECL	slk_attron(attrs)
+attr_t attrs;
+#endif
+/***********************************************************************/
+{
+ int i,rc;
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_attron() - called\n");
+#endif
+ rc = wattron(PDC_SP->slk_winptr, attrs);
+ for (i = 0; i < labels; ++i)
+ {
+    PDC_slk_set(i + 1, slk_save[i].label, slk_save[i].format, 0);
+ }
+ return rc;
+}
+
+
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	slk_attroff(attr_t attrs)
+#else
+int	PDC_CDECL	slk_attroff(attrs)
+attr_t attrs;
+#endif
+/***********************************************************************/
+{
+ int i,rc;
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_attroff() - called\n");
+#endif
+ rc = wattroff(PDC_SP->slk_winptr, attrs);
+ for (i = 0; i < labels; ++i)
+ {
+    PDC_slk_set(i + 1, slk_save[i].label, slk_save[i].format, 0);
+ }
+ return rc;
+}
+
+
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	slk_attrset(attr_t attrs)
+#else
+int	PDC_CDECL	slk_attrset(attrs)
+attr_t attrs;
+#endif
+/***********************************************************************/
+{
+ int i,rc;
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_attrset() - called\n");
+#endif
+
+ rc = wattrset(PDC_SP->slk_winptr, attrs);
+ for (i = 0; i < labels; ++i)
+ {
+    PDC_slk_set(i + 1, slk_save[i].label, slk_save[i].format, 0);
+ }
+
+ return rc;
+
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+static void	PDC_slk_init(void)
+#else
+static void	PDC_slk_init()
+#endif
+/***********************************************************************/
+{
+ register int i=0;
+ attr_t save_attr;
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("PDC_slk_init() - called\n");
+#endif
+
+/*
+ * Don't set this to NULL as resize_term() calls it.
+ PDC_initial_slk = NULL;
+ */
+      
+ if ( label_fmt == 3 )
+ {
+    PDC_SP->slklines = 2;
+    label_line = 1;
+ }
+ else
+    PDC_SP->slklines = 1;
+
+ if (!PDC_SP->slk_winptr)
+ {
+    if ((PDC_SP->slk_winptr = newwin(PDC_SP->slklines, COLS, LINES-PDC_SP->slklines, 0)) == (WINDOW *)0)
+       return;
+    wattrset(PDC_SP->slk_winptr,A_REVERSE);
+ }
+ PDC_slk_calc();
+ /* if we have an index line, display it now */
+ if ( label_fmt == 3 )
+ {
+    save_attr = PDC_SP->slk_winptr->_attrs;
+    wattrset(PDC_SP->slk_winptr,A_NORMAL);
+    wmove( PDC_SP->slk_winptr, 0, 0 );
+    whline( PDC_SP->slk_winptr, 0, COLS );
+    for ( i = 0; i < labels; i++ )
+    {
+       mvwprintw( PDC_SP->slk_winptr, 0, slk_start_col[i], "F%d", i+1 );
+    }
+    PDC_SP->slk_winptr->_attrs = save_attr;
+ }
+ touchwin(PDC_SP->slk_winptr);
+}
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_slk_calc(void)
+#else
+void	PDC_slk_calc()
+#endif
+/***********************************************************************/
+{
+ register int i=0;
+ register int col=0, center=0;
+
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("PDC_slk_calc() - called\n");
+#endif
+
+ switch (label_fmt) 
+ {
+    case 0:  /* 3 - 2 - 3 */
+       label_length = ( COLS / labels ) - space_seperator - 1;
+       break;
+
+    case 1:   /* 4 - 4 */
+       label_length = ( COLS / labels ) - space_seperator;
+       break;
+
+    case 2:   /* 4 4 4 */
+    case 3:   /* 4 4 4 with index */
+       label_length = ( COLS / labels ) - space_seperator;
+       break;
+
+    case 55:  /* 5 - 5 */
+       label_length = ( COLS / labels ) - space_seperator;
+       break;
+
+    default: /* should never get here!! */
+       return;
+ } /* end switch */
+
+
+ /* set default attribute */
+ for (i = 0; i < labels; ++i)
+ {
+    slk_attributes[i] = A_REVERSE;
+ }
+
+ switch (label_fmt) {
+    case 0:     /* 3 - 2 - 3 F-Key layout */
+       slk_start_col[0] = col;
+       slk_start_col[1] = (col += label_length + space_seperator);
+       slk_start_col[2] = (col += label_length + space_seperator);
+
+       center = COLS/2;
+       slk_start_col[3] = center - label_length;
+       slk_start_col[4] = center + space_seperator;
+
+       col = COLS - ((label_length + space_seperator) * 2 + label_length);
+       slk_start_col[5] = col;
+       slk_start_col[6] = (col += label_length + space_seperator);
+       slk_start_col[7] = (col += label_length + space_seperator);
+       break;
+
+    case 1:     /* 4 - 4 F-Key layout */
+       slk_start_col[0] = col;
+       slk_start_col[1] = (col += label_length + space_seperator);
+       slk_start_col[2] = (col += label_length + space_seperator);
+       slk_start_col[3] = (col += label_length + space_seperator);
+
+       col = COLS - ((label_length + space_seperator) * 3 + label_length);
+       slk_start_col[4] = col;
+       slk_start_col[5] = (col += label_length + space_seperator);
+       slk_start_col[6] = (col += label_length + space_seperator);
+       slk_start_col[7] = (col += label_length + space_seperator);
+       break;
+
+    case 2:     /* 4 4 4 F-Key layout */
+    case 3:     /* 4 4 4 F-Key layout with index */
+       slk_start_col[0] = col;
+       slk_start_col[1] = (col += label_length + space_seperator);
+       slk_start_col[2] = (col += label_length + space_seperator);
+       slk_start_col[3] = (col += label_length + space_seperator);
+
+       center = COLS/2;
+       slk_start_col[4] = center - (2 * label_length) - space_seperator;
+       slk_start_col[5] = center - label_length;
+       slk_start_col[6] = center + space_seperator;
+       slk_start_col[7] = center + label_length + (2 * space_seperator);
+
+       col = COLS - ((label_length + space_seperator) * 3 + label_length);
+       slk_start_col[8] = col;
+       slk_start_col[9] = (col += label_length + space_seperator);
+       slk_start_col[10] = (col += label_length + space_seperator);
+       slk_start_col[11] = (col += label_length + space_seperator);
+       break;
+
+    default:    /* 5 - 5 F-Key layout */
+       slk_start_col[0] = col;
+       slk_start_col[1] = (col += label_length + space_seperator);
+       slk_start_col[2] = (col += label_length + space_seperator);
+       slk_start_col[3] = (col += label_length + space_seperator);
+       slk_start_col[4] = (col += label_length + space_seperator);
+
+       col = COLS - ((label_length + space_seperator) * 4 + label_length);
+       slk_start_col[5] = col;
+       slk_start_col[6] = (col += label_length + space_seperator);
+       slk_start_col[7] = (col += label_length + space_seperator);
+       slk_start_col[8] = (col += label_length + space_seperator);
+       slk_start_col[9] = (col += label_length + space_seperator);
+       break;
+
+ } /* end switch */
+
+ /* make sure labels are all in window */
+ for (i = 0; i < labels; ++i)
+ {
+    slk_set(i + 1, slk_save[i].label, slk_save[i].format);
+ }
+ return;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_mouse_in_slk(int y, int x)
+#else
+int	PDC_mouse_in_slk(y,x)
+int y, x;
+#endif
+/***********************************************************************/
+{
+ register int i;
+
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("PDC_mouse_in_slk() - called: y->%d x->%d\n",y,x);
+#endif
+
+/*
+ * If the line on which the mouse was clicked is NOT the last line of
+ * the screen, we are not interested in it...
+ */
+ if ( PDC_SP->slk_winptr == NULL )
+    return(0);
+ if ( y != ( PDC_SP->slk_winptr->_begy + label_line ) )
+    return(0);
+
+ for (i=0;i<labels;i++)
+ {
+    if (x >= slk_start_col[i]
+    &&  x <= slk_start_col[i] + label_length - 1)
+       return(i+1);
+ }
+
+ return(0);
+}
Index: PDCurses/pdcurses/getch.c
===================================================================
--- PDCurses/pdcurses/getch.c	(revision 1)
+++ PDCurses/pdcurses/getch.c	(working copy)
@@ -1,399 +1,399 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	getch
-#undef	wgetch
-#undef	mvgetch
-#undef	mvwgetch
-#undef	ungetch
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef	wrefresh
-#  undef	nocbreak
-#  undef	move
-#  undef	wmove
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_getch  = "$Id: getch.c,v 1.3 2002/03/22 22:36:08 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                         getch
-
-  Synopsis:
-  	int getch(void);
-  	int wgetch(WINDOW *win);
-  	int mvgetch(int y, int x);
-  	int mvwgetch(WINDOW *win, int y, int x);
-  	int ungetch(int ch);
-
-  X/Open Description:
- 	With the getch(), wgetch(), mvgetch(), and mvwgetch() functions, 
- 	a character is read from the terminal associated with the window. 
- 	In nodelay mode, if there is no input
- 	waiting, the value ERR is returned. In delay mode, the program will
- 	hang until the system passes text through to the program.
- 	Depending on the setting of cbreak(), this will be after one
- 	character or after the first newline.  Unless noecho() has
- 	been set, the character will also be echoed into the designated
- 	window.
-
- 	If keypad() is TRUE, and a function key is pressed, the token for
- 	that function key will be returned instead of the raw characters.
- 	Possible function keys are defined in <curses.h> with integers
- 	beginning with 0401, whose names begin with KEY_.  If a character
- 	is received that could be the beginning of a function key (such as
- 	escape), curses will set a timer.  If the remainder of the sequence
- 	does not come in within the designated time, the character will be
- 	passed through, otherwise the function key value will be returned.
- 	For this reason, on many terminals, there will be a delay after a
- 	user presses the escape key before the escape is returned to the
- 	program.  (Use by a programmer of the escape key for a single
- 	character function is discouraged.)
-
- 	If nodelay(win,TRUE) has been called on the window and no input is
- 	waiting, the value ERR is returned.
-
- 	The ungetch() function places ch back onto the input queue to be
- 	returned by the next call to wgetch().
-
- 	NOTE: getch(), mvgetch() and mvwgetch() are implemented as macros.
-
-  PDCurses Description:
- 	Given the nature of the PC, there is no such timer set for an
- 	incoming ESCAPE value, because function keys generate unique
- 	scan codes that are not prefixed with the ESCAPE character.
-
- 	Also, note that the getch() definition will conflict  with
- 	many DOS compiler's runtime libraries.
-
-  X/Open Return Value:
- 	This functions return ERR or the value of the character, meta 
- 	character or function key token.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      getch                                 Y        Y       Y
-      wgetch                                Y        Y       Y
-      mvgetch                               Y        Y       Y
-      mvwgetch                              Y        Y       Y
-      ungetch                               Y        Y       Y
-
-**man-end**********************************************************************/
-
-static WINDOW *w;			/* to reduce stack usage   */
-
-/* this define to get around DOS libraries conflict */
-#define getch PDC_getch
-#define ungetch PDC_ungetch
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	PDC_getch(void)
-#else
-int	PDC_CDECL	PDC_getch()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("getch() - called\n");
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	return(wgetch(stdscr));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	wgetch(WINDOW *win)
-#else
-int	PDC_CDECL	wgetch(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-extern	int	c_pindex;		/* putter index		   */
-extern	int	c_gindex;		/* getter index		   */
-extern	int	c_ungind;		/* ungetch() push index   */
-extern	int	c_ungch[NUNGETCH];	/* array of ungotten chars */
-extern  WINDOW*	_getch_win_;
-
-/*	signed	key; MH*/
-	int	key;
-#if defined(DOS) || defined(OS2) || defined(WIN32)
-	bool	cbr;
-#endif
-/*	static	chtype	buffer[_INBUFSIZ];MH*/	/* character buffer */
-	static	int	buffer[_INBUFSIZ];	/* character buffer */
-#ifdef UNIX
-	short display_key = 0400;
-	bool cbreak_set = FALSE;
-#else
-	short display_key = 0x100;
-#endif
-	int waitingtenths = 0;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wgetch() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if ( SP->delaytenths )
-		waitingtenths = 2*SP->delaytenths; /* changed from 10 to 2 - William McBrine */
-
-/* wrs (7/31/93) -- System V curses refreshes window when wgetch is called */
-/*                  if there have been changes to it and it is not a pad */
-	if( (! (win->_flags & _PAD)) && (! win->_nodelay) ) 
-	{
-		if( is_wintouched(win) )
-			wrefresh(win);
-	}
-
-	_getch_win_ = win;
-
-	if (c_ungind)	
-	{			/* if ungotten char exists */
-						/* remove and return it */
-		if ((! (win->_flags & _PAD)) && (win->_nodelay))
-		{
-			if ( is_wintouched(win) )
-				wrefresh(win);
-		}
-		return( c_ungch[--c_ungind] );
-	}
-
-	if ((!SP->raw_inp) && (!SP->cbreak))
-	{
-		/*
-		 * if normal
-		 */
-		if (c_gindex < c_pindex)
-		{
-			/*
-			 * and data in buffer
-			 */
-			return( buffer[c_gindex++] );
-		}
-	}
-
-	w = win;		/* static for speed & stack */
-	c_pindex = 0;		/* prepare to buffer data */
-	c_gindex = 0;
-
-/*
- * to get here, no keys are buffered. go and get one...
- */
-
-	for(;;)			/* loop for any buffering */
-	{
-
-#ifdef UNIX
-		if (!(SP->raw_inp || SP->cbreak))
-			{
-			cbreak();
-			cbreak_set = TRUE;
-			}
-		if (w->_use_keypad)
-			key = PDC_sysgetch();
-		else
-			key = PDC_rawgetch();
-		if (cbreak_set)
-			nocbreak();
-#endif
-
-#if defined(DOS) || defined(OS2) || defined(WIN32)
-		if (SP->raw_inp)
-		{
-			/*
-			 * get a raw character
-			 */
-			key = PDC_rawgetch();
-		}
-		else
-		{
-			/*
-			 * get a system character
-			 * if break return proper
-			 */
-			cbr = PDC_get_ctrl_break();
-			PDC_set_ctrl_break(SP->orgcbr);
-			key = PDC_sysgetch();
-			PDC_set_ctrl_break(cbr);	/* restore as it was */
-		}
-#endif
-
-#if defined(XCURSES)
-		key = PDC_rawgetch();
-		if (!(_getch_win_->_use_keypad) && (unsigned int)key > 255)
-			key = (-1);
-#endif
-
-/*
- * Order of test for delaytenths and _nodelay reversed - William McBrine
- */
-		if (SP->delaytenths)
-		{
-			if (waitingtenths == 0 && key == (-1))
-				return(ERR);
-			if (key == (-1))
-			{
-				waitingtenths--;
-					napms(50); /* changed from 10 to 50 - William McBrine */
-				continue;
-			}
-		}
-		else
-		{
-			if (w->_nodelay)
-			{
-				/*
-				 * if nodelay and no char, return ERR
-				 */
-				if (key == -1)
-					return( ERR );
-				else if ( ! SP->echo ) {
-					if ( ! (w->_flags & _PAD) ) {
-						if ( is_wintouched(w) )
-							wrefresh(w);
-					}
-				}
-			}
-		}
-
-		if ((key == '\r') &&
-		    (SP->autocr) &&
-		    (!SP->raw_inp))
-		{
-			/*
-			 * translate CR
-			 */
-			key = '\n';
-		}
-		if ( SP->echo && (key < display_key) )
-		{
-			/*
-			 * if echo is enabled
-			 */
-			waddch(w, key);
-			wrefresh(w);
-		}
-		if ( (SP->raw_inp || SP->cbreak) )
-		{
-			/*
-			 * if no buffering
-			 */
-			return( key );
-		}
-
-		if (c_pindex < _INBUFSIZ - 2)
-		{
-			/*
-			 * if no overflow, put data in buffer
-			 */
-			buffer[c_pindex++] = key;
-		}
-		if ((key == '\n') || (key == '\r'))
-		{
-			/*
-			 * if we got a line
-			 */
-			return( buffer[c_gindex++] );
-		}
-	}
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvgetch(int y, int x)
-#else
-int	PDC_CDECL	mvgetch(y,x)
-int y;
-int x;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvgetch() - called\n");
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	if (move(y, x) == ERR)
-		return(ERR);
-	return(getch());
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvwgetch(WINDOW *win, int y, int x)
-#else
-int	PDC_CDECL	mvwgetch(win,y,x)
-WINDOW *win;
-int y;
-int x;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvwgetch() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if (wmove(win,y, x) == ERR)
-		return(ERR);
-	return(wgetch(win));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	PDC_ungetch(int ch)
-#else
-int	PDC_CDECL	PDC_ungetch(ch)
-int ch;
-#endif
-/***********************************************************************/
-{
-extern	int	c_ungind;		/* ungetch() push index */
-extern	int	c_ungch[NUNGETCH];	/* array of ungotten chars */
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("ungetch() - called\n");
-#endif
-
-	if (c_ungind >= NUNGETCH)	/* pushback stack full */
-		return( ERR );
-
-	c_ungch[c_ungind++] = ch;
-	return( OK );
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	getch
+#undef	wgetch
+#undef	mvgetch
+#undef	mvwgetch
+#undef	ungetch
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	wrefresh
+#  undef	nocbreak
+#  undef	move
+#  undef	wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_getch  = "$Id: getch.c,v 1.3 2002/03/22 22:36:08 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         getch
+
+  Synopsis:
+  	int getch(void);
+  	int wgetch(WINDOW *win);
+  	int mvgetch(int y, int x);
+  	int mvwgetch(WINDOW *win, int y, int x);
+  	int ungetch(int ch);
+
+  X/Open Description:
+ 	With the getch(), wgetch(), mvgetch(), and mvwgetch() functions, 
+ 	a character is read from the terminal associated with the window. 
+ 	In nodelay mode, if there is no input
+ 	waiting, the value ERR is returned. In delay mode, the program will
+ 	hang until the system passes text through to the program.
+ 	Depending on the setting of cbreak(), this will be after one
+ 	character or after the first newline.  Unless noecho() has
+ 	been set, the character will also be echoed into the designated
+ 	window.
+
+ 	If keypad() is TRUE, and a function key is pressed, the token for
+ 	that function key will be returned instead of the raw characters.
+ 	Possible function keys are defined in <curses.h> with integers
+ 	beginning with 0401, whose names begin with KEY_.  If a character
+ 	is received that could be the beginning of a function key (such as
+ 	escape), curses will set a timer.  If the remainder of the sequence
+ 	does not come in within the designated time, the character will be
+ 	passed through, otherwise the function key value will be returned.
+ 	For this reason, on many terminals, there will be a delay after a
+ 	user presses the escape key before the escape is returned to the
+ 	program.  (Use by a programmer of the escape key for a single
+ 	character function is discouraged.)
+
+ 	If nodelay(win,TRUE) has been called on the window and no input is
+ 	waiting, the value ERR is returned.
+
+ 	The ungetch() function places ch back onto the input queue to be
+ 	returned by the next call to wgetch().
+
+ 	NOTE: getch(), mvgetch() and mvwgetch() are implemented as macros.
+
+  PDCurses Description:
+ 	Given the nature of the PC, there is no such timer set for an
+ 	incoming ESCAPE value, because function keys generate unique
+ 	scan codes that are not prefixed with the ESCAPE character.
+
+ 	Also, note that the getch() definition will conflict  with
+ 	many DOS compiler's runtime libraries.
+
+  X/Open Return Value:
+ 	This functions return ERR or the value of the character, meta 
+ 	character or function key token.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      getch                                 Y        Y       Y
+      wgetch                                Y        Y       Y
+      mvgetch                               Y        Y       Y
+      mvwgetch                              Y        Y       Y
+      ungetch                               Y        Y       Y
+
+**man-end**********************************************************************/
+
+static WINDOW *w;			/* to reduce stack usage   */
+
+/* this define to get around DOS libraries conflict */
+#define getch PDC_getch
+#define ungetch PDC_ungetch
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	PDC_getch(void)
+#else
+int	PDC_CDECL	PDC_getch()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("getch() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	return(wgetch(stdscr));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wgetch(WINDOW *win)
+#else
+int	PDC_CDECL	wgetch(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+extern	int	c_pindex;		/* putter index		   */
+extern	int	c_gindex;		/* getter index		   */
+extern	int	c_ungind;		/* ungetch() push index   */
+extern	int	c_ungch[NUNGETCH];	/* array of ungotten chars */
+extern  WINDOW*	_getch_win_;
+
+/*	signed	key; MH*/
+	int	key;
+#if defined(DOS) || defined(OS2) || defined(WIN32)
+	bool	cbr;
+#endif
+/*	static	chtype	buffer[_INBUFSIZ];MH*/	/* character buffer */
+	static	int	buffer[_INBUFSIZ];	/* character buffer */
+#ifdef UNIX
+	short display_key = 0400;
+	bool cbreak_set = FALSE;
+#else
+	short display_key = 0x100;
+#endif
+	int waitingtenths = 0;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wgetch() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if ( PDC_SP->delaytenths )
+		waitingtenths = 2*PDC_SP->delaytenths; /* changed from 10 to 2 - William McBrine */
+
+/* wrs (7/31/93) -- System V curses refreshes window when wgetch is called */
+/*                  if there have been changes to it and it is not a pad */
+	if( (! (win->_flags & _PAD)) && (! win->_nodelay) ) 
+	{
+		if( is_wintouched(win) )
+			wrefresh(win);
+	}
+
+	_getch_win_ = win;
+
+	if (c_ungind)	
+	{			/* if ungotten char exists */
+						/* remove and return it */
+		if ((! (win->_flags & _PAD)) && (win->_nodelay))
+		{
+			if ( is_wintouched(win) )
+				wrefresh(win);
+		}
+		return( c_ungch[--c_ungind] );
+	}
+
+	if ((!PDC_SP->raw_inp) && (!PDC_SP->cbreak))
+	{
+		/*
+		 * if normal
+		 */
+		if (c_gindex < c_pindex)
+		{
+			/*
+			 * and data in buffer
+			 */
+			return( buffer[c_gindex++] );
+		}
+	}
+
+	w = win;		/* static for speed & stack */
+	c_pindex = 0;		/* prepare to buffer data */
+	c_gindex = 0;
+
+/*
+ * to get here, no keys are buffered. go and get one...
+ */
+
+	for(;;)			/* loop for any buffering */
+	{
+
+#ifdef UNIX
+		if (!(PDC_SP->raw_inp || PDC_SP->cbreak))
+			{
+			cbreak();
+			cbreak_set = TRUE;
+			}
+		if (w->_use_keypad)
+			key = PDC_sysgetch();
+		else
+			key = PDC_rawgetch();
+		if (cbreak_set)
+			nocbreak();
+#endif
+
+#if defined(DOS) || defined(OS2) || defined(WIN32)
+		if (PDC_SP->raw_inp)
+		{
+			/*
+			 * get a raw character
+			 */
+			key = PDC_rawgetch();
+		}
+		else
+		{
+			/*
+			 * get a system character
+			 * if break return proper
+			 */
+			cbr = PDC_get_ctrl_break();
+			PDC_set_ctrl_break(PDC_SP->orgcbr);
+			key = PDC_sysgetch();
+			PDC_set_ctrl_break(cbr);	/* restore as it was */
+		}
+#endif
+
+#if defined(XCURSES)
+		key = PDC_rawgetch();
+		if (!(_getch_win_->_use_keypad) && (unsigned int)key > 255)
+			key = (-1);
+#endif
+
+/*
+ * Order of test for delaytenths and _nodelay reversed - William McBrine
+ */
+		if (PDC_SP->delaytenths)
+		{
+			if (waitingtenths == 0 && key == (-1))
+				return(ERR);
+			if (key == (-1))
+			{
+				waitingtenths--;
+					napms(50); /* changed from 10 to 50 - William McBrine */
+				continue;
+			}
+		}
+		else
+		{
+			if (w->_nodelay)
+			{
+				/*
+				 * if nodelay and no char, return ERR
+				 */
+				if (key == -1)
+					return( ERR );
+				else if ( ! PDC_SP->echo ) {
+					if ( ! (w->_flags & _PAD) ) {
+						if ( is_wintouched(w) )
+							wrefresh(w);
+					}
+				}
+			}
+		}
+
+		if ((key == '\r') &&
+		    (PDC_SP->autocr) &&
+		    (!PDC_SP->raw_inp))
+		{
+			/*
+			 * translate CR
+			 */
+			key = '\n';
+		}
+		if ( PDC_SP->echo && (key < display_key) )
+		{
+			/*
+			 * if echo is enabled
+			 */
+			waddch(w, key);
+			wrefresh(w);
+		}
+		if ( (PDC_SP->raw_inp || PDC_SP->cbreak) )
+		{
+			/*
+			 * if no buffering
+			 */
+			return( key );
+		}
+
+		if (c_pindex < _INBUFSIZ - 2)
+		{
+			/*
+			 * if no overflow, put data in buffer
+			 */
+			buffer[c_pindex++] = key;
+		}
+		if ((key == '\n') || (key == '\r'))
+		{
+			/*
+			 * if we got a line
+			 */
+			return( buffer[c_gindex++] );
+		}
+	}
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvgetch(int y, int x)
+#else
+int	PDC_CDECL	mvgetch(y,x)
+int y;
+int x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvgetch() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (move(y, x) == ERR)
+		return(ERR);
+	return(getch());
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwgetch(WINDOW *win, int y, int x)
+#else
+int	PDC_CDECL	mvwgetch(win,y,x)
+WINDOW *win;
+int y;
+int x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwgetch() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(win,y, x) == ERR)
+		return(ERR);
+	return(wgetch(win));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	PDC_ungetch(int ch)
+#else
+int	PDC_CDECL	PDC_ungetch(ch)
+int ch;
+#endif
+/***********************************************************************/
+{
+extern	int	c_ungind;		/* ungetch() push index */
+extern	int	c_ungch[NUNGETCH];	/* array of ungotten chars */
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("ungetch() - called\n");
+#endif
+
+	if (c_ungind >= NUNGETCH)	/* pushback stack full */
+		return( ERR );
+
+	c_ungch[c_ungind++] = ch;
+	return( OK );
+}
Index: PDCurses/pdcurses/deleteln.c
===================================================================
--- PDCurses/pdcurses/deleteln.c	(revision 1)
+++ PDCurses/pdcurses/deleteln.c	(working copy)
@@ -1,324 +1,324 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	deleteln
-#undef	wdeleteln
-#undef	insdelln
-#undef	winsdelln
-#undef	insertln
-#undef	winsertln
-#undef	mvwinsertln
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_deleteln  = "$Id: deleteln.c,v 1.1 2001/01/10 08:26:58 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                      deleteln
-
-  Synopsis:
-  	int deleteln(void);
-  	int wdeleteln(WINDOW *win);
-  	int insdelln(int n);
-  	int winsdelln(WINDOW *win, int n);
-  	int insertln(void);
-  	int winsertln(WINDOW *win);
-  	int mvwinsertln(WINDOW *win, int y, int x);
-
-  X/Open Description:
- 	With the deleteln() and wdelteln() functions,
- 	the line under the cursor in the window is deleted.  All
- 	lines below the current line are moved up one line.  The
- 	bottom line of the window is cleared.  The cursor position
- 	does not change.
-
- 	With the insertln() and winsertn() functions,
- 	a blank line is inserted above the current line and the bottom
- 	line is lost.
-
- 	NOTE: deleteln() and insertln() are implemented as macros.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  NOTE:
- 	The behaviour of Unix curses is to clear the line with a space
- 	and attributes of A_NORMAL. PDCurses clears the line with the
- 	window's current attributes (including current colour). To get
- 	the behaviour of PDCurses, #define PDCURSES_WCLR in curses.h or
- 	add -DPDCURSES_WCLR to the compile switches.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      deleteln                              Y        Y       Y
-      wdeleteln                             Y        Y       Y
-      insdelln                              -        -      4.0
-      winsdelln                             -        -      4.0
-      insertln                              Y        Y       Y
-      winsertln                             Y        Y       Y
-      mvwinsertln                           -        -       -
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	deleteln(void)
-#else
-int	PDC_CDECL	deleteln()
-#endif
-/***********************************************************************/
-{
-	chtype	blank;
-	chtype*	temp;
-	chtype*	ptr;
-	int	y;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("deleteln() - called\n");
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-#if defined(PDCURSES_WCLR)
-	blank	= stdscr->_blank | stdscr->_attrs;
-#else
-/* wrs (4/10/93) account for window background */
-	blank	= stdscr->_bkgd;
-#endif
-	temp	= stdscr->_y[stdscr->_cury];
-
-	for (y = stdscr->_cury; y < stdscr->_bmarg; y++)
-	{
-		stdscr->_y[y]	 = stdscr->_y[y + 1];
-		stdscr->_firstch[y] = 0;
-		stdscr->_lastch[y] = stdscr->_maxx - 1;
-	}
-
-	for (ptr = temp; (ptr - temp < stdscr->_maxx); ptr++)
-		*ptr = blank;			/* make a blank line */
-
-	if( stdscr->_cury <= stdscr->_bmarg ) 
-	{
-		stdscr->_firstch[stdscr->_bmarg]	= 0;
-		stdscr->_lastch[stdscr->_bmarg]	= stdscr->_maxx - 1;
-		stdscr->_y[stdscr->_bmarg]		= temp;
-	}
-
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	wdeleteln(WINDOW *win)
-#else
-int	PDC_CDECL	wdeleteln(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-	chtype	blank;
-	chtype*	temp;
-	chtype*	ptr;
-	int	y;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wdeleteln() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-#if defined(PDCURSES_WCLR)
-	blank	= win->_blank | win->_attrs;
-#else
-/* wrs (4/10/93) account for window background */
-	blank	= win->_bkgd;
-#endif
-	temp	= win->_y[win->_cury];
-
-	for (y = win->_cury; y < win->_bmarg; y++)
-	{
-		win->_y[y]	 = win->_y[y + 1];
-		win->_firstch[y] = 0;
-		win->_lastch[y] = win->_maxx - 1;
-	}
-
-	for (ptr = temp; (ptr - temp < win->_maxx); ptr++)
-		*ptr = blank;			/* make a blank line */
-
-	if( win->_cury <= win->_bmarg ) 
-	{
-		win->_firstch[win->_bmarg]	= 0;
-		win->_lastch[win->_bmarg]	= win->_maxx - 1;
-		win->_y[win->_bmarg]		= temp;
-	}
-
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	insdelln(int n)
-#else
-int	PDC_CDECL	insdelln(n)
-int n;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("insdelln() - called\n");
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	return(winsdelln(stdscr,n));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	winsdelln(WINDOW *win, int n)
-#else
-int	PDC_CDECL	winsdelln(win,n)
-WINDOW *win;
-int n;
-#endif
-/***********************************************************************/
-{
-	int i;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("winsdelln() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if( n > 0 ) {
-		for(i=0; i<n; i++) {
-			if( winsertln(win) == ERR )
-				return ERR;
-		}
-	}
-	else if( n < 0 ) {
-		n = -n;
-		for(i=0; i<n; i++) {
-			if( wdeleteln(win) == ERR )
-				return ERR;
-		}
-	}
-
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	winsertln(WINDOW *win)
-#else
-int	PDC_CDECL	winsertln(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-	chtype	blank;
-	chtype*	temp;
-	chtype*	end;
-	short	y;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("winsertln() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-#if defined(PDCURSES_WCLR)
-	blank	= win->_blank | win->_attrs;
-#else
-/* wrs (4/10/93) account for window background */
-	blank	= win->_bkgd;
-#endif
-	temp	= win->_y[win->_maxy-1];
-
-	for (y = win->_maxy-1; y > win->_cury; y--)
-	{
-		win->_y[y]	 = win->_y[y - 1];
-		win->_firstch[y] = 0;
-		win->_lastch[y] = win->_maxx - 1;
-	}
-
-	win->_y[win->_cury] = temp;
-
-	for (end = &temp[win->_maxx - 1]; temp <= end; temp++)
-	{
-		*temp = blank;
-	}
-
-	win->_firstch[win->_cury] = 0;
-	win->_lastch[win->_cury] = win->_maxx - 1;
-
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	insertln(void)
-#else
-int	PDC_CDECL	insertln()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("insertln() - called\n");
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	return(winsertln(stdscr));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvwinsertln(WINDOW *win, int y, int x)
-#else
-int	PDC_CDECL	mvwinsertln(win, y, x)
-WINDOW *win;
-int y,x;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvwinsertln() - called\n");
-#endif
-
-	if (wmove(win,y,x) == ERR)
-		return(ERR);
-	return(winsertln(win));
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	deleteln
+#undef	wdeleteln
+#undef	insdelln
+#undef	winsdelln
+#undef	insertln
+#undef	winsertln
+#undef	mvwinsertln
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_deleteln  = "$Id: deleteln.c,v 1.1 2001/01/10 08:26:58 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                      deleteln
+
+  Synopsis:
+  	int deleteln(void);
+  	int wdeleteln(WINDOW *win);
+  	int insdelln(int n);
+  	int winsdelln(WINDOW *win, int n);
+  	int insertln(void);
+  	int winsertln(WINDOW *win);
+  	int mvwinsertln(WINDOW *win, int y, int x);
+
+  X/Open Description:
+ 	With the deleteln() and wdelteln() functions,
+ 	the line under the cursor in the window is deleted.  All
+ 	lines below the current line are moved up one line.  The
+ 	bottom line of the window is cleared.  The cursor position
+ 	does not change.
+
+ 	With the insertln() and winsertn() functions,
+ 	a blank line is inserted above the current line and the bottom
+ 	line is lost.
+
+ 	NOTE: deleteln() and insertln() are implemented as macros.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  NOTE:
+ 	The behaviour of Unix curses is to clear the line with a space
+ 	and attributes of A_NORMAL. PDCurses clears the line with the
+ 	window's current attributes (including current colour). To get
+ 	the behaviour of PDCurses, #define PDCURSES_WCLR in curses.h or
+ 	add -DPDCURSES_WCLR to the compile switches.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      deleteln                              Y        Y       Y
+      wdeleteln                             Y        Y       Y
+      insdelln                              -        -      4.0
+      winsdelln                             -        -      4.0
+      insertln                              Y        Y       Y
+      winsertln                             Y        Y       Y
+      mvwinsertln                           -        -       -
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	deleteln(void)
+#else
+int	PDC_CDECL	deleteln()
+#endif
+/***********************************************************************/
+{
+	chtype	blank;
+	chtype*	temp;
+	chtype*	ptr;
+	int	y;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("deleteln() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+#if defined(PDCURSES_WCLR)
+	blank	= stdscr->_blank | stdscr->_attrs;
+#else
+/* wrs (4/10/93) account for window background */
+	blank	= stdscr->_bkgd;
+#endif
+	temp	= stdscr->_y[stdscr->_cury];
+
+	for (y = stdscr->_cury; y < stdscr->_bmarg; y++)
+	{
+		stdscr->_y[y]	 = stdscr->_y[y + 1];
+		stdscr->_firstch[y] = 0;
+		stdscr->_lastch[y] = stdscr->_maxx - 1;
+	}
+
+	for (ptr = temp; (ptr - temp < stdscr->_maxx); ptr++)
+		*ptr = blank;			/* make a blank line */
+
+	if( stdscr->_cury <= stdscr->_bmarg ) 
+	{
+		stdscr->_firstch[stdscr->_bmarg]	= 0;
+		stdscr->_lastch[stdscr->_bmarg]	= stdscr->_maxx - 1;
+		stdscr->_y[stdscr->_bmarg]		= temp;
+	}
+
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wdeleteln(WINDOW *win)
+#else
+int	PDC_CDECL	wdeleteln(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	chtype	blank;
+	chtype*	temp;
+	chtype*	ptr;
+	int	y;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wdeleteln() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+#if defined(PDCURSES_WCLR)
+	blank	= win->_blank | win->_attrs;
+#else
+/* wrs (4/10/93) account for window background */
+	blank	= win->_bkgd;
+#endif
+	temp	= win->_y[win->_cury];
+
+	for (y = win->_cury; y < win->_bmarg; y++)
+	{
+		win->_y[y]	 = win->_y[y + 1];
+		win->_firstch[y] = 0;
+		win->_lastch[y] = win->_maxx - 1;
+	}
+
+	for (ptr = temp; (ptr - temp < win->_maxx); ptr++)
+		*ptr = blank;			/* make a blank line */
+
+	if( win->_cury <= win->_bmarg ) 
+	{
+		win->_firstch[win->_bmarg]	= 0;
+		win->_lastch[win->_bmarg]	= win->_maxx - 1;
+		win->_y[win->_bmarg]		= temp;
+	}
+
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	insdelln(int n)
+#else
+int	PDC_CDECL	insdelln(n)
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("insdelln() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	return(winsdelln(stdscr,n));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	winsdelln(WINDOW *win, int n)
+#else
+int	PDC_CDECL	winsdelln(win,n)
+WINDOW *win;
+int n;
+#endif
+/***********************************************************************/
+{
+	int i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winsdelln() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if( n > 0 ) {
+		for(i=0; i<n; i++) {
+			if( winsertln(win) == ERR )
+				return ERR;
+		}
+	}
+	else if( n < 0 ) {
+		n = -n;
+		for(i=0; i<n; i++) {
+			if( wdeleteln(win) == ERR )
+				return ERR;
+		}
+	}
+
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	winsertln(WINDOW *win)
+#else
+int	PDC_CDECL	winsertln(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	chtype	blank;
+	chtype*	temp;
+	chtype*	end;
+	short	y;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winsertln() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+#if defined(PDCURSES_WCLR)
+	blank	= win->_blank | win->_attrs;
+#else
+/* wrs (4/10/93) account for window background */
+	blank	= win->_bkgd;
+#endif
+	temp	= win->_y[win->_maxy-1];
+
+	for (y = win->_maxy-1; y > win->_cury; y--)
+	{
+		win->_y[y]	 = win->_y[y - 1];
+		win->_firstch[y] = 0;
+		win->_lastch[y] = win->_maxx - 1;
+	}
+
+	win->_y[win->_cury] = temp;
+
+	for (end = &temp[win->_maxx - 1]; temp <= end; temp++)
+	{
+		*temp = blank;
+	}
+
+	win->_firstch[win->_cury] = 0;
+	win->_lastch[win->_cury] = win->_maxx - 1;
+
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	insertln(void)
+#else
+int	PDC_CDECL	insertln()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("insertln() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	return(winsertln(stdscr));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwinsertln(WINDOW *win, int y, int x)
+#else
+int	PDC_CDECL	mvwinsertln(win, y, x)
+WINDOW *win;
+int y,x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwinsertln() - called\n");
+#endif
+
+	if (wmove(win,y,x) == ERR)
+		return(ERR);
+	return(winsertln(win));
+}
Index: PDCurses/pdcurses/termattr.c
===================================================================
--- PDCurses/pdcurses/termattr.c	(revision 1)
+++ PDCurses/pdcurses/termattr.c	(working copy)
@@ -1,445 +1,445 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-#ifdef UNIX
-#include <defs.h>
-#include <term.h>
-#endif
-
-#include <stdio.h>
-#include <string.h>
-#include <limits.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	baudrate
-#undef	erasechar
-#undef	has_ic
-#undef	has_il
-#undef	killchar
-#undef	longname
-#undef	termattrs
-#undef	termname
-#undef	wordchar
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_termattr  = "$Id: termattr.c,v 1.2 2002/11/27 11:25:18 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                     termattr
-
-  Synopsis:
-  	int baudrate(void);
-  	char erasechar(void);
-  	bool has_ic(void);
-  	bool has_il(void);
-  	char killchar(void);
-  	char *longname(void);
-  	attr_t termattrs(void);
-  	char *termname(void);
-
-  	char	wordchar(void);
-
-  X/Open Description:
- 	baudrate() returns the output speed of the terminal.  The number 
- 	returned is bits per second, for example 9600, and is an integer.
-
- 	The user's current ERASE character is returned from a call to
- 	erasechar();
-
- 	The has_ic function will return TRUE if the terminal has insert 
- 	character and delete character capabilities.
-
- 	The has_il() function will return TRUE if the terminal has insert
- 	line and delete line capabilities.
-
- 	The user's current KILL character is returned from a call to
- 	killchar();
-
- 	longname() returns a pointer to a static area containing a
- 	verbose description of the current terminal.  The maximum length
- 	of the string is 128 characters.  It is defined only after the
- 	call to initscr() or newterm().  The area is overwritten by each
- 	call to newterm() and is not restored by set_term().  The value
- 	should therefore be saved between calls to newterm(), if
- 	longname() is going to be used with multiple terminals.
-
- 	termname() returns a pointer to a static area containing a
- 	short description of the current terminal (14 characters).
-
- 	termattrs() returns a logical OR of all video attributes
- 	supported by the terminal.
-
-  PDCurses Description:
- 	If FAST_VIDEO is true, then this is the largest possible
- 	(portable) int value (INT_MAX from limits.h) IF direct
- 	video is possible, OR the approximate guess at BIOS speeds,
- 	19200.
- 	If FAST_VIDEO is false, this is an approximate guess at BIOS
- 	speeds, 19200.
-
- 	erasechar(), killchar() and wordchar() all return values that are 
- 	hardcoded at this time.  There may be future development
- 	to allow applications an easy way to specify these value.
-
- 	For DOS, has_ic() and has_il() always return TRUE, as the speed of
- 	the DIRECT VIDEO or even BIOS writes is quicker than on a
- 	serial terminal.
- 	For FLEXOS, this value has meaning and depends on the terminal,
- 	though at this time, it is a constant TRUE.
-
- 	In addition to the above definition for longname(), the form of 
- 	this string is the adapter name (or video card name) and the text 
- 	resolution. This may also be followed by the notation that the video 
- 	card may be a clone, which indicates that the card identification
- 	maps to more than one unique card.
- 	e.g. The MDS Genius and the Quadram QuadHPG identify themselves
- 	in the same manner, but are vastly different in maximum resolution.
-
- 	The user's current WORD character is returned from a call to
- 	wordchar();
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      baudrate                              Y        Y       Y
-      erasechar                             Y        Y       Y
-      has_ic                                Y        Y       Y
-      has_il                                Y        Y       Y
-      killchar                              Y        Y       Y
-      longname                              Y        Y       Y
-      termattrs                             Y        Y       Y
-      termname                              Y        Y       Y
-      wordchar                              -        -       -
-
-**man-end**********************************************************************/
-
-#ifdef	FLEXOS
-extern	char*	_flexos_gname();
-#endif
-static	char	_display[ 128 ];
-static	char	_shrtnme[ 14 ];
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	baudrate(void)
-#else
-int	PDC_CDECL	baudrate()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("baudrate() - called\n");
-#endif
-
-#ifdef UNIX
-	return (_CUR_TERM.baudrate);
-#else
-#ifdef FAST_VIDEO
-	return (SP->direct_video ? INT_MAX : 19200 );
-#else
-	return (19200);			/* Approx. guess at BIOS speeds.*/
-#endif
-#endif
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-char	PDC_CDECL	erasechar(void)
-#else
-char	PDC_CDECL	erasechar()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("erasechar() - called\n");
-#endif
-
-#ifdef UNIX
-#ifdef USE_TERMIO
-	ioctl(_CUR_TERM.fd, TCGETA, &_CUR_TERM.prog_mode);
-	return(_CUR_TERM.prog_mode.c_cc[VERASE]);
-#else
-	ioctl(_CUR_TERM.fd, TIOCGETP, &_CUR_TERM.prog_mode.v6);
-	return(_CUR_TERM.prog_mode.v6.sg_erase);
-#endif
-#else
-	return(	_ECHAR );	/* character delete char (^H) */
-#endif
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-bool	PDC_CDECL	has_ic(void)
-#else
-bool	PDC_CDECL	has_ic()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("has_ic() - called\n");
-#endif
-
-#ifdef UNIX
-	if (insert_character != NULL && delete_character != NULL)
-		return(TRUE);
-	else
-		return(FALSE);
-#else
-	return( TRUE );
-#endif
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-bool	PDC_CDECL	has_il(void)
-#else
-bool	PDC_CDECL	has_il()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("has_il() - called\n");
-#endif
-
-#ifdef UNIX
-	if (insert_line != NULL && delete_line != NULL)
-		return(TRUE);
-	else
-		return(FALSE);
-#else
-	return( TRUE );
-#endif
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-char	PDC_CDECL	killchar(void)
-#else
-char	PDC_CDECL	killchar()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("killchar() - called\n");
-#endif
-
-#ifdef UNIX
-#ifdef USE_TERMIO
-	ioctl(_CUR_TERM.fd, TCGETA, &_CUR_TERM.prog_mode);
-	return(_CUR_TERM.prog_mode.c_cc[VKILL]);
-#else
-	ioctl(_CUR_TERM.fd, TIOCGETP, &_CUR_TERM.prog_mode.v6);
-	return(_CUR_TERM.prog_mode.v6.sg_kill);
-#endif
-#else
-	return( _DLCHAR );	/* line delete char (^U) */
-#endif
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-char*	PDC_CDECL	longname(void)
-#else
-char*	PDC_CDECL	longname()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("longname() - called\n");
-#endif
-
-#if defined (XCURSES)
-	if (SP->mono)
-		sprintf(_display,"X11-MONO-%dx%d",LINES,COLS);
-	else
-		sprintf(_display,"X11-COLOR-%dx%d",LINES,COLS);
-#endif
-
-#ifdef OS2
-# ifdef EMXVIDEO
-	switch (SP->mono)
-	{
-	case FALSE:	sprintf(_display,"COLOR-%dx%d", LINES, COLS); break;
-	case TRUE:	sprintf(_display,"MONO-%dx%d", LINES, COLS); break;
-# else
-	switch	(SP->adapter.adapter)
-	{
-	case DISPLAY_CGA:	sprintf(_display, "CGA-%dx%d", LINES, COLS);	  break;
-	case DISPLAY_MONOCHROME:	sprintf(_display, "MDA-%dx%d", LINES, COLS);	  break;
-	case DISPLAY_EGA:	sprintf(_display, "EGA-%dx%d", LINES, COLS); break;
-	case DISPLAY_VGA:	sprintf(_display, "VGA-%dx%d", LINES, COLS); break;
-	case DISPLAY_8514A:     sprintf(_display, "8514-%dx%d", LINES, COLS);  break;
-# endif
-	default:	sprintf(_display, "Unknown-%dx%d", LINES, COLS);  break;
-	}
-#endif
-
-#ifdef DOS
-	switch	(SP->adapter)
-	{
-	case _CGA:	sprintf(_display, "CGA-%dx%d", LINES, COLS);	  break;
-	case _MDA:	sprintf(_display, "MDA-%dx%d", LINES, COLS);	  break;
-	case _EGACOLOR:	sprintf(_display, "EGAColor-%dx%d", LINES, COLS); break;
-	case _EGAMONO:	sprintf(_display, "EGAMono-%dx%d", LINES, COLS);  break;
-	case _VGACOLOR:	sprintf(_display, "VGAColor-%dx%d", LINES, COLS); break;
-	case _VGAMONO:	sprintf(_display, "VGAMono-%dx%d", LINES, COLS);  break;
-	case _MCGACOLOR:sprintf(_display, "MCGAColor-%dx%d", LINES, COLS);break;
-	case _MCGAMONO:	sprintf(_display, "MCGAMono-%dx%d", LINES, COLS); break;
-	case _MDS_GENIUS:sprintf(_display, "Genius-%dx%d", LINES, COLS);  break;
-	default:	sprintf(_display, "Unknown-%dx%d", LINES, COLS);  break;
-	}
-#endif
-
-#ifdef	FLEXOS
-	switch	(SP->adapter)
-	{
-	case _FLEXOS:	sprintf(_display, "%s", _cursesgname());	  break;
-	default:	sprintf(_display, "Unknown-%dx%d", LINES, COLS);  break;
-	}
-#endif
-
-
-	if (SP->bogus_adapter)
-		strcat(_display, " (Clone)");
-
-	return (_display);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-attr_t	PDC_CDECL	termattrs(void)
-#else
-attr_t	PDC_CDECL	termattrs()
-#endif
-/***********************************************************************/
-{
-	attr_t temp =   (A_NORMAL | A_BOLD | A_BLINK | A_REVERSE); /* blink is bold background on some platforms */
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("termattrs() - called\n");
-#endif
-
-	if( ! SP->mono )
-		temp |= A_COLOR;
-
-	return( temp );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-char*	PDC_CDECL	termname(void)
-#else
-char*	PDC_CDECL	termname()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("termname() - called\n");
-#endif
-
-#if defined (XCURSES)
-	if (SP->mono)
-		sprintf(_shrtnme,"X-MONO");
-	else
-		sprintf(_shrtnme,"X-COLOR");
-#endif
-
-#ifdef     OS2
-# ifdef	EMXVIDEO
-	switch (SP->mono)
-	{
-	case FALSE:	sprintf(_shrtnme,"COLOR"); break;
-	case TRUE:	sprintf(_shrtnme,"MONO"); break;
-# else
-	switch	(SP->adapter.adapter)
-	{
-	case DISPLAY_CGA:	sprintf(_shrtnme, "CGA");	  break;
-	case DISPLAY_MONOCHROME:	sprintf(_shrtnme, "MDA");	  break;
-	case DISPLAY_EGA:	sprintf(_shrtnme, "EGA"); break;
-	case DISPLAY_VGA:	sprintf(_shrtnme, "VGA"); break;
-	case DISPLAY_8514A:     sprintf(_shrtnme, "8514");  break;
-# endif
-	default:	sprintf(_shrtnme, "Unknown");  break;
-	}
-#endif
-
-#ifdef DOS
-	switch	(SP->adapter)
-	{
-	case _CGA:	sprintf(_shrtnme, "CGA");	  break;
-	case _MDA:	sprintf(_shrtnme, "MDA");	  break;
-	case _EGACOLOR:	sprintf(_shrtnme, "EGAColor"); break;
-	case _EGAMONO:	sprintf(_shrtnme, "EGAMono");  break;
-	case _VGACOLOR:	sprintf(_shrtnme, "VGAColor"); break;
-	case _VGAMONO:	sprintf(_shrtnme, "VGAMono");  break;
-	case _MCGACOLOR:sprintf(_shrtnme, "MCGAColor");break;
-	case _MCGAMONO:	sprintf(_shrtnme, "MCGAMono"); break;
-	case _MDS_GENIUS:sprintf(_shrtnme, "Genius");  break;
-	default:	sprintf(_shrtnme, "Unknown");  break;
-	}
-#endif
-
-#ifdef	FLEXOS
-	switch	(SP->adapter)
-	{
-	case _FLEXOS:	sprintf(_shrtnme, "%s", _cursesgname());	  break;
-	default:	sprintf(_shrtnme, "Unknown");  break;
-	}
-#endif
-
-	return (_shrtnme);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-char	PDC_CDECL	wordchar(void)
-#else
-char	PDC_CDECL	wordchar()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wordchar() - called\n");
-#endif
-
-#ifdef UNIX
-#ifdef USE_TERMIO
-	ioctl(_CUR_TERM.fd, TCGETA, &_CUR_TERM.prog_mode);
-	return(_CUR_TERM.prog_mode.c_cc[VWERASE]);
-#else
-#ifdef TIOCGLTC
-	ioctl(_CUR_TERM.fd, TIOCGLTC, &_CUR_TERM.prog_mode.bsd_new);
-	return(_CUR_TERM.prog_mode.bsd_new.t_werase);
-#else
-	return(0);
-#endif
-#endif
-#else
-	return (_DWCHAR);			/* word delete char */
-#endif
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef UNIX
+#include <defs.h>
+#include <term.h>
+#endif
+
+#include <stdio.h>
+#include <string.h>
+#include <limits.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	baudrate
+#undef	erasechar
+#undef	has_ic
+#undef	has_il
+#undef	killchar
+#undef	longname
+#undef	termattrs
+#undef	termname
+#undef	wordchar
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_termattr  = "$Id: termattr.c,v 1.2 2002/11/27 11:25:18 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                     termattr
+
+  Synopsis:
+  	int baudrate(void);
+  	char erasechar(void);
+  	bool has_ic(void);
+  	bool has_il(void);
+  	char killchar(void);
+  	char *longname(void);
+  	attr_t termattrs(void);
+  	char *termname(void);
+
+  	char	wordchar(void);
+
+  X/Open Description:
+ 	baudrate() returns the output speed of the terminal.  The number 
+ 	returned is bits per second, for example 9600, and is an integer.
+
+ 	The user's current ERASE character is returned from a call to
+ 	erasechar();
+
+ 	The has_ic function will return TRUE if the terminal has insert 
+ 	character and delete character capabilities.
+
+ 	The has_il() function will return TRUE if the terminal has insert
+ 	line and delete line capabilities.
+
+ 	The user's current KILL character is returned from a call to
+ 	killchar();
+
+ 	longname() returns a pointer to a static area containing a
+ 	verbose description of the current terminal.  The maximum length
+ 	of the string is 128 characters.  It is defined only after the
+ 	call to initscr() or newterm().  The area is overwritten by each
+ 	call to newterm() and is not restored by set_term().  The value
+ 	should therefore be saved between calls to newterm(), if
+ 	longname() is going to be used with multiple terminals.
+
+ 	termname() returns a pointer to a static area containing a
+ 	short description of the current terminal (14 characters).
+
+ 	termattrs() returns a logical OR of all video attributes
+ 	supported by the terminal.
+
+  PDCurses Description:
+ 	If FAST_VIDEO is true, then this is the largest possible
+ 	(portable) int value (INT_MAX from limits.h) IF direct
+ 	video is possible, OR the approximate guess at BIOS speeds,
+ 	19200.
+ 	If FAST_VIDEO is false, this is an approximate guess at BIOS
+ 	speeds, 19200.
+
+ 	erasechar(), killchar() and wordchar() all return values that are 
+ 	hardcoded at this time.  There may be future development
+ 	to allow applications an easy way to specify these value.
+
+ 	For DOS, has_ic() and has_il() always return TRUE, as the speed of
+ 	the DIRECT VIDEO or even BIOS writes is quicker than on a
+ 	serial terminal.
+ 	For FLEXOS, this value has meaning and depends on the terminal,
+ 	though at this time, it is a constant TRUE.
+
+ 	In addition to the above definition for longname(), the form of 
+ 	this string is the adapter name (or video card name) and the text 
+ 	resolution. This may also be followed by the notation that the video 
+ 	card may be a clone, which indicates that the card identification
+ 	maps to more than one unique card.
+ 	e.g. The MDS Genius and the Quadram QuadHPG identify themselves
+ 	in the same manner, but are vastly different in maximum resolution.
+
+ 	The user's current WORD character is returned from a call to
+ 	wordchar();
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      baudrate                              Y        Y       Y
+      erasechar                             Y        Y       Y
+      has_ic                                Y        Y       Y
+      has_il                                Y        Y       Y
+      killchar                              Y        Y       Y
+      longname                              Y        Y       Y
+      termattrs                             Y        Y       Y
+      termname                              Y        Y       Y
+      wordchar                              -        -       -
+
+**man-end**********************************************************************/
+
+#ifdef	FLEXOS
+extern	char*	_flexos_gname();
+#endif
+static	char	_display[ 128 ];
+static	char	_shrtnme[ 14 ];
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	baudrate(void)
+#else
+int	PDC_CDECL	baudrate()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("baudrate() - called\n");
+#endif
+
+#ifdef UNIX
+	return (_CUR_TERM.baudrate);
+#else
+#ifdef FAST_VIDEO
+	return (PDC_SP->direct_video ? INT_MAX : 19200 );
+#else
+	return (19200);			/* Approx. guess at BIOS speeds.*/
+#endif
+#endif
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char	PDC_CDECL	erasechar(void)
+#else
+char	PDC_CDECL	erasechar()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("erasechar() - called\n");
+#endif
+
+#ifdef UNIX
+#ifdef USE_TERMIO
+	ioctl(_CUR_TERM.fd, TCGETA, &_CUR_TERM.prog_mode);
+	return(_CUR_TERM.prog_mode.c_cc[VERASE]);
+#else
+	ioctl(_CUR_TERM.fd, TIOCGETP, &_CUR_TERM.prog_mode.v6);
+	return(_CUR_TERM.prog_mode.v6.sg_erase);
+#endif
+#else
+	return(	_ECHAR );	/* character delete char (^H) */
+#endif
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool	PDC_CDECL	has_ic(void)
+#else
+bool	PDC_CDECL	has_ic()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("has_ic() - called\n");
+#endif
+
+#ifdef UNIX
+	if (insert_character != NULL && delete_character != NULL)
+		return(TRUE);
+	else
+		return(FALSE);
+#else
+	return( TRUE );
+#endif
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool	PDC_CDECL	has_il(void)
+#else
+bool	PDC_CDECL	has_il()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("has_il() - called\n");
+#endif
+
+#ifdef UNIX
+	if (insert_line != NULL && delete_line != NULL)
+		return(TRUE);
+	else
+		return(FALSE);
+#else
+	return( TRUE );
+#endif
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char	PDC_CDECL	killchar(void)
+#else
+char	PDC_CDECL	killchar()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("killchar() - called\n");
+#endif
+
+#ifdef UNIX
+#ifdef USE_TERMIO
+	ioctl(_CUR_TERM.fd, TCGETA, &_CUR_TERM.prog_mode);
+	return(_CUR_TERM.prog_mode.c_cc[VKILL]);
+#else
+	ioctl(_CUR_TERM.fd, TIOCGETP, &_CUR_TERM.prog_mode.v6);
+	return(_CUR_TERM.prog_mode.v6.sg_kill);
+#endif
+#else
+	return( _DLCHAR );	/* line delete char (^U) */
+#endif
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char*	PDC_CDECL	longname(void)
+#else
+char*	PDC_CDECL	longname()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("longname() - called\n");
+#endif
+
+#if defined (XCURSES)
+	if (PDC_SP->mono)
+		sprintf(_display,"X11-MONO-%dx%d",LINES,COLS);
+	else
+		sprintf(_display,"X11-COLOR-%dx%d",LINES,COLS);
+#endif
+
+#ifdef OS2
+# ifdef EMXVIDEO
+	switch (PDC_SP->mono)
+	{
+	case FALSE:	sprintf(_display,"COLOR-%dx%d", LINES, COLS); break;
+	case TRUE:	sprintf(_display,"MONO-%dx%d", LINES, COLS); break;
+# else
+	switch	(PDC_SP->adapter.adapter)
+	{
+	case DISPLAY_CGA:	sprintf(_display, "CGA-%dx%d", LINES, COLS);	  break;
+	case DISPLAY_MONOCHROME:	sprintf(_display, "MDA-%dx%d", LINES, COLS);	  break;
+	case DISPLAY_EGA:	sprintf(_display, "EGA-%dx%d", LINES, COLS); break;
+	case DISPLAY_VGA:	sprintf(_display, "VGA-%dx%d", LINES, COLS); break;
+	case DISPLAY_8514A:     sprintf(_display, "8514-%dx%d", LINES, COLS);  break;
+# endif
+	default:	sprintf(_display, "Unknown-%dx%d", LINES, COLS);  break;
+	}
+#endif
+
+#ifdef DOS
+	switch	(PDC_SP->adapter)
+	{
+	case _CGA:	sprintf(_display, "CGA-%dx%d", LINES, COLS);	  break;
+	case _MDA:	sprintf(_display, "MDA-%dx%d", LINES, COLS);	  break;
+	case _EGACOLOR:	sprintf(_display, "EGAColor-%dx%d", LINES, COLS); break;
+	case _EGAMONO:	sprintf(_display, "EGAMono-%dx%d", LINES, COLS);  break;
+	case _VGACOLOR:	sprintf(_display, "VGAColor-%dx%d", LINES, COLS); break;
+	case _VGAMONO:	sprintf(_display, "VGAMono-%dx%d", LINES, COLS);  break;
+	case _MCGACOLOR:sprintf(_display, "MCGAColor-%dx%d", LINES, COLS);break;
+	case _MCGAMONO:	sprintf(_display, "MCGAMono-%dx%d", LINES, COLS); break;
+	case _MDS_GENIUS:sprintf(_display, "Genius-%dx%d", LINES, COLS);  break;
+	default:	sprintf(_display, "Unknown-%dx%d", LINES, COLS);  break;
+	}
+#endif
+
+#ifdef	FLEXOS
+	switch	(PDC_SP->adapter)
+	{
+	case _FLEXOS:	sprintf(_display, "%s", _cursesgname());	  break;
+	default:	sprintf(_display, "Unknown-%dx%d", LINES, COLS);  break;
+	}
+#endif
+
+
+	if (PDC_SP->bogus_adapter)
+		strcat(_display, " (Clone)");
+
+	return (_display);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+attr_t	PDC_CDECL	termattrs(void)
+#else
+attr_t	PDC_CDECL	termattrs()
+#endif
+/***********************************************************************/
+{
+	attr_t temp =   (A_NORMAL | A_BOLD | A_BLINK | A_REVERSE); /* blink is bold background on some platforms */
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("termattrs() - called\n");
+#endif
+
+	if( ! PDC_SP->mono )
+		temp |= A_COLOR;
+
+	return( temp );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char*	PDC_CDECL	termname(void)
+#else
+char*	PDC_CDECL	termname()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("termname() - called\n");
+#endif
+
+#if defined (XCURSES)
+	if (PDC_SP->mono)
+		sprintf(_shrtnme,"X-MONO");
+	else
+		sprintf(_shrtnme,"X-COLOR");
+#endif
+
+#ifdef     OS2
+# ifdef	EMXVIDEO
+	switch (PDC_SP->mono)
+	{
+	case FALSE:	sprintf(_shrtnme,"COLOR"); break;
+	case TRUE:	sprintf(_shrtnme,"MONO"); break;
+# else
+	switch	(PDC_SP->adapter.adapter)
+	{
+	case DISPLAY_CGA:	sprintf(_shrtnme, "CGA");	  break;
+	case DISPLAY_MONOCHROME:	sprintf(_shrtnme, "MDA");	  break;
+	case DISPLAY_EGA:	sprintf(_shrtnme, "EGA"); break;
+	case DISPLAY_VGA:	sprintf(_shrtnme, "VGA"); break;
+	case DISPLAY_8514A:     sprintf(_shrtnme, "8514");  break;
+# endif
+	default:	sprintf(_shrtnme, "Unknown");  break;
+	}
+#endif
+
+#ifdef DOS
+	switch	(PDC_SP->adapter)
+	{
+	case _CGA:	sprintf(_shrtnme, "CGA");	  break;
+	case _MDA:	sprintf(_shrtnme, "MDA");	  break;
+	case _EGACOLOR:	sprintf(_shrtnme, "EGAColor"); break;
+	case _EGAMONO:	sprintf(_shrtnme, "EGAMono");  break;
+	case _VGACOLOR:	sprintf(_shrtnme, "VGAColor"); break;
+	case _VGAMONO:	sprintf(_shrtnme, "VGAMono");  break;
+	case _MCGACOLOR:sprintf(_shrtnme, "MCGAColor");break;
+	case _MCGAMONO:	sprintf(_shrtnme, "MCGAMono"); break;
+	case _MDS_GENIUS:sprintf(_shrtnme, "Genius");  break;
+	default:	sprintf(_shrtnme, "Unknown");  break;
+	}
+#endif
+
+#ifdef	FLEXOS
+	switch	(PDC_SP->adapter)
+	{
+	case _FLEXOS:	sprintf(_shrtnme, "%s", _cursesgname());	  break;
+	default:	sprintf(_shrtnme, "Unknown");  break;
+	}
+#endif
+
+	return (_shrtnme);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char	PDC_CDECL	wordchar(void)
+#else
+char	PDC_CDECL	wordchar()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wordchar() - called\n");
+#endif
+
+#ifdef UNIX
+#ifdef USE_TERMIO
+	ioctl(_CUR_TERM.fd, TCGETA, &_CUR_TERM.prog_mode);
+	return(_CUR_TERM.prog_mode.c_cc[VWERASE]);
+#else
+#ifdef TIOCGLTC
+	ioctl(_CUR_TERM.fd, TIOCGLTC, &_CUR_TERM.prog_mode.bsd_new);
+	return(_CUR_TERM.prog_mode.bsd_new.t_werase);
+#else
+	return(0);
+#endif
+#endif
+#else
+	return (_DWCHAR);			/* word delete char */
+#endif
+}
Index: PDCurses/pdcurses/addch.c
===================================================================
--- PDCurses/pdcurses/addch.c	(revision 1)
+++ PDCurses/pdcurses/addch.c	(working copy)
@@ -1,238 +1,238 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	addch
-#undef	waddch
-#undef	mvaddch
-#undef	mvwaddch
-#undef	echochar
-#undef	wechochar
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef	refresh
-#  undef	wrefresh
-#  undef	move
-#  undef	wmove
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_addch  = "$Id: addch.c,v 1.1 2001/01/10 08:26:44 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                         addch
-
-  Synopsis:
-  	int addch(chtype ch);
-  	int waddch(WINDOW *win, chtype ch);
-  	int mvaddch(int y, int x, chtype ch);
-  	int mvwaddch(WINDOW *win, int y, int x, chtype ch);
-  	int echochar(chtype ch);
-  	int wechochar(WINDOW *win, chtype ch);
-
-  X/Open Description:
- 	The routine addch() inserts the character ch into the default
- 	window at the current cursor position and the window cursor is
- 	advanced.  The character is of the type chtype as containing
- 	both data and attributes.
-
- 	The routine waddch() inserts the character ch into the specified
- 	window at the current cursor position.  The cursor position is
- 	advanced.
-
- 	The routine mvaddch() moves the cursor to the specified (y, x)
- 	position and inserts the character ch into the default window.
- 	The cursor position is advanced after the character has been
- 	inserted.
-
- 	The routine mvwaddch() moves the cursor to the specified (y, x)
- 	position and inserts the character ch into the specified
- 	window.  The cursor position is advanced after the character
- 	has been inserted.
-
- 	The routine echochar() inserts the character ch into stdscr
- 	at the current cursor position and a refresh() is called.  
- 	The cursor position is advanced.
-
- 	The routine wechochar() inserts the character ch into the
- 	specified window at the current cursor position and a wrefresh() 
- 	is called. The cursor position is advanced.
-
- 	All these routines are similar to putchar().  The following
- 	information applies to all the routines.
-
- 	If the cursor moves on to the right margin, an automatic
- 	newline is performed.  If scrollok is enabled, and a character
- 	is added to the bottom right corner of the screen, the
- 	scrolling region will be scrolled up one line.  If scrolling
- 	is not allowed, ERR will be returned.
-
- 	If ch is a tab, newline, or backspace, the cursor will be
- 	moved appropriately within the window.  If ch is a newline,
- 	the clrtoeol routine is called before the cursor is moved to
- 	the beginning of the next line.  If newline mapping is off,
- 	the cursor will be moved to the next line, but the x
- 	coordinate will be unchanged.  If ch is a tab the cursor is
- 	moved to the next tab position within the window.  If ch is
- 	another control character, it will be drawn in the ^X
- 	notation.  Calling the inch() routine after adding a control
- 	character returns the representation of the control character,
- 	not the control character.
-
- 	Video attributes can be combined with a character by ORing
- 	them into the parameter.  This will result in these attributes
- 	being set.  The intent here is that text, including
- 	attributes, can be copied from one place to another using inch()
- 	and addch().
-
- 	NOTE: All these functions are implemented as macros.
-
-  PDCurses Description:
- 	Depending upon the state of the raw character output, 7- or
- 	8-bit characters will be output.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      addch                                 Y        Y       Y
-      waddch                                Y        Y       Y
-      mvaddch                               Y        Y       Y
-      mvwaddch                              Y        Y       Y
-      echochar                              -        -      3.0
-      wechochar                             -        -      3.0
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	addch(chtype ch)
-#else
-int	PDC_CDECL	addch(ch)
-chtype ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("addch() - called: ch=%x\n",ch);
-#endif
-
-	return( PDC_chadd( stdscr, ch, (bool)(!(SP->raw_out)), TRUE ) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	waddch(WINDOW *win, chtype ch)
-#else
-int	PDC_CDECL	waddch(win,ch)
-WINDOW *win;
-chtype ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("waddch() - called: win=%x ch=%x\n",win,ch);
-#endif
-
-	return( PDC_chadd( win, ch, (bool)(!(SP->raw_out)), TRUE ) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvaddch(int y, int x, chtype ch)
-#else
-int	PDC_CDECL	mvaddch(y,x,ch)
-int y;
-int x;
-chtype ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvaddch() - called: y=%d x=%d ch=%x\n",y,x,ch);
-#endif
-	if (move(y,x) == ERR)
-		return(ERR);
-	return( PDC_chadd( stdscr, ch, (bool)(!(SP->raw_out)), TRUE ) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvwaddch(WINDOW *win, int y, int x, chtype ch)
-#else
-int	PDC_CDECL	mvwaddch(win,y,x,ch)
-WINDOW *win;
-int y;
-int x;
-chtype ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvwaddch() - called: win=%x y=%d x=%d ch=%d\n",win,y,x,ch);
-#endif
-	if (wmove(win,y,x) == ERR)
-		return(ERR);
-	return( PDC_chadd( win, ch, (bool)(!(SP->raw_out)), TRUE ) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	echochar(chtype ch)
-#else
-int	PDC_CDECL	echochar(ch)
-chtype ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("echochar() - called: ch=%x\n",ch);
-#endif
-
-	if (PDC_chadd( stdscr, ch, (bool)(!(SP->raw_out)), TRUE ) == ERR)
-		return(ERR);
-	return(refresh());
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	wechochar(WINDOW *win, chtype ch)
-#else
-int	PDC_CDECL	wechochar(win,ch)
-WINDOW *win;
-chtype ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wechochar() - called: win=%x ch=%x\n",win,ch);
-#endif
-
-	if (PDC_chadd( win, ch, (bool)(!(SP->raw_out)), TRUE ) == ERR)
-		return(ERR);
-	return(wrefresh(win));
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	addch
+#undef	waddch
+#undef	mvaddch
+#undef	mvwaddch
+#undef	echochar
+#undef	wechochar
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	refresh
+#  undef	wrefresh
+#  undef	move
+#  undef	wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_addch  = "$Id: addch.c,v 1.1 2001/01/10 08:26:44 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         addch
+
+  Synopsis:
+  	int addch(chtype ch);
+  	int waddch(WINDOW *win, chtype ch);
+  	int mvaddch(int y, int x, chtype ch);
+  	int mvwaddch(WINDOW *win, int y, int x, chtype ch);
+  	int echochar(chtype ch);
+  	int wechochar(WINDOW *win, chtype ch);
+
+  X/Open Description:
+ 	The routine addch() inserts the character ch into the default
+ 	window at the current cursor position and the window cursor is
+ 	advanced.  The character is of the type chtype as containing
+ 	both data and attributes.
+
+ 	The routine waddch() inserts the character ch into the specified
+ 	window at the current cursor position.  The cursor position is
+ 	advanced.
+
+ 	The routine mvaddch() moves the cursor to the specified (y, x)
+ 	position and inserts the character ch into the default window.
+ 	The cursor position is advanced after the character has been
+ 	inserted.
+
+ 	The routine mvwaddch() moves the cursor to the specified (y, x)
+ 	position and inserts the character ch into the specified
+ 	window.  The cursor position is advanced after the character
+ 	has been inserted.
+
+ 	The routine echochar() inserts the character ch into stdscr
+ 	at the current cursor position and a refresh() is called.  
+ 	The cursor position is advanced.
+
+ 	The routine wechochar() inserts the character ch into the
+ 	specified window at the current cursor position and a wrefresh() 
+ 	is called. The cursor position is advanced.
+
+ 	All these routines are similar to putchar().  The following
+ 	information applies to all the routines.
+
+ 	If the cursor moves on to the right margin, an automatic
+ 	newline is performed.  If scrollok is enabled, and a character
+ 	is added to the bottom right corner of the screen, the
+ 	scrolling region will be scrolled up one line.  If scrolling
+ 	is not allowed, ERR will be returned.
+
+ 	If ch is a tab, newline, or backspace, the cursor will be
+ 	moved appropriately within the window.  If ch is a newline,
+ 	the clrtoeol routine is called before the cursor is moved to
+ 	the beginning of the next line.  If newline mapping is off,
+ 	the cursor will be moved to the next line, but the x
+ 	coordinate will be unchanged.  If ch is a tab the cursor is
+ 	moved to the next tab position within the window.  If ch is
+ 	another control character, it will be drawn in the ^X
+ 	notation.  Calling the inch() routine after adding a control
+ 	character returns the representation of the control character,
+ 	not the control character.
+
+ 	Video attributes can be combined with a character by ORing
+ 	them into the parameter.  This will result in these attributes
+ 	being set.  The intent here is that text, including
+ 	attributes, can be copied from one place to another using inch()
+ 	and addch().
+
+ 	NOTE: All these functions are implemented as macros.
+
+  PDCurses Description:
+ 	Depending upon the state of the raw character output, 7- or
+ 	8-bit characters will be output.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      addch                                 Y        Y       Y
+      waddch                                Y        Y       Y
+      mvaddch                               Y        Y       Y
+      mvwaddch                              Y        Y       Y
+      echochar                              -        -      3.0
+      wechochar                             -        -      3.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	addch(chtype ch)
+#else
+int	PDC_CDECL	addch(ch)
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("addch() - called: ch=%x\n",ch);
+#endif
+
+	return( PDC_chadd( stdscr, ch, (bool)(!(PDC_SP->raw_out)), TRUE ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	waddch(WINDOW *win, chtype ch)
+#else
+int	PDC_CDECL	waddch(win,ch)
+WINDOW *win;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("waddch() - called: win=%x ch=%x\n",win,ch);
+#endif
+
+	return( PDC_chadd( win, ch, (bool)(!(PDC_SP->raw_out)), TRUE ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvaddch(int y, int x, chtype ch)
+#else
+int	PDC_CDECL	mvaddch(y,x,ch)
+int y;
+int x;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvaddch() - called: y=%d x=%d ch=%x\n",y,x,ch);
+#endif
+	if (move(y,x) == ERR)
+		return(ERR);
+	return( PDC_chadd( stdscr, ch, (bool)(!(PDC_SP->raw_out)), TRUE ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwaddch(WINDOW *win, int y, int x, chtype ch)
+#else
+int	PDC_CDECL	mvwaddch(win,y,x,ch)
+WINDOW *win;
+int y;
+int x;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwaddch() - called: win=%x y=%d x=%d ch=%d\n",win,y,x,ch);
+#endif
+	if (wmove(win,y,x) == ERR)
+		return(ERR);
+	return( PDC_chadd( win, ch, (bool)(!(PDC_SP->raw_out)), TRUE ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	echochar(chtype ch)
+#else
+int	PDC_CDECL	echochar(ch)
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("echochar() - called: ch=%x\n",ch);
+#endif
+
+	if (PDC_chadd( stdscr, ch, (bool)(!(PDC_SP->raw_out)), TRUE ) == ERR)
+		return(ERR);
+	return(refresh());
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wechochar(WINDOW *win, chtype ch)
+#else
+int	PDC_CDECL	wechochar(win,ch)
+WINDOW *win;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wechochar() - called: win=%x ch=%x\n",win,ch);
+#endif
+
+	if (PDC_chadd( win, ch, (bool)(!(PDC_SP->raw_out)), TRUE ) == ERR)
+		return(ERR);
+	return(wrefresh(win));
+}
Index: PDCurses/pdcurses/pad.c
===================================================================
--- PDCurses/pdcurses/pad.c	(revision 1)
+++ PDCurses/pdcurses/pad.c	(working copy)
@@ -1,424 +1,424 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define CURSES_LIBRARY 1
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif
-#include <curses.h>
-
-#include <string.h>
-
-#ifdef HAVE_MEMORY_H
-# include <memory.h>
-#endif
-
-/* undefine any macros for functions defined in this module */
-#undef newpad
-#undef subpad
-#undef prefresh
-#undef pnoutrefresh
-#undef pechochar
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-# undef doupdate
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_pad  = "$Id: pad.c,v 1.3 2002/05/26 01:12:45 mark Exp $";
-#endif
-
-/*
- * save values for pechochar()
- */
-static int save_pminrow;
-static int save_pmincol;
-static int save_sminrow;
-static int save_smincol;
-static int save_smaxrow;
-static int save_smaxcol;
-
-/*man-start*********************************************************************
-
-  Name:                                                           pad
-
-  Synopsis:
-    WINDOW* newpad( int nlines, int ncols );
-    WINDOW* subpad(WINDOW* orig,int nlines,int ncols,int begin_y,int begin_x);
-    int prefresh(WINDOW* win,int py,int px,int sy1,int sx1,int sy2,int sx2);
-    int pnoutrefresh(WINDOW* w,int py,int px,int sy1,int sx1,int sy2,int sx2);
-    int pechochar(WINDOW *pad, chtype ch);
-
-  X/Open Description:
-    newpad() creates a new pad data structure.  A pad is a special case
-    of a window, which is not restricted by the screen size, and is not
-    necessarily associated with a particular part of the screen.  A
-    pad can be used when a large window is needed, and only a part
-    of the window will be on the screen at one tme.  Automatic
-    refreshes of pads (e.g., from scrolling or echoing of input) do
-    not occur.  It is not legal to call refresh() with a pad as an
-    argument; the routines prefresh() or pnoutrefresh() should be
-    called instead.  Note that these routines require additional
-    parameters to specify the part of the pad to be displayed and
-    the location on the screen to be used for display.
-
-    The subpad() routine creates a new sub-pad within a pad.  The
-    dimensions of the sub-pad are nlines lines and ncols
-    columns.  The sub-pad is at position (begin_y, begin_x) in the
-    the parent pad.  This position is relative to the pad, and not
-    to the screen like with subwin.
-    The sub-pad is made in the middle of the pad orig, so
-    that changes made to either pad will affect both.  When
-    using this routine, it will often be necessary to call
-    touchwin before calling prefresh.
-
-    The prefresh() routine copies the specified pad to the physical
-    terminal screen.  It takes account of what is already
-    displayed on the screen to optimize cursor movement.
-    The pnoutrefresh() routine copies the named pad to the virtual
-    screen. It then compares the virtual screen with the physical
-    screen and performs the actual update.
-    These routines are analogous to the routines wrefresh() and
-    wnoutrefresh() except that pads, instead of windows, are
-    involved.  Additional parameters are also needed to indicate
-    what part of the pad and screen are involved. The upper left
-    corner of the part of the pad to be displayed is specified by
-    py and px.  The coordinates sy1, sx1, sy2, and sx2 specify the
-    edges of the screen rectangle that will contain the selected
-    part of the pad.
-    The lower right corner of the pad rectangle to be displayed is
-    calculated from the screen co-ordinates.  This ensures that
-    the screen rectangle and the pad rectangle are the same size.
-    Both rectangles must be entirely contained within their
-    respective structures.
-
-    The pechochar() is functionally equivalent to adch() followed
-    by a call to refresh().
-
-  PDCurses Description:
-    PDCurses (as a library) provides the developer with the ability to
-    hook in their own malloc debugging  package.  See the details in
-    INITSCR.C for details on how to accomplish this.
-
-  X/Open Return Value:
-    All functions return OK on success and ERR on error.
-
-  X/Open Errors:
-    No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      newpad                                Y        -       Y
-      subpad                                Y        -       Y
-      prefresh                              Y        -       Y
-      pnoutrefresh                          Y        -       Y
-      pechochar                             -        -      3.0
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-WINDOW* PDC_CDECL newpad( int nlines, int ncols )
-#else
-WINDOW* PDC_CDECL newpad(nlines,ncols)
-int nlines;
-int ncols;
-#endif
-/***********************************************************************/
-{
-#ifdef HAVE_PROTO
-   extern void* (*callc)( size_t, size_t );
-   extern void  (*fre)( void* );
-#else
-   extern void* (*callc)();
-   extern void  (*fre)();
-#endif
-
-   WINDOW* win;
-   chtype* ptr;
-   int   i;
-   int   j;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("newpad() - called: lines=%d cols=%d\n",nlines,ncols);
-#endif
-
-   if ((win = PDC_makenew( nlines, ncols, -1, -1 )) == (WINDOW *)NULL)
-      return( (WINDOW *)NULL );
-
-   for (i = 0; i < nlines; i++)
-   {
-      /*
-       * make and clear the lines
-       */
-      if ((win->_y[i] = (*callc)(ncols, sizeof(chtype))) == NULL)
-      {
-         for (j = 0; j < i; j++)
-         {
-            /*
-             * if error, free all the data
-             */
-            (*fre)(win->_y[j]);
-         }
-         (*fre)(win->_firstch);
-         (*fre)(win->_lastch);
-         (*fre)(win->_y);
-         (*fre)(win);
-         return( (WINDOW *)NULL );
-      }
-      else
-      {
-         for (ptr = win->_y[i];
-              ptr < win->_y[i] + ncols;)
-         {
-            /*
-            * Retain the original screen attributes...
-            */
-
-            *ptr++ = SP->blank;  
-         }
-      }
-   }
-   win->_flags = _PAD;
-   /*
-    * save default values in case pechochar() is the first call
-    * to prefresh().
-    */
-   save_pminrow=0;
-   save_pmincol=0;
-   save_sminrow=0;
-   save_smincol=0;
-   save_smaxrow=min(LINES,nlines)-1;
-   save_smaxcol=min(COLS,ncols)-1;
-   return( win );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-WINDOW* PDC_CDECL subpad(WINDOW* orig,int nlines,int ncols,int begin_y,int begin_x)
-#else
-WINDOW* PDC_CDECL subpad(orig,nlines,ncols,begin_y,begin_x)
-WINDOW* orig;
-int nlines;
-int ncols;
-int begin_y;
-int begin_x;
-#endif
-/***********************************************************************/
-{
-   WINDOW*  win;
-   int   i;
-   int   j = begin_y - orig->_begy;
-   int   k = begin_x - orig->_begx;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("subpad() - called: lines=%d cols=%d begy=%d begx=%d\n",nlines,ncols,begin_y,begin_x);
-#endif
-
-   if (!orig)
-      return( (WINDOW *)NULL );
-
-   if (!(orig->_flags & _PAD))
-      return( (WINDOW *)NULL );
-
-   /*
-    * make sure window fits inside the original one
-    */
-   if ((begin_y < orig->_begy) ||
-       (begin_x < orig->_begx) ||
-       (begin_y + nlines) > (orig->_begy + orig->_maxy) ||
-       (begin_x + ncols)  > (orig->_begx + orig->_maxx))
-   {
-      return( (WINDOW *)NULL );
-   }
-   if (!nlines) 
-      nlines = orig->_maxy - 1 - j;
-   if (!ncols) 
-      ncols = orig->_maxx - 1 - k;
-   if ((win = PDC_makenew(nlines, ncols, begin_y, begin_x)) == (WINDOW *) NULL)
-   {
-      return( (WINDOW *)NULL );
-   }
-
-   /*
-    * initialize window variables
-    */
-   win->_attrs = orig->_attrs;
-   win->_leaveit  = orig->_leaveit;
-   win->_scroll   = orig->_scroll;
-   win->_nodelay  = orig->_nodelay;
-   win->_use_keypad  = orig->_use_keypad;
-   win->_parent   = orig;
-
-   for (i = 0; i < nlines; i++)
-   {
-      win->_y[i] = (orig->_y[j++]) + k;
-   }
-
-   win->_flags = _SUBPAD;
-   /*
-    * save default values in case pechochar() is the first call
-    * to prefresh().
-    */
-   save_pminrow=0;
-   save_pmincol=0;
-   save_sminrow=0;
-   save_smincol=0;
-   save_smaxrow=min(LINES,nlines)-1;
-   save_smaxcol=min(COLS,ncols)-1;
-   return (win);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_CDECL prefresh(WINDOW* win,int py,int px,int sy1,int sx1,int sy2,int sx2)
-#else
-int PDC_CDECL prefresh(win,py,px,sy1,sx1,sy2,sx2)
-WINDOW* win;
-int py;
-int px;
-int sy1;
-int sx1;
-int sy2;
-int sx2;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("prefresh() - called\n");
-#endif
-
-   if (win == (WINDOW *)NULL)
-      return( ERR );
-
-   if (pnoutrefresh(win, py, px, sy1, sx1, sy2, sx2) == ERR)
-      return( ERR );
-
-   doupdate();
-   return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_CDECL pnoutrefresh(WINDOW* w,int py,int px,int sy1,int sx1,int sy2,int sx2)
-#else
-int PDC_CDECL pnoutrefresh(w,py,px,sy1,sx1,sy2,sx2)
-WINDOW* w;
-int py;
-int px;
-int sy1;
-int sx1;
-int sy2;
-int sx2;
-#endif
-/***********************************************************************/
-{
-   WINDOW*     s = curscr;
-   int      sline = sy1;
-   int      pline = py;
-   int      num_cols = min((sx2-sx1+1),(w->_maxx-px));
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("pnoutrefresh() - called\n");
-#endif
-
-
-   if (w == (WINDOW *)NULL)
-      return( ERR );
-
-   if (sy2 < sy1 || sx2 < sx1) return(ERR);
-
-   if (!(w->_flags == _PAD)
-   &&  !(w->_flags == _SUBPAD))
-      return( ERR );
-
-   while (sline <= sy2)
-   {
-      if (pline < w->_maxy)
-      {
-         memcpy(&(s->_y[sline][sx1]), &(w->_y[pline][px]), (num_cols) * sizeof(chtype));
-
-         if ((s->_firstch[sline] == _NO_CHANGE) 
-         ||  (s->_firstch[sline] > sx1))
-         {
-            s->_firstch[sline] = sx1;
-         }
-
-         if (sx2 > s->_lastch[sline])
-            s->_lastch[sline] = sx2;
-
-         w->_firstch[pline] = _NO_CHANGE;  /* updated now */
-         w->_lastch[pline] = _NO_CHANGE;  /* updated now */
-      }
-      sline++;
-      pline++;
-   }
-
-   w->_lastpy = py;
-   w->_lastpx = px;
-   w->_lastsy1 = sy1;
-   w->_lastsx1 = sx1;
-   w->_lastsy2 = sy2;
-   w->_lastsx2 = sx2;
-
-   if (w->_clear)
-   {
-      w->_clear = FALSE;
-      s->_clear = TRUE;
-   }
-
-   /* position the cursor to the pad's current position if possible */
-   if (!w->_leaveit)
-   {
-      /* is the pad current position going to end up displayed ? if not
-       * then don't move the cursor, if so move it to the correct place 
-       */
-      if (w->_cury >= py
-      &&  w->_curx >= px
-      &&  w->_cury <= py + (sy2 - sy1+1)
-      &&  w->_curx <= px + (sx2 - sx1+1))
-      {
-         s->_cury = (w->_cury - py) + sy1;
-         s->_curx = (w->_curx - px) + sx1;
-      }
-   }
-   return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_CDECL pechochar(WINDOW *pad, chtype ch)
-#else
-int PDC_CDECL pechochar(pad,ch)
-WINDOW *pad;
-chtype ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("pechochar() - called\n");
-#endif
-
-   if ( PDC_chadd( pad, ch, !(SP->raw_out), TRUE ) == ERR )
-      return(ERR);
-   return( prefresh( pad,
-                     save_pminrow,
-                     save_pmincol,
-                     save_sminrow,
-                     save_smincol,
-                     save_smaxrow,
-                     save_smaxcol ) );
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+#include <curses.h>
+
+#include <string.h>
+
+#ifdef HAVE_MEMORY_H
+# include <memory.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef newpad
+#undef subpad
+#undef prefresh
+#undef pnoutrefresh
+#undef pechochar
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+# undef doupdate
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_pad  = "$Id: pad.c,v 1.3 2002/05/26 01:12:45 mark Exp $";
+#endif
+
+/*
+ * save values for pechochar()
+ */
+static int save_pminrow;
+static int save_pmincol;
+static int save_sminrow;
+static int save_smincol;
+static int save_smaxrow;
+static int save_smaxcol;
+
+/*man-start*********************************************************************
+
+  Name:                                                           pad
+
+  Synopsis:
+    WINDOW* newpad( int nlines, int ncols );
+    WINDOW* subpad(WINDOW* orig,int nlines,int ncols,int begin_y,int begin_x);
+    int prefresh(WINDOW* win,int py,int px,int sy1,int sx1,int sy2,int sx2);
+    int pnoutrefresh(WINDOW* w,int py,int px,int sy1,int sx1,int sy2,int sx2);
+    int pechochar(WINDOW *pad, chtype ch);
+
+  X/Open Description:
+    newpad() creates a new pad data structure.  A pad is a special case
+    of a window, which is not restricted by the screen size, and is not
+    necessarily associated with a particular part of the screen.  A
+    pad can be used when a large window is needed, and only a part
+    of the window will be on the screen at one tme.  Automatic
+    refreshes of pads (e.g., from scrolling or echoing of input) do
+    not occur.  It is not legal to call refresh() with a pad as an
+    argument; the routines prefresh() or pnoutrefresh() should be
+    called instead.  Note that these routines require additional
+    parameters to specify the part of the pad to be displayed and
+    the location on the screen to be used for display.
+
+    The subpad() routine creates a new sub-pad within a pad.  The
+    dimensions of the sub-pad are nlines lines and ncols
+    columns.  The sub-pad is at position (begin_y, begin_x) in the
+    the parent pad.  This position is relative to the pad, and not
+    to the screen like with subwin.
+    The sub-pad is made in the middle of the pad orig, so
+    that changes made to either pad will affect both.  When
+    using this routine, it will often be necessary to call
+    touchwin before calling prefresh.
+
+    The prefresh() routine copies the specified pad to the physical
+    terminal screen.  It takes account of what is already
+    displayed on the screen to optimize cursor movement.
+    The pnoutrefresh() routine copies the named pad to the virtual
+    screen. It then compares the virtual screen with the physical
+    screen and performs the actual update.
+    These routines are analogous to the routines wrefresh() and
+    wnoutrefresh() except that pads, instead of windows, are
+    involved.  Additional parameters are also needed to indicate
+    what part of the pad and screen are involved. The upper left
+    corner of the part of the pad to be displayed is specified by
+    py and px.  The coordinates sy1, sx1, sy2, and sx2 specify the
+    edges of the screen rectangle that will contain the selected
+    part of the pad.
+    The lower right corner of the pad rectangle to be displayed is
+    calculated from the screen co-ordinates.  This ensures that
+    the screen rectangle and the pad rectangle are the same size.
+    Both rectangles must be entirely contained within their
+    respective structures.
+
+    The pechochar() is functionally equivalent to adch() followed
+    by a call to refresh().
+
+  PDCurses Description:
+    PDCurses (as a library) provides the developer with the ability to
+    hook in their own malloc debugging  package.  See the details in
+    INITSCR.C for details on how to accomplish this.
+
+  X/Open Return Value:
+    All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+    No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      newpad                                Y        -       Y
+      subpad                                Y        -       Y
+      prefresh                              Y        -       Y
+      pnoutrefresh                          Y        -       Y
+      pechochar                             -        -      3.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW* PDC_CDECL newpad( int nlines, int ncols )
+#else
+WINDOW* PDC_CDECL newpad(nlines,ncols)
+int nlines;
+int ncols;
+#endif
+/***********************************************************************/
+{
+#ifdef HAVE_PROTO
+   extern void* (*callc)( size_t, size_t );
+   extern void  (*fre)( void* );
+#else
+   extern void* (*callc)();
+   extern void  (*fre)();
+#endif
+
+   WINDOW* win;
+   chtype* ptr;
+   int   i;
+   int   j;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("newpad() - called: lines=%d cols=%d\n",nlines,ncols);
+#endif
+
+   if ((win = PDC_makenew( nlines, ncols, -1, -1 )) == (WINDOW *)NULL)
+      return( (WINDOW *)NULL );
+
+   for (i = 0; i < nlines; i++)
+   {
+      /*
+       * make and clear the lines
+       */
+      if ((win->_y[i] = (*callc)(ncols, sizeof(chtype))) == NULL)
+      {
+         for (j = 0; j < i; j++)
+         {
+            /*
+             * if error, free all the data
+             */
+            (*fre)(win->_y[j]);
+         }
+         (*fre)(win->_firstch);
+         (*fre)(win->_lastch);
+         (*fre)(win->_y);
+         (*fre)(win);
+         return( (WINDOW *)NULL );
+      }
+      else
+      {
+         for (ptr = win->_y[i];
+              ptr < win->_y[i] + ncols;)
+         {
+            /*
+            * Retain the original screen attributes...
+            */
+
+            *ptr++ = PDC_SP->blank;  
+         }
+      }
+   }
+   win->_flags = _PAD;
+   /*
+    * save default values in case pechochar() is the first call
+    * to prefresh().
+    */
+   save_pminrow=0;
+   save_pmincol=0;
+   save_sminrow=0;
+   save_smincol=0;
+   save_smaxrow=min(LINES,nlines)-1;
+   save_smaxcol=min(COLS,ncols)-1;
+   return( win );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW* PDC_CDECL subpad(WINDOW* orig,int nlines,int ncols,int begin_y,int begin_x)
+#else
+WINDOW* PDC_CDECL subpad(orig,nlines,ncols,begin_y,begin_x)
+WINDOW* orig;
+int nlines;
+int ncols;
+int begin_y;
+int begin_x;
+#endif
+/***********************************************************************/
+{
+   WINDOW*  win;
+   int   i;
+   int   j = begin_y - orig->_begy;
+   int   k = begin_x - orig->_begx;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("subpad() - called: lines=%d cols=%d begy=%d begx=%d\n",nlines,ncols,begin_y,begin_x);
+#endif
+
+   if (!orig)
+      return( (WINDOW *)NULL );
+
+   if (!(orig->_flags & _PAD))
+      return( (WINDOW *)NULL );
+
+   /*
+    * make sure window fits inside the original one
+    */
+   if ((begin_y < orig->_begy) ||
+       (begin_x < orig->_begx) ||
+       (begin_y + nlines) > (orig->_begy + orig->_maxy) ||
+       (begin_x + ncols)  > (orig->_begx + orig->_maxx))
+   {
+      return( (WINDOW *)NULL );
+   }
+   if (!nlines) 
+      nlines = orig->_maxy - 1 - j;
+   if (!ncols) 
+      ncols = orig->_maxx - 1 - k;
+   if ((win = PDC_makenew(nlines, ncols, begin_y, begin_x)) == (WINDOW *) NULL)
+   {
+      return( (WINDOW *)NULL );
+   }
+
+   /*
+    * initialize window variables
+    */
+   win->_attrs = orig->_attrs;
+   win->_leaveit  = orig->_leaveit;
+   win->_scroll   = orig->_scroll;
+   win->_nodelay  = orig->_nodelay;
+   win->_use_keypad  = orig->_use_keypad;
+   win->_parent   = orig;
+
+   for (i = 0; i < nlines; i++)
+   {
+      win->_y[i] = (orig->_y[j++]) + k;
+   }
+
+   win->_flags = _SUBPAD;
+   /*
+    * save default values in case pechochar() is the first call
+    * to prefresh().
+    */
+   save_pminrow=0;
+   save_pmincol=0;
+   save_sminrow=0;
+   save_smincol=0;
+   save_smaxrow=min(LINES,nlines)-1;
+   save_smaxcol=min(COLS,ncols)-1;
+   return (win);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL prefresh(WINDOW* win,int py,int px,int sy1,int sx1,int sy2,int sx2)
+#else
+int PDC_CDECL prefresh(win,py,px,sy1,sx1,sy2,sx2)
+WINDOW* win;
+int py;
+int px;
+int sy1;
+int sx1;
+int sy2;
+int sx2;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("prefresh() - called\n");
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+   if (pnoutrefresh(win, py, px, sy1, sx1, sy2, sx2) == ERR)
+      return( ERR );
+
+   doupdate();
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL pnoutrefresh(WINDOW* w,int py,int px,int sy1,int sx1,int sy2,int sx2)
+#else
+int PDC_CDECL pnoutrefresh(w,py,px,sy1,sx1,sy2,sx2)
+WINDOW* w;
+int py;
+int px;
+int sy1;
+int sx1;
+int sy2;
+int sx2;
+#endif
+/***********************************************************************/
+{
+   WINDOW*     s = curscr;
+   int      sline = sy1;
+   int      pline = py;
+   int      num_cols = min((sx2-sx1+1),(w->_maxx-px));
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("pnoutrefresh() - called\n");
+#endif
+
+
+   if (w == (WINDOW *)NULL)
+      return( ERR );
+
+   if (sy2 < sy1 || sx2 < sx1) return(ERR);
+
+   if (!(w->_flags == _PAD)
+   &&  !(w->_flags == _SUBPAD))
+      return( ERR );
+
+   while (sline <= sy2)
+   {
+      if (pline < w->_maxy)
+      {
+         memcpy(&(s->_y[sline][sx1]), &(w->_y[pline][px]), (num_cols) * sizeof(chtype));
+
+         if ((s->_firstch[sline] == _NO_CHANGE) 
+         ||  (s->_firstch[sline] > sx1))
+         {
+            s->_firstch[sline] = sx1;
+         }
+
+         if (sx2 > s->_lastch[sline])
+            s->_lastch[sline] = sx2;
+
+         w->_firstch[pline] = _NO_CHANGE;  /* updated now */
+         w->_lastch[pline] = _NO_CHANGE;  /* updated now */
+      }
+      sline++;
+      pline++;
+   }
+
+   w->_lastpy = py;
+   w->_lastpx = px;
+   w->_lastsy1 = sy1;
+   w->_lastsx1 = sx1;
+   w->_lastsy2 = sy2;
+   w->_lastsx2 = sx2;
+
+   if (w->_clear)
+   {
+      w->_clear = FALSE;
+      s->_clear = TRUE;
+   }
+
+   /* position the cursor to the pad's current position if possible */
+   if (!w->_leaveit)
+   {
+      /* is the pad current position going to end up displayed ? if not
+       * then don't move the cursor, if so move it to the correct place 
+       */
+      if (w->_cury >= py
+      &&  w->_curx >= px
+      &&  w->_cury <= py + (sy2 - sy1+1)
+      &&  w->_curx <= px + (sx2 - sx1+1))
+      {
+         s->_cury = (w->_cury - py) + sy1;
+         s->_curx = (w->_curx - px) + sx1;
+      }
+   }
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL pechochar(WINDOW *pad, chtype ch)
+#else
+int PDC_CDECL pechochar(pad,ch)
+WINDOW *pad;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("pechochar() - called\n");
+#endif
+
+   if ( PDC_chadd( pad, ch, !(PDC_SP->raw_out), TRUE ) == ERR )
+      return(ERR);
+   return( prefresh( pad,
+                     save_pminrow,
+                     save_pmincol,
+                     save_sminrow,
+                     save_smincol,
+                     save_smaxrow,
+                     save_smaxcol ) );
+}
Index: PDCurses/pdcurses/move.c
===================================================================
--- PDCurses/pdcurses/move.c	(revision 1)
+++ PDCurses/pdcurses/move.c	(working copy)
@@ -1,123 +1,123 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	move
-#undef	wmove
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_move  = "$Id: move.c,v 1.1 2001/01/10 08:27:16 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                          move
-
-  Synopsis:
-  	int move(int y, int x);
-  	int wmove(WINDOW *win, int y, int x);
-
-  X/Open Description:
- 	The cursor associated with the window is moved to the given
- 	location.  This does not move the physical cursor of the
- 	terminal until refresh() is called.  The position specified is
- 	relative to the upper left corner of the window, which is (0,0).
-
- 	NOTE: move() is a macro.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      move                                  Y        Y       Y
-      wmove                                 Y        Y       Y
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	move(int y, int x)
-#else
-int	PDC_CDECL	move(y,x)
-int y;
-int x;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("move() - called: y=%d x=%d\n",y,x);
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	if ((x < 0) ||
-	    (y < 0) ||
-	    (x >= stdscr->_maxx) ||
-	    (y >= stdscr->_maxy))
-	{
-		return( ERR );
-	}
-	stdscr->_curx = x;
-	stdscr->_cury = y;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	wmove(WINDOW *win, int y, int x)
-#else
-int	PDC_CDECL	wmove(win,y,x)
-WINDOW *win;
-int y;
-int x;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wmove() - called: y=%d x=%d\n",y,x);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if ((x < 0) ||
-	    (y < 0) ||
-	    (x >= win->_maxx) ||
-	    (y >= win->_maxy))
-	{
-		return( ERR );
-	}
-	win->_curx = x;
-	win->_cury = y;
-	return( OK );
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	move
+#undef	wmove
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_move  = "$Id: move.c,v 1.1 2001/01/10 08:27:16 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                          move
+
+  Synopsis:
+  	int move(int y, int x);
+  	int wmove(WINDOW *win, int y, int x);
+
+  X/Open Description:
+ 	The cursor associated with the window is moved to the given
+ 	location.  This does not move the physical cursor of the
+ 	terminal until refresh() is called.  The position specified is
+ 	relative to the upper left corner of the window, which is (0,0).
+
+ 	NOTE: move() is a macro.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      move                                  Y        Y       Y
+      wmove                                 Y        Y       Y
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	move(int y, int x)
+#else
+int	PDC_CDECL	move(y,x)
+int y;
+int x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("move() - called: y=%d x=%d\n",y,x);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if ((x < 0) ||
+	    (y < 0) ||
+	    (x >= stdscr->_maxx) ||
+	    (y >= stdscr->_maxy))
+	{
+		return( ERR );
+	}
+	stdscr->_curx = x;
+	stdscr->_cury = y;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wmove(WINDOW *win, int y, int x)
+#else
+int	PDC_CDECL	wmove(win,y,x)
+WINDOW *win;
+int y;
+int x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wmove() - called: y=%d x=%d\n",y,x);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if ((x < 0) ||
+	    (y < 0) ||
+	    (x >= win->_maxx) ||
+	    (y >= win->_maxy))
+	{
+		return( ERR );
+	}
+	win->_curx = x;
+	win->_cury = y;
+	return( OK );
+}
Index: PDCurses/pdcurses/window.c
===================================================================
--- PDCurses/pdcurses/window.c	(revision 1)
+++ PDCurses/pdcurses/window.c	(working copy)
@@ -1,743 +1,743 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	newwin
-#undef	delwin
-#undef	mvwin
-#undef	subwin
-#undef	derwin
-#undef	mvderwin
-#undef	dupwin
-#undef	wsyncup
-#undef	syncok
-#undef	wcursyncup
-#undef	wsyncdown
-#undef	resize_window
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef	touchwin
-#  undef	wmove
-#  undef	overwrite
-#  undef	wmove
-#  undef	wclrtobot
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_window  = "$Id: window.c,v 1.2 2002/12/16 06:59:12 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                        window
-
-  Synopsis:
-  	WINDOW *newwin(int nlines, int ncols, int begy, int begx);
-  	int delwin(WINDOW *win);
-  	int mvwin(WINDOW *win, int y, int x);
-  	WINDOW *subwin(WINDOW* orig,int nlines,int ncols,
-  			int begin_y,int begin_x);
-  	WINDOW *derwin(WINDOW* orig,int nlines,int ncols,
-  			int begin_y,int begin_x);
-  	int mvderwin(WINDOW *win, int par_y, int par_x);
-  	int dupwin(WINDOW *win);
-  	void wsyncup(WINDOW *win);
-  	int syncok(WINDOW *win, bool bf);
-  	void wcursyncup(WINDOW *win);
-  	void wsyncdown(WINDOW *win);
-
-  	WINDOW *resize_window(WINDOW *w, int lins, int cols);
-
-  X/Open Description:
- 	newwin() creates a new window with the given number of lines, 
- 	nlines and columns, ncols. The upper left corner of the window is 
- 	at line begy, column begx. If either nlines or ncols is zero,
- 	they will be defaulted to LINES - begy and COLS - begx. A
- 	new full-screen window is created by calling newwin(0, 0, 0, 0).
-
- 	delwin() deletes the named window, freeing all memory associated 
- 	with it. In the case of overlapping windows, subwindows should be 
- 	deleted before the main window.
-
- 	mvwin() moves the window so that the upper left-hand corner is at
- 	position (y,x). If the move would cause the window to be off the
- 	screen, it is an error and the window is not moved. Moving subwindows
- 	is allowed, but should be avoided. (I don't know why ?).
-
- 	subwin() creates a new sub-window within a window.  The
- 	dimensions of the sub-window are nlines lines and ncols
- 	columns.  The sub-window is at position (begin_y, begin_x) on
- 	the screen.  This position is relative to the screen, and not
- 	to the window orig.
- 	The sub-window is made in the middle of the window orig, so
- 	that changes made to either window will affect both.  When
- 	using this routine, it will often be necessary to call
- 	touchwin() before calling wrefresh().
-
- 	derwin() is the same as subwin(), except that begin_y and
- 	begin_x are relative to the origin of the window orig rather than
- 	the screen.  There is no difference between subwindows and derived
- 	windows.
-
- 	mvderwin() moves a derived window (or subwindow) inside its
- 	parent window.  The screen-relative parameters of the window are not
- 	changed.  This routine is used to display different parts of the parent
- 	window at the same physical position on the screen.
-
- 	dupwin() creates an exact duplicate of the window win.
-
- 	wsyncup() causes a touchwin() of all of the window's parents.
-
- 	If wsyncok() is called with a second argument of TRUE, this causes 
- 	a wsyncup() to be called every time the window is changed.
-
- 	wcursyncup() causes the current cursor position of all of a window's
- 	ancestors to reflect the current cursor position of the current window.
-
- 	wsyncdown() causes a touchwin() of the current window if any of 
- 	its parent's windows have been touched.
-
-  PDCurses Description:
- 	resize_window() allows the usrer to resize an existing window.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  PDCurses Errors:
- 	It is an error to call resize_window() before calling initscr().
- 	Also, an error will be generated if we fail to create a newly
- 	sized replacement window for curscr, or stdscr.
- 	This will typically happen when increasing the window size.
-
- 	NOTE:  If this happens, the previously successfully allocated
- 	windows are left alone.  i.e. The resize is NOT cancelled for
- 	those windows.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      newwin                                Y        Y       Y
-      delwin                                Y        Y       Y
-      mvwin                                 Y        Y       Y
-      subwin                                Y        Y       Y
-      derwin                                Y        -       Y
-      mvderwin                              Y        -       Y
-      dupwin                                -        -      4.0
-      wsyncup                               -        -      4.0
-      syncok                                -        -      4.0
-      wcursyncup                            -        -      4.0
-      wsyncdown                             -        -      4.0
-      resize_window                         -        -       -
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-WINDOW*	PDC_CDECL	newwin(int nlines, int ncols, int begy, int begx)
-#else
-WINDOW*	PDC_CDECL	newwin(nlines,ncols,begy,begx)
-int nlines;
-int ncols;
-int begy;
-int begx;
-#endif
-/***********************************************************************/
-{
-#ifdef HAVE_PROTO
-extern	void*	(*callc)( size_t, size_t );
-extern	void	(*fre)( void* );
-#else
-extern	void*	(*callc)();
-extern	void	(*fre)();
-#endif
-
-	WINDOW*	win;
-	chtype*	ptr;
-	int	i;
-	int	j;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("newwin() - called:lines=%d cols=%d begy=%d begx=%d\n",nlines,ncols,begy,begx);
-#endif
-
-	if (nlines == 0)	nlines = LINES - begy;
-	if (ncols  == 0)	ncols  = COLS  - begx;
-
-	if (begy + nlines > SP->lines
-	||  begx + ncols > SP->cols)
-		return( (WINDOW *)NULL );
-
-	if ((win = PDC_makenew(nlines, ncols, begy, begx)) == (WINDOW *) NULL)
-		return( (WINDOW *)NULL );
-
-	for (i = 0; i < nlines; i++)
-	{
-		/*
-		 * make and clear the lines
-		 */
-		if ((win->_y[i] = (*callc)(ncols, sizeof(chtype))) == NULL)
-		{
-			for (j = 0; j < i; j++)
-			{
-				/*
-				 * if error, free all the data
-				 */
-				(*fre)(win->_y[j]);
-			}
-			(*fre)(win->_firstch);
-			(*fre)(win->_lastch);
-			(*fre)(win->_y);
-			(*fre)(win);
-			return( (WINDOW *)NULL );
-		}
-		else
-		{
-			for (ptr = win->_y[i];
-			     ptr < win->_y[i] + ncols;)
-			{
-				/*
-				 * Retain the original screen attributes...
-				 */
-				*ptr++ = SP->blank;
-			}
-		}
-	}
-#ifdef UNIX
-	PDC_gotoxy(begy, begx);
-#endif
-	return( win );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	delwin(WINDOW *win)
-#else
-int	PDC_CDECL	delwin(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-#ifdef HAVE_PROTO
-extern	void	(*fre)( void* );
-#else
-extern	void	(*fre)();
-#endif
-	int	i;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("delwin() - called\n");
-#endif
-
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-#ifdef	REGISTERWINDOWS
-	_rmwin(win);		/* Remove from the visible windows list... */
-#endif
-
-	/*
-	 * FYI:  Subwindow's use 'parent's' lines
-	 */
-	if (!(win->_flags & _SUBWIN)
-	&&  !(win->_flags & _SUBPAD))
-	{
-		for (i = 0; i < win->_pmaxy && win->_y[i]; i++)
-		{
-			if (win->_y[i] != NULL)
-				(*fre)(win->_y[i]);
-		}
-	}
-	(*fre)(win->_firstch);
-	(*fre)(win->_lastch);
-	(*fre)(win->_y);
-	(*fre)(win);
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvwin(WINDOW *win, int y, int x)
-#else
-int	PDC_CDECL	mvwin(win,y,x)
-WINDOW *win;
-int y;
-int x;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvwin() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if (y + win->_maxy > LINES || y < 0)
-		return( ERR );
-
-	if (x + win->_maxx > COLS || x < 0)
-		return( ERR );
-
-	win->_begy = y;
-	win->_begx = x;
-	touchwin(win);
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-WINDOW*	PDC_CDECL	subwin(WINDOW* orig,int nlines,int ncols,int begin_y,int begin_x)
-#else
-WINDOW*	PDC_CDECL	subwin(orig,nlines,ncols,begin_y,begin_x)
-WINDOW* orig;
-int nlines;
-int ncols;
-int begin_y;
-int begin_x;
-#endif
-/***********************************************************************/
-{
-	WINDOW*	win;
-	int	i;
-	int	j = begin_y - orig->_begy;
-	int	k = begin_x - orig->_begx;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("subwin() - called: lines %d cols %d begy %d begx %d\n",nlines,ncols,begin_y,begin_x);
-#endif
-
-	if (!orig)
-		return( (WINDOW *)NULL );
-
-	/*
-	 * make sure window fits inside the original one
-	 */
-	if ((begin_y < orig->_begy) ||
-	    (begin_x < orig->_begx) ||
-	    (begin_y + nlines) > (orig->_begy + orig->_maxy) ||
-	    (begin_x + ncols)  > (orig->_begx + orig->_maxx))
-	{
-		return( (WINDOW *)NULL );
-	}
-	if (!nlines)	nlines = orig->_maxy - 1 - j;
-	if (!ncols)	ncols  = orig->_maxx - 1 - k;
-	if ((win = PDC_makenew(nlines, ncols, begin_y, begin_x)) == (WINDOW *) NULL)
-	{
-		return( (WINDOW *)NULL );
-	}
-
-	/*
-	 * initialize window variables
-	 */
-	win->_attrs	= orig->_attrs;
-/* wrs (4/10/93) -- account for window background */
-	win->_bkgd	= orig->_bkgd;
-	win->_leaveit	= orig->_leaveit;
-	win->_scroll	= orig->_scroll;
-	win->_nodelay	= orig->_nodelay;
-	win->_use_keypad	= orig->_use_keypad;
-	win->_immed	= orig->_immed;
-	win->_sync	= orig->_sync;
-	win->_pary	= j;
-	win->_parx	= k;
-	win->_parent	= orig;
-
-	for (i = 0; i < nlines; i++)
-	{
-		win->_y[i] = (orig->_y[j++]) + k;
-	}
-
-	win->_flags |= _SUBWIN;
-	return (win);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-WINDOW*	PDC_CDECL	derwin(WINDOW* orig,int nlines,int ncols,int begin_y,int begin_x)
-#else
-WINDOW*	PDC_CDECL	derwin(orig,nlines,ncols,begin_y,begin_x)
-WINDOW* orig;
-int nlines;
-int ncols;
-int begin_y;
-int begin_x;
-#endif
-/***********************************************************************/
-{
-	if (orig == (WINDOW *)NULL)
-		return( ERR );
-
-	return subwin(orig, nlines, ncols, begin_y+orig->_begy, begin_x+orig->_begx);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvderwin( WINDOW* win, int par_y, int par_x )
-#else
-int	PDC_CDECL	mvderwin(win,par_y,par_x)
-WINDOW* win;
-int par_y;
-int par_x;
-#endif
-/***********************************************************************/
-{
-	int i, j;
-	WINDOW *mypar;
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if( win->_parent == NULL )
-		return( ERR );
-
-	mypar = win->_parent;
-
-	if( par_y < 0 || par_x < 0 ||
-		(par_y + win->_maxy) > mypar->_maxy ||
-		(par_x + win->_maxx) > mypar->_maxx )
-	{
-		return( ERR );
-	}
-
-	j = par_y;
-	for (i = 0; i < win->_maxy; i++)
-	{
-		win->_y[i] = (mypar->_y[j++]) + par_x;
-	}
-
-	win->_pary	= par_y;
-	win->_parx	= par_x;
-
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-WINDOW*	PDC_CDECL	dupwin( WINDOW* win )
-#else
-WINDOW*	PDC_CDECL	dupwin(win)
-WINDOW* win;
-#endif
-/***********************************************************************/
-{
-#ifdef HAVE_PROTO
-extern	void*	(*callc)( size_t, size_t );
-extern	void	(*fre)( void* );
-#else
-extern	void*	(*callc)();
-extern	void	(*fre)();
-#endif
-
-	WINDOW* new;
-	chtype* ptr;
-	chtype* ptr1;
-	int nlines, ncols, begy, begx;
-	int	i;
-	int	j;
-
-	if (!win)
-		return( (WINDOW *)NULL );
-
-	nlines	= win->_maxy;
-	ncols	= win->_maxx;
-	begy	= win->_begy;
-	begx	= win->_begx;
-
-	if ((new = PDC_makenew(nlines, ncols, begy, begx)) == (WINDOW *) NULL)
-		return( (WINDOW *)NULL );
-
-/* copy the contents of win into new */
-
-	for (i = 0; i < nlines; i++)
-	{
-		if ((new->_y[i] = (*callc)(ncols, sizeof(chtype))) == NULL)
-		{
-			for (j = 0; j < i; j++)
-			{
-				/*
-				 * if error, free all the data
-				 */
-				(*fre)(new->_y[j]);
-			}
-			(*fre)(new->_firstch);
-			(*fre)(new->_lastch);
-			(*fre)(new->_y);
-			(*fre)(new);
-			return( (WINDOW *)NULL );
-		}
-		else
-		{
-			for (ptr = new->_y[i], ptr1 = win->_y[i];
-			     ptr < new->_y[i] + ncols;)
-			{
-				*ptr++ = *ptr1++;
-			}
-		}
-	}
-
-	new->_curx = win->_curx;
-	new->_cury = win->_cury;
-	new->_maxy = win->_maxy;
-	new->_maxx = win->_maxx;
-	new->_pmaxy = win->_pmaxy;
-	new->_pmaxx = win->_pmaxx;
-	new->_begy = win->_begy;
-	new->_begx = win->_begx;
-	new->_lastpy = win->_lastpy;
-	new->_lastpx = win->_lastpx;
-	new->_lastsy1 = win->_lastsy1;
-	new->_lastsx1 = win->_lastsx1;
-	new->_lastsy2 = win->_lastsy2;
-	new->_lastsx2 = win->_lastsx2;
-	new->_flags = win->_flags;
-	new->_attrs = win->_attrs;
-	new->_tabsize = win->_tabsize;
-	new->_clear = win->_clear;
-	new->_leaveit = win->_leaveit;
-	new->_scroll = win->_scroll;
-	new->_nodelay = win->_nodelay;
-	new->_use_keypad = win->_use_keypad;
-	new->_use_idl = win->_use_idl;
-	new->_use_idc = win->_use_idc;
-	new->_tmarg = win->_tmarg;
-	new->_bmarg = win->_bmarg;
-	new->_title = win->_title;
-	new->_title_ofs = win->_title_ofs;
-	new->_title_attr = win->_title_attr;
-	new->_blank = win->_blank;
-	new->_parx = win->_parx;
-	new->_pary = win->_pary;
-	new->_parent = win->_parent;
-	new->_bkgd = win->_bkgd;
-
-	for (i = 0; i < nlines; i++)
-	{
-		new->_firstch[i] = 0;
-		new->_lastch[i] = ncols - 1;
-	}
-
-	new->_flags = win->_flags;
-
-	return( new );
-
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-WINDOW *	PDC_CDECL	resize_window(WINDOW *win, int lins, int cols)
-#else
-WINDOW *	PDC_CDECL	resize_window(win,lins,cols)
-WINDOW *win;
-int lins;
-int cols;
-#endif
-/***********************************************************************/
-{
-#ifdef HAVE_PROTO
-extern	void*	(*callc)( size_t, size_t );
-extern	void	(*fre)( void* );
-#else
-extern	void*	(*callc)();
-extern	void	(*fre)();
-#endif
-
-	WINDOW*	new;
-	int	i;
-	int	j;
-	int	save_cury=0,save_curx=0;
-	int	new_begy=0,new_begx=0;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("resize_window() - called: lins %d cols %d\n",lins,cols);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( (WINDOW *)NULL );
-
-	if (win == SP->slk_winptr)
-	{
-		new_begy = SP->lines-SP->slklines;
-		new_begx = 0;
-	}
-	else
-	{
-		new_begy = win->_begy;
-		new_begx = win->_begx;
-	}
-
-	if ((new = PDC_makenew(lins, cols, new_begy, new_begx)) == (WINDOW *)NULL)
-		return( (WINDOW *)NULL );
-
-	new->_curx = min(win->_curx,new->_maxx);
-	new->_cury = min(win->_cury,new->_maxy);
-	new->_flags = win->_flags;
-	new->_attrs = win->_attrs;
-	new->_tabsize = win->_tabsize;
-	new->_clear = win->_clear;
-	new->_leaveit = win->_leaveit;
-	new->_scroll = win->_scroll;
-	new->_nodelay = win->_nodelay;
-	new->_use_keypad = win->_use_keypad;
-	new->_tmarg = (win->_tmarg > new->_maxy-1) ? 0 : win->_tmarg;
-	new->_bmarg = (win->_bmarg == win->_maxy-1) ? new->_maxy-1 : min(win->_bmarg,(new->_maxy-1));
-	new->_title = win->_title;
-	new->_title_ofs = win->_title_ofs;
-	new->_title_attr = win->_title_attr;
-	new->_parent = win->_parent;
-	new->_immed = win->_immed;
-	new->_sync = win->_sync;
-
-	for (i = 0; i < lins; i++)
-	{
-		/*
-		 * make and clear the lines
-		 */
-		if ((new->_y[i] = (chtype*)(*callc)(cols, sizeof(chtype))) == NULL)
-		{
-			for (j = 0; j < i; j++)
-			{
-				/*
-				 * if error, free all the data
-				 */
-				(*fre)(new->_y[j]);
-			}
-			(*fre)(new->_firstch);
-			(*fre)(new->_lastch);
-			(*fre)(new->_y);
-			(*fre)(new);
-			return( (WINDOW *)NULL );
-		}
-		new->_firstch[i] = new->_lastch[i] = _NO_CHANGE;
-	}
-
-	if (win != curscr
-	&&  win != SP->slk_winptr)
-	{
-		copywin(win, new, 0, 0, 0, 0, min(win->_maxy,new->_maxy), min(win->_maxx,new->_maxx),FALSE);
-		if (new->_maxy > win->_maxy)
-		{
-			save_cury = new->_cury;
-			save_curx = new->_curx;
-			wmove(new, new->_maxy - 1, 0);
-			wclrtobot(new);
-			new->_cury = save_cury;
-			new->_curx = save_curx;
-		}
-#if 0
-/* JGB box uses defaults if arguments are zero, but we don't want to do
-   this if the window currently has no box */
-		if (win->_borderchars[0] || win->_borderchars[2])
-			box(new, win->_borderchars[0], win->_borderchars[2]);
-#endif
-	}
-
-
-	delwin(win);
-	return(new);
-
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-void	PDC_CDECL	wsyncup(WINDOW *win)
-#else
-void	PDC_CDECL	wsyncup(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-	WINDOW *tmp=(WINDOW *)NULL;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wsyncup() - called\n");
-#endif
-
-	for (tmp = win; tmp != (WINDOW *)NULL; tmp = tmp->_parent) 
-	{
-		touchwin(tmp);
-	}
-	return;
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	syncok(WINDOW *win, bool bf)
-#else
-int	PDC_CDECL	syncok(win,bf)
-WINDOW *win;
-bool bf;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("syncok() - called\n");
-#endif
-	if (win == (WINDOW *)NULL)
-		return(ERR);
-
-	win->_sync = bf;
-	return(OK);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-void	PDC_CDECL	wcursyncup(WINDOW *win)
-#else
-void	PDC_CDECL	wcursyncup(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-	WINDOW *tmp=(WINDOW *)NULL;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wcursyncup() - called\n");
-#endif
-
-	for( tmp = win; (tmp != (WINDOW *)NULL) && (tmp->_parent != (WINDOW *)NULL); tmp = tmp->_parent )
-	{
-		wmove( tmp->_parent, tmp->_pary + tmp->_cury, tmp->_parx + tmp->_curx );
-	}
-	return;
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-void	PDC_CDECL	wsyncdown(WINDOW *win)
-#else
-void	PDC_CDECL	wsyncdown(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-	WINDOW *tmp=(WINDOW *)NULL;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wsyncdown() - called\n");
-#endif
-
-	for (tmp = win; tmp != (WINDOW *)NULL; tmp = tmp->_parent) 
-	{
-		if (is_wintouched(tmp)) 
-		{
-			touchwin(win);
-			break;
-		}
-	}
-	return;
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	newwin
+#undef	delwin
+#undef	mvwin
+#undef	subwin
+#undef	derwin
+#undef	mvderwin
+#undef	dupwin
+#undef	wsyncup
+#undef	syncok
+#undef	wcursyncup
+#undef	wsyncdown
+#undef	resize_window
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	touchwin
+#  undef	wmove
+#  undef	overwrite
+#  undef	wmove
+#  undef	wclrtobot
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_window  = "$Id: window.c,v 1.2 2002/12/16 06:59:12 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        window
+
+  Synopsis:
+  	WINDOW *newwin(int nlines, int ncols, int begy, int begx);
+  	int delwin(WINDOW *win);
+  	int mvwin(WINDOW *win, int y, int x);
+  	WINDOW *subwin(WINDOW* orig,int nlines,int ncols,
+  			int begin_y,int begin_x);
+  	WINDOW *derwin(WINDOW* orig,int nlines,int ncols,
+  			int begin_y,int begin_x);
+  	int mvderwin(WINDOW *win, int par_y, int par_x);
+  	int dupwin(WINDOW *win);
+  	void wsyncup(WINDOW *win);
+  	int syncok(WINDOW *win, bool bf);
+  	void wcursyncup(WINDOW *win);
+  	void wsyncdown(WINDOW *win);
+
+  	WINDOW *resize_window(WINDOW *w, int lins, int cols);
+
+  X/Open Description:
+ 	newwin() creates a new window with the given number of lines, 
+ 	nlines and columns, ncols. The upper left corner of the window is 
+ 	at line begy, column begx. If either nlines or ncols is zero,
+ 	they will be defaulted to LINES - begy and COLS - begx. A
+ 	new full-screen window is created by calling newwin(0, 0, 0, 0).
+
+ 	delwin() deletes the named window, freeing all memory associated 
+ 	with it. In the case of overlapping windows, subwindows should be 
+ 	deleted before the main window.
+
+ 	mvwin() moves the window so that the upper left-hand corner is at
+ 	position (y,x). If the move would cause the window to be off the
+ 	screen, it is an error and the window is not moved. Moving subwindows
+ 	is allowed, but should be avoided. (I don't know why ?).
+
+ 	subwin() creates a new sub-window within a window.  The
+ 	dimensions of the sub-window are nlines lines and ncols
+ 	columns.  The sub-window is at position (begin_y, begin_x) on
+ 	the screen.  This position is relative to the screen, and not
+ 	to the window orig.
+ 	The sub-window is made in the middle of the window orig, so
+ 	that changes made to either window will affect both.  When
+ 	using this routine, it will often be necessary to call
+ 	touchwin() before calling wrefresh().
+
+ 	derwin() is the same as subwin(), except that begin_y and
+ 	begin_x are relative to the origin of the window orig rather than
+ 	the screen.  There is no difference between subwindows and derived
+ 	windows.
+
+ 	mvderwin() moves a derived window (or subwindow) inside its
+ 	parent window.  The screen-relative parameters of the window are not
+ 	changed.  This routine is used to display different parts of the parent
+ 	window at the same physical position on the screen.
+
+ 	dupwin() creates an exact duplicate of the window win.
+
+ 	wsyncup() causes a touchwin() of all of the window's parents.
+
+ 	If wsyncok() is called with a second argument of TRUE, this causes 
+ 	a wsyncup() to be called every time the window is changed.
+
+ 	wcursyncup() causes the current cursor position of all of a window's
+ 	ancestors to reflect the current cursor position of the current window.
+
+ 	wsyncdown() causes a touchwin() of the current window if any of 
+ 	its parent's windows have been touched.
+
+  PDCurses Description:
+ 	resize_window() allows the usrer to resize an existing window.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  PDCurses Errors:
+ 	It is an error to call resize_window() before calling initscr().
+ 	Also, an error will be generated if we fail to create a newly
+ 	sized replacement window for curscr, or stdscr.
+ 	This will typically happen when increasing the window size.
+
+ 	NOTE:  If this happens, the previously successfully allocated
+ 	windows are left alone.  i.e. The resize is NOT cancelled for
+ 	those windows.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      newwin                                Y        Y       Y
+      delwin                                Y        Y       Y
+      mvwin                                 Y        Y       Y
+      subwin                                Y        Y       Y
+      derwin                                Y        -       Y
+      mvderwin                              Y        -       Y
+      dupwin                                -        -      4.0
+      wsyncup                               -        -      4.0
+      syncok                                -        -      4.0
+      wcursyncup                            -        -      4.0
+      wsyncdown                             -        -      4.0
+      resize_window                         -        -       -
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW*	PDC_CDECL	newwin(int nlines, int ncols, int begy, int begx)
+#else
+WINDOW*	PDC_CDECL	newwin(nlines,ncols,begy,begx)
+int nlines;
+int ncols;
+int begy;
+int begx;
+#endif
+/***********************************************************************/
+{
+#ifdef HAVE_PROTO
+extern	void*	(*callc)( size_t, size_t );
+extern	void	(*fre)( void* );
+#else
+extern	void*	(*callc)();
+extern	void	(*fre)();
+#endif
+
+	WINDOW*	win;
+	chtype*	ptr;
+	int	i;
+	int	j;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("newwin() - called:lines=%d cols=%d begy=%d begx=%d\n",nlines,ncols,begy,begx);
+#endif
+
+	if (nlines == 0)	nlines = LINES - begy;
+	if (ncols  == 0)	ncols  = COLS  - begx;
+
+	if (begy + nlines > PDC_SP->lines
+	||  begx + ncols > PDC_SP->cols)
+		return( (WINDOW *)NULL );
+
+	if ((win = PDC_makenew(nlines, ncols, begy, begx)) == (WINDOW *) NULL)
+		return( (WINDOW *)NULL );
+
+	for (i = 0; i < nlines; i++)
+	{
+		/*
+		 * make and clear the lines
+		 */
+		if ((win->_y[i] = (*callc)(ncols, sizeof(chtype))) == NULL)
+		{
+			for (j = 0; j < i; j++)
+			{
+				/*
+				 * if error, free all the data
+				 */
+				(*fre)(win->_y[j]);
+			}
+			(*fre)(win->_firstch);
+			(*fre)(win->_lastch);
+			(*fre)(win->_y);
+			(*fre)(win);
+			return( (WINDOW *)NULL );
+		}
+		else
+		{
+			for (ptr = win->_y[i];
+			     ptr < win->_y[i] + ncols;)
+			{
+				/*
+				 * Retain the original screen attributes...
+				 */
+				*ptr++ = PDC_SP->blank;
+			}
+		}
+	}
+#ifdef UNIX
+	PDC_gotoxy(begy, begx);
+#endif
+	return( win );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	delwin(WINDOW *win)
+#else
+int	PDC_CDECL	delwin(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef HAVE_PROTO
+extern	void	(*fre)( void* );
+#else
+extern	void	(*fre)();
+#endif
+	int	i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("delwin() - called\n");
+#endif
+
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+#ifdef	REGISTERWINDOWS
+	_rmwin(win);		/* Remove from the visible windows list... */
+#endif
+
+	/*
+	 * FYI:  Subwindow's use 'parent's' lines
+	 */
+	if (!(win->_flags & _SUBWIN)
+	&&  !(win->_flags & _SUBPAD))
+	{
+		for (i = 0; i < win->_pmaxy && win->_y[i]; i++)
+		{
+			if (win->_y[i] != NULL)
+				(*fre)(win->_y[i]);
+		}
+	}
+	(*fre)(win->_firstch);
+	(*fre)(win->_lastch);
+	(*fre)(win->_y);
+	(*fre)(win);
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwin(WINDOW *win, int y, int x)
+#else
+int	PDC_CDECL	mvwin(win,y,x)
+WINDOW *win;
+int y;
+int x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwin() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (y + win->_maxy > LINES || y < 0)
+		return( ERR );
+
+	if (x + win->_maxx > COLS || x < 0)
+		return( ERR );
+
+	win->_begy = y;
+	win->_begx = x;
+	touchwin(win);
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW*	PDC_CDECL	subwin(WINDOW* orig,int nlines,int ncols,int begin_y,int begin_x)
+#else
+WINDOW*	PDC_CDECL	subwin(orig,nlines,ncols,begin_y,begin_x)
+WINDOW* orig;
+int nlines;
+int ncols;
+int begin_y;
+int begin_x;
+#endif
+/***********************************************************************/
+{
+	WINDOW*	win;
+	int	i;
+	int	j = begin_y - orig->_begy;
+	int	k = begin_x - orig->_begx;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("subwin() - called: lines %d cols %d begy %d begx %d\n",nlines,ncols,begin_y,begin_x);
+#endif
+
+	if (!orig)
+		return( (WINDOW *)NULL );
+
+	/*
+	 * make sure window fits inside the original one
+	 */
+	if ((begin_y < orig->_begy) ||
+	    (begin_x < orig->_begx) ||
+	    (begin_y + nlines) > (orig->_begy + orig->_maxy) ||
+	    (begin_x + ncols)  > (orig->_begx + orig->_maxx))
+	{
+		return( (WINDOW *)NULL );
+	}
+	if (!nlines)	nlines = orig->_maxy - 1 - j;
+	if (!ncols)	ncols  = orig->_maxx - 1 - k;
+	if ((win = PDC_makenew(nlines, ncols, begin_y, begin_x)) == (WINDOW *) NULL)
+	{
+		return( (WINDOW *)NULL );
+	}
+
+	/*
+	 * initialize window variables
+	 */
+	win->_attrs	= orig->_attrs;
+/* wrs (4/10/93) -- account for window background */
+	win->_bkgd	= orig->_bkgd;
+	win->_leaveit	= orig->_leaveit;
+	win->_scroll	= orig->_scroll;
+	win->_nodelay	= orig->_nodelay;
+	win->_use_keypad	= orig->_use_keypad;
+	win->_immed	= orig->_immed;
+	win->_sync	= orig->_sync;
+	win->_pary	= j;
+	win->_parx	= k;
+	win->_parent	= orig;
+
+	for (i = 0; i < nlines; i++)
+	{
+		win->_y[i] = (orig->_y[j++]) + k;
+	}
+
+	win->_flags |= _SUBWIN;
+	return (win);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW*	PDC_CDECL	derwin(WINDOW* orig,int nlines,int ncols,int begin_y,int begin_x)
+#else
+WINDOW*	PDC_CDECL	derwin(orig,nlines,ncols,begin_y,begin_x)
+WINDOW* orig;
+int nlines;
+int ncols;
+int begin_y;
+int begin_x;
+#endif
+/***********************************************************************/
+{
+	if (orig == (WINDOW *)NULL)
+		return( ERR );
+
+	return subwin(orig, nlines, ncols, begin_y+orig->_begy, begin_x+orig->_begx);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvderwin( WINDOW* win, int par_y, int par_x )
+#else
+int	PDC_CDECL	mvderwin(win,par_y,par_x)
+WINDOW* win;
+int par_y;
+int par_x;
+#endif
+/***********************************************************************/
+{
+	int i, j;
+	WINDOW *mypar;
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if( win->_parent == NULL )
+		return( ERR );
+
+	mypar = win->_parent;
+
+	if( par_y < 0 || par_x < 0 ||
+		(par_y + win->_maxy) > mypar->_maxy ||
+		(par_x + win->_maxx) > mypar->_maxx )
+	{
+		return( ERR );
+	}
+
+	j = par_y;
+	for (i = 0; i < win->_maxy; i++)
+	{
+		win->_y[i] = (mypar->_y[j++]) + par_x;
+	}
+
+	win->_pary	= par_y;
+	win->_parx	= par_x;
+
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW*	PDC_CDECL	dupwin( WINDOW* win )
+#else
+WINDOW*	PDC_CDECL	dupwin(win)
+WINDOW* win;
+#endif
+/***********************************************************************/
+{
+#ifdef HAVE_PROTO
+extern	void*	(*callc)( size_t, size_t );
+extern	void	(*fre)( void* );
+#else
+extern	void*	(*callc)();
+extern	void	(*fre)();
+#endif
+
+	WINDOW* new;
+	chtype* ptr;
+	chtype* ptr1;
+	int nlines, ncols, begy, begx;
+	int	i;
+	int	j;
+
+	if (!win)
+		return( (WINDOW *)NULL );
+
+	nlines	= win->_maxy;
+	ncols	= win->_maxx;
+	begy	= win->_begy;
+	begx	= win->_begx;
+
+	if ((new = PDC_makenew(nlines, ncols, begy, begx)) == (WINDOW *) NULL)
+		return( (WINDOW *)NULL );
+
+/* copy the contents of win into new */
+
+	for (i = 0; i < nlines; i++)
+	{
+		if ((new->_y[i] = (*callc)(ncols, sizeof(chtype))) == NULL)
+		{
+			for (j = 0; j < i; j++)
+			{
+				/*
+				 * if error, free all the data
+				 */
+				(*fre)(new->_y[j]);
+			}
+			(*fre)(new->_firstch);
+			(*fre)(new->_lastch);
+			(*fre)(new->_y);
+			(*fre)(new);
+			return( (WINDOW *)NULL );
+		}
+		else
+		{
+			for (ptr = new->_y[i], ptr1 = win->_y[i];
+			     ptr < new->_y[i] + ncols;)
+			{
+				*ptr++ = *ptr1++;
+			}
+		}
+	}
+
+	new->_curx = win->_curx;
+	new->_cury = win->_cury;
+	new->_maxy = win->_maxy;
+	new->_maxx = win->_maxx;
+	new->_pmaxy = win->_pmaxy;
+	new->_pmaxx = win->_pmaxx;
+	new->_begy = win->_begy;
+	new->_begx = win->_begx;
+	new->_lastpy = win->_lastpy;
+	new->_lastpx = win->_lastpx;
+	new->_lastsy1 = win->_lastsy1;
+	new->_lastsx1 = win->_lastsx1;
+	new->_lastsy2 = win->_lastsy2;
+	new->_lastsx2 = win->_lastsx2;
+	new->_flags = win->_flags;
+	new->_attrs = win->_attrs;
+	new->_tabsize = win->_tabsize;
+	new->_clear = win->_clear;
+	new->_leaveit = win->_leaveit;
+	new->_scroll = win->_scroll;
+	new->_nodelay = win->_nodelay;
+	new->_use_keypad = win->_use_keypad;
+	new->_use_idl = win->_use_idl;
+	new->_use_idc = win->_use_idc;
+	new->_tmarg = win->_tmarg;
+	new->_bmarg = win->_bmarg;
+	new->_title = win->_title;
+	new->_title_ofs = win->_title_ofs;
+	new->_title_attr = win->_title_attr;
+	new->_blank = win->_blank;
+	new->_parx = win->_parx;
+	new->_pary = win->_pary;
+	new->_parent = win->_parent;
+	new->_bkgd = win->_bkgd;
+
+	for (i = 0; i < nlines; i++)
+	{
+		new->_firstch[i] = 0;
+		new->_lastch[i] = ncols - 1;
+	}
+
+	new->_flags = win->_flags;
+
+	return( new );
+
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW *	PDC_CDECL	resize_window(WINDOW *win, int lins, int cols)
+#else
+WINDOW *	PDC_CDECL	resize_window(win,lins,cols)
+WINDOW *win;
+int lins;
+int cols;
+#endif
+/***********************************************************************/
+{
+#ifdef HAVE_PROTO
+extern	void*	(*callc)( size_t, size_t );
+extern	void	(*fre)( void* );
+#else
+extern	void*	(*callc)();
+extern	void	(*fre)();
+#endif
+
+	WINDOW*	new;
+	int	i;
+	int	j;
+	int	save_cury=0,save_curx=0;
+	int	new_begy=0,new_begx=0;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("resize_window() - called: lins %d cols %d\n",lins,cols);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( (WINDOW *)NULL );
+
+	if (win == PDC_SP->slk_winptr)
+	{
+		new_begy = PDC_SP->lines-PDC_SP->slklines;
+		new_begx = 0;
+	}
+	else
+	{
+		new_begy = win->_begy;
+		new_begx = win->_begx;
+	}
+
+	if ((new = PDC_makenew(lins, cols, new_begy, new_begx)) == (WINDOW *)NULL)
+		return( (WINDOW *)NULL );
+
+	new->_curx = min(win->_curx,new->_maxx);
+	new->_cury = min(win->_cury,new->_maxy);
+	new->_flags = win->_flags;
+	new->_attrs = win->_attrs;
+	new->_tabsize = win->_tabsize;
+	new->_clear = win->_clear;
+	new->_leaveit = win->_leaveit;
+	new->_scroll = win->_scroll;
+	new->_nodelay = win->_nodelay;
+	new->_use_keypad = win->_use_keypad;
+	new->_tmarg = (win->_tmarg > new->_maxy-1) ? 0 : win->_tmarg;
+	new->_bmarg = (win->_bmarg == win->_maxy-1) ? new->_maxy-1 : min(win->_bmarg,(new->_maxy-1));
+	new->_title = win->_title;
+	new->_title_ofs = win->_title_ofs;
+	new->_title_attr = win->_title_attr;
+	new->_parent = win->_parent;
+	new->_immed = win->_immed;
+	new->_sync = win->_sync;
+
+	for (i = 0; i < lins; i++)
+	{
+		/*
+		 * make and clear the lines
+		 */
+		if ((new->_y[i] = (chtype*)(*callc)(cols, sizeof(chtype))) == NULL)
+		{
+			for (j = 0; j < i; j++)
+			{
+				/*
+				 * if error, free all the data
+				 */
+				(*fre)(new->_y[j]);
+			}
+			(*fre)(new->_firstch);
+			(*fre)(new->_lastch);
+			(*fre)(new->_y);
+			(*fre)(new);
+			return( (WINDOW *)NULL );
+		}
+		new->_firstch[i] = new->_lastch[i] = _NO_CHANGE;
+	}
+
+	if (win != curscr
+	&&  win != PDC_SP->slk_winptr)
+	{
+		copywin(win, new, 0, 0, 0, 0, min(win->_maxy,new->_maxy), min(win->_maxx,new->_maxx),FALSE);
+		if (new->_maxy > win->_maxy)
+		{
+			save_cury = new->_cury;
+			save_curx = new->_curx;
+			wmove(new, new->_maxy - 1, 0);
+			wclrtobot(new);
+			new->_cury = save_cury;
+			new->_curx = save_curx;
+		}
+#if 0
+/* JGB box uses defaults if arguments are zero, but we don't want to do
+   this if the window currently has no box */
+		if (win->_borderchars[0] || win->_borderchars[2])
+			box(new, win->_borderchars[0], win->_borderchars[2]);
+#endif
+	}
+
+
+	delwin(win);
+	return(new);
+
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	wsyncup(WINDOW *win)
+#else
+void	PDC_CDECL	wsyncup(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	WINDOW *tmp=(WINDOW *)NULL;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wsyncup() - called\n");
+#endif
+
+	for (tmp = win; tmp != (WINDOW *)NULL; tmp = tmp->_parent) 
+	{
+		touchwin(tmp);
+	}
+	return;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	syncok(WINDOW *win, bool bf)
+#else
+int	PDC_CDECL	syncok(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("syncok() - called\n");
+#endif
+	if (win == (WINDOW *)NULL)
+		return(ERR);
+
+	win->_sync = bf;
+	return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	wcursyncup(WINDOW *win)
+#else
+void	PDC_CDECL	wcursyncup(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	WINDOW *tmp=(WINDOW *)NULL;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wcursyncup() - called\n");
+#endif
+
+	for( tmp = win; (tmp != (WINDOW *)NULL) && (tmp->_parent != (WINDOW *)NULL); tmp = tmp->_parent )
+	{
+		wmove( tmp->_parent, tmp->_pary + tmp->_cury, tmp->_parx + tmp->_curx );
+	}
+	return;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	wsyncdown(WINDOW *win)
+#else
+void	PDC_CDECL	wsyncdown(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	WINDOW *tmp=(WINDOW *)NULL;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wsyncdown() - called\n");
+#endif
+
+	for (tmp = win; tmp != (WINDOW *)NULL; tmp = tmp->_parent) 
+	{
+		if (is_wintouched(tmp)) 
+		{
+			touchwin(win);
+			break;
+		}
+	}
+	return;
+}
Index: PDCurses/pdcurses/attr.c
===================================================================
--- PDCurses/pdcurses/attr.c	(revision 1)
+++ PDCurses/pdcurses/attr.c	(working copy)
@@ -1,287 +1,287 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	attroff
-#undef	wattroff
-#undef	attron
-#undef	wattron
-#undef	attrset
-#undef	wattrset
-#undef	standend
-#undef	standout
-#undef	wstandend
-#undef	wstandout
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_attr  = "$Id: attr.c,v 1.1 2001/01/10 08:26:48 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                          attr
-
-  Synopsis:
-  	int attroff(attr_t attrs);
-  	int wattroff(WINDOW *win, attr_t attrs);
-  	int attron(attr_t attrs);
-  	int wattron(WINDOW *win, attr_t attrs);
-  	int attrset(attr_t attrs);
-  	int wattrset(WINDOW *win, attr_t attrs);
-  	int standend(void);
-  	int wstandend(WINDOW *win);
-  	int standout(void);
-  	int wstandout(WINDOW *win);
-
-  X/Open Description:
- 	These functions manipulate the current attributes of the named
- 	window.  These attributes can be any combination of A_STANDOUT,
- 	A_REVERSE, A_BOLD, A_DIM, A_BLINK, A_UNDERLINE.
-
- 	These constants are defined in <curses.h> and can be combined
- 	with the bitwise-OR operator (|).
-
- 	The current attributes of a window are applied to all characters
- 	that are written into the window with waddch().  Attributes are
- 	a property of the character, and move with the character
- 	through any scrolling and insert/delete line/character operations.
- 	To the extent possible on the particular terminal, they will be
- 	displayed as the graphic rendition of characters put on the
- 	screen.
-
- 	The attrset() function sets the current attributes of the given
- 	window to attrs.  The attroff() function turns off the named
- 	attributes without turning on or off any other attributes.  The
- 	attron() function turs on the named attriutes without affecting
- 	any others.  The standout() function is the same as
- 	attron( A_STANDOUT ).  The standend() function is the same as
- 	attrset( A_NORMAL ); that is it turns off all attributes.
-
- 	NOTE:	attroff(), attron(), attrset(), standend(), standout(),
- 		wstandend(), and wstandout() are defined as macros.
-
-  PDCurses Description:
- 	System V compatible color support is included.
- 	See <curses.h> for further details.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	It is an error to call this function with a NULL window pointer.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      attroff                               Y        Y       Y
-      wattroff                              Y        Y       Y
-      attron                                Y        Y       Y
-      wattron                               Y        Y       Y
-      attrset                               Y        Y       Y
-      wattrset                              Y        Y       Y
-      standend                              Y        Y       Y
-      wstandend                             Y        Y       Y
-      standout                              Y        Y       Y
-      wstandout                             Y        Y       Y
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	attroff(attr_t attrs)
-#else
-int	PDC_CDECL	attroff(attrs)
-chtype attrs;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("attroff() - called\n");
-#endif
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	stdscr->_attrs &= (~attrs & A_ATTRIBUTES);
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	wattroff(WINDOW *win, attr_t attrs)
-#else
-int	PDC_CDECL	wattroff(win,attrs)
-WINDOW *win;
-attr_t attrs;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wattroff() - called\n");
-#endif
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	win->_attrs &= (~attrs & A_ATTRIBUTES);
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	attron(attr_t attrs)
-#else
-int	PDC_CDECL	attron(attrs)
-attr_t attrs;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("attron() - called\n");
-#endif
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-	return(wattron(stdscr,attrs));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	wattron(WINDOW *win, attr_t attrs)
-#else
-int	PDC_CDECL	wattron(win,attrs)
-WINDOW *win;
-attr_t attrs;
-#endif
-/***********************************************************************/
-{
-	attr_t newcolr, oldcolr;
-	attr_t newattr, oldattr;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wattron() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-	if( (win->_attrs & A_COLOR) && (attrs & A_COLOR) ) 
-		{
-		oldcolr = win->_attrs & A_COLOR;
-		oldattr = win->_attrs ^ oldcolr;
-		newcolr = attrs & A_COLOR;
-		newattr = (attrs & A_ATTRIBUTES) ^ newcolr;
-		newattr |= oldattr;
-		win->_attrs = newattr | newcolr;
-		}
-	else
-		win->_attrs |= (attrs & A_ATTRIBUTES);
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	attrset(attr_t attrs)
-#else
-int	PDC_CDECL	attrset(attrs)
-attr_t attrs;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("attrset() - called\n");
-#endif
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-	stdscr->_attrs = attrs & A_ATTRIBUTES;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	wattrset(WINDOW *win, attr_t attrs)
-#else
-int	PDC_CDECL	wattrset(win,attrs)
-WINDOW *win;
-attr_t attrs;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wattrset() - called\n");
-#endif
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-	win->_attrs = attrs & A_ATTRIBUTES;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	standend(void)
-#else
-int	PDC_CDECL	standend()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("standend() - called\n");
-#endif
-	return( wattrset( stdscr, A_NORMAL ) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	standout(void)
-#else
-int	PDC_CDECL	standout()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("standout() - called\n");
-#endif
-	return( wattrset( stdscr, A_STANDOUT ) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	wstandend( WINDOW *win )
-#else
-int	PDC_CDECL	wstandend(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wstandend() - called\n");
-#endif
-	return( wattrset( win, A_NORMAL ) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	wstandout( WINDOW *win )
-#else
-int	PDC_CDECL	wstandout(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wstandout() - called\n");
-#endif
-	return( wattrset( win, A_STANDOUT ) );
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	attroff
+#undef	wattroff
+#undef	attron
+#undef	wattron
+#undef	attrset
+#undef	wattrset
+#undef	standend
+#undef	standout
+#undef	wstandend
+#undef	wstandout
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_attr  = "$Id: attr.c,v 1.1 2001/01/10 08:26:48 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                          attr
+
+  Synopsis:
+  	int attroff(attr_t attrs);
+  	int wattroff(WINDOW *win, attr_t attrs);
+  	int attron(attr_t attrs);
+  	int wattron(WINDOW *win, attr_t attrs);
+  	int attrset(attr_t attrs);
+  	int wattrset(WINDOW *win, attr_t attrs);
+  	int standend(void);
+  	int wstandend(WINDOW *win);
+  	int standout(void);
+  	int wstandout(WINDOW *win);
+
+  X/Open Description:
+ 	These functions manipulate the current attributes of the named
+ 	window.  These attributes can be any combination of A_STANDOUT,
+ 	A_REVERSE, A_BOLD, A_DIM, A_BLINK, A_UNDERLINE.
+
+ 	These constants are defined in <curses.h> and can be combined
+ 	with the bitwise-OR operator (|).
+
+ 	The current attributes of a window are applied to all characters
+ 	that are written into the window with waddch().  Attributes are
+ 	a property of the character, and move with the character
+ 	through any scrolling and insert/delete line/character operations.
+ 	To the extent possible on the particular terminal, they will be
+ 	displayed as the graphic rendition of characters put on the
+ 	screen.
+
+ 	The attrset() function sets the current attributes of the given
+ 	window to attrs.  The attroff() function turns off the named
+ 	attributes without turning on or off any other attributes.  The
+ 	attron() function turs on the named attriutes without affecting
+ 	any others.  The standout() function is the same as
+ 	attron( A_STANDOUT ).  The standend() function is the same as
+ 	attrset( A_NORMAL ); that is it turns off all attributes.
+
+ 	NOTE:	attroff(), attron(), attrset(), standend(), standout(),
+ 		wstandend(), and wstandout() are defined as macros.
+
+  PDCurses Description:
+ 	System V compatible color support is included.
+ 	See <curses.h> for further details.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	It is an error to call this function with a NULL window pointer.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      attroff                               Y        Y       Y
+      wattroff                              Y        Y       Y
+      attron                                Y        Y       Y
+      wattron                               Y        Y       Y
+      attrset                               Y        Y       Y
+      wattrset                              Y        Y       Y
+      standend                              Y        Y       Y
+      wstandend                             Y        Y       Y
+      standout                              Y        Y       Y
+      wstandout                             Y        Y       Y
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	attroff(attr_t attrs)
+#else
+int	PDC_CDECL	attroff(attrs)
+chtype attrs;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("attroff() - called\n");
+#endif
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	stdscr->_attrs &= (~attrs & A_ATTRIBUTES);
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wattroff(WINDOW *win, attr_t attrs)
+#else
+int	PDC_CDECL	wattroff(win,attrs)
+WINDOW *win;
+attr_t attrs;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wattroff() - called\n");
+#endif
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	win->_attrs &= (~attrs & A_ATTRIBUTES);
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	attron(attr_t attrs)
+#else
+int	PDC_CDECL	attron(attrs)
+attr_t attrs;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("attron() - called\n");
+#endif
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+	return(wattron(stdscr,attrs));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wattron(WINDOW *win, attr_t attrs)
+#else
+int	PDC_CDECL	wattron(win,attrs)
+WINDOW *win;
+attr_t attrs;
+#endif
+/***********************************************************************/
+{
+	attr_t newcolr, oldcolr;
+	attr_t newattr, oldattr;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wattron() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+	if( (win->_attrs & A_COLOR) && (attrs & A_COLOR) ) 
+		{
+		oldcolr = win->_attrs & A_COLOR;
+		oldattr = win->_attrs ^ oldcolr;
+		newcolr = attrs & A_COLOR;
+		newattr = (attrs & A_ATTRIBUTES) ^ newcolr;
+		newattr |= oldattr;
+		win->_attrs = newattr | newcolr;
+		}
+	else
+		win->_attrs |= (attrs & A_ATTRIBUTES);
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	attrset(attr_t attrs)
+#else
+int	PDC_CDECL	attrset(attrs)
+attr_t attrs;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("attrset() - called\n");
+#endif
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+	stdscr->_attrs = attrs & A_ATTRIBUTES;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wattrset(WINDOW *win, attr_t attrs)
+#else
+int	PDC_CDECL	wattrset(win,attrs)
+WINDOW *win;
+attr_t attrs;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wattrset() - called\n");
+#endif
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+	win->_attrs = attrs & A_ATTRIBUTES;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	standend(void)
+#else
+int	PDC_CDECL	standend()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("standend() - called\n");
+#endif
+	return( wattrset( stdscr, A_NORMAL ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	standout(void)
+#else
+int	PDC_CDECL	standout()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("standout() - called\n");
+#endif
+	return( wattrset( stdscr, A_STANDOUT ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wstandend( WINDOW *win )
+#else
+int	PDC_CDECL	wstandend(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wstandend() - called\n");
+#endif
+	return( wattrset( win, A_NORMAL ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wstandout( WINDOW *win )
+#else
+int	PDC_CDECL	wstandout(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wstandout() - called\n");
+#endif
+	return( wattrset( win, A_STANDOUT ) );
+}
Index: PDCurses/pdcurses/initscr.c
===================================================================
--- PDCurses/pdcurses/initscr.c	(revision 1)
+++ PDCurses/pdcurses/initscr.c	(working copy)
@@ -1,716 +1,716 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define  CURSES_LIBRARY 1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-#ifdef HAVE_MEMORY_H
-#include <memory.h>
-#endif
-
-#ifdef UNIX
-#define NOTLIB
-#include <defs.h>
-#include <term.h>
-#endif
-
-/* undefine any macros for functions defined in this module */
-#undef   initscr
-#undef   endwin
-#undef   isendwin
-#undef   newterm
-#undef   set_term
-#undef   delscreen
-#undef   resize_term
-#undef   is_termresized
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef move
-#  undef wmove
-#  undef resize_term
-#  undef touchwin
-#  undef wnoutrefresh
-#endif
-
-#ifdef UNIX
-#define NOTLIB
-#include <defs.h>
-#include <term.h>
-/* following is to stop compilation problems with #define of lines */
-#undef lines
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_initscr  = "$Id: initscr.c,v 1.4 2002/12/16 06:58:09 mark Exp $";
-#else
-char* _curses_notice = "PDCurses 2.2 - Public Domain 1994";
-#endif
-
-int   _default_lines = 25; /* default terminal height */
-
-SCREEN *SP = (SCREEN*)NULL;      /* curses variables     */
-WINDOW*  curscr=NULL;         /* the current screen image   */
-WINDOW*  stdscr=NULL;         /* the default screen window  */
-int   LINES=0;       /* current terminal height */
-int   COLS=0;        /* current terminal width  */
-MOUSE_STATUS Mouse_status;
-int    use_emalloc = FALSE;
-
-#if defined DOS
-Regs regs;
-#endif
-
-/*
- * Global definitions for charget routines
- */
-int   c_pindex = 0;     /* putter index */
-int   c_gindex = 1;     /* getter index */
-int   c_ungind = 0;     /* wungetch() push index */
-int   c_ungch[NUNGETCH];   /* array of ungotten chars */
-WINDOW*  _getch_win_=NULL;
-
-/*
- * Global definitions for setmode routines
- */
-struct cttyset c_sh_tty = {0};   /* tty modes for def_shell_mode */
-struct cttyset c_pr_tty = {0};   /* tty modes for def_prog_mode  */
-struct cttyset c_save_tty = {0};
-struct cttyset c_save_trm = {0};
-
-/*
- * Global definitions for printscan routines
- */
-char c_printscanbuf[513];  /* buffer used during I/O */
-
-/*
- * Global definitions for strget routines
- */
-char *c_strbeg;
-
-#if   EMALLOC
-void* emalloc( size_t );
-void* ecalloc( size_t, size_t );
-void  efree( void* );
-   
-extern   void* emalloc();  /* user's emalloc(size)    */
-extern   void* ecalloc();  /* user's ecalloc(num,size)   */
-extern   void  efree(); /* user's efree(ptr)    */
-#endif
-
-#if !defined(UNIX) && !defined(XCURSES)
-extern   void* malloc();   /* runtime's malloc(size)  */
-extern   void* calloc();   /* runtime's calloc(num,size) */
-extern   void  free();     /* runtime's free(ptr)     */
-#endif
-
-void* (*mallc)();    /* ptr to some malloc(size)   */
-void* (*callc)();    /* ptr to some ecalloc(num,size)*/
-void  (*fre)();      /* ptr to some free(ptr)   */
-void* (*reallc)();      /* ptr to some realloc(ptr,size) */
-
-#ifdef XCURSES
-chtype *acs_map;
-#endif
-
-extern RIPPEDOFFLINE linesripped[5];
-extern char linesrippedoff;
-
-#ifdef HAVE_PROTO
-extern void (*PDC_initial_slk)(void);
-#else
-extern void (*PDC_initial_slk)();
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                       initscr
-
-  Synopsis:
-   WINDOW *initscr(void);
-   WINDOW *Xinitscr(int argc, char *argv[]);
-   int endwin(void);
-   int isendwin(void);
-  *** SCREEN *newterm(char *type, FILE *outfd, FILE *infd);
-   SCREEN *set_term(SCREEN *new);
-  *** void delscreen(SCREEN *sp);
-
-   int resize_term(int nlines, int ncols);
-   bool is_termresized(void);
-
-  X/Open Description:
-   The first curses routine called should be initscr().  This will
-   determine the terminal type and initialize all curses data
-   structures.  The initscr() function also arranges that the
-   first call to refresh() will clear the screen.  If errors
-   occur, initscr() will write an appropriate error message to
-   standard error and exit.  If the program wants an indication
-   of error conditions, newterm() should be used instead of
-   initscr().
-
-   A program should always call endwin() before exiting or
-   escaping from curses mode temporarily.  This routine will
-   restore tty modes, move the cursor to the lower left corner
-   of the screen and reset the terminal into the proper non-visual
-   mode.  To resume curses after a temporary escape, refresh() or
-   doupdate() should be called.
-
-   The isendwin() function returns TRUE if endwin() has been called
-   without any subsequent calls to wrefresh(), and FALSE otherwise.
-
-   A program which outputs to more than one terminal should use
-   newterm() for each terminal instead of initscr().  The newterm()
-   function should be called once for each terminal.  It returns a 
-   value of type SCREEN* which should be saved as a reference to that
-   terminal. The arguments are the type of of terminal to be used
-   in place of TERM (environment variable), a file pointer for output
-   to the terminal and another file pointer for input from the terminal.
-   The program must also call endwin() for each terminal no longer being
-   used.
-
-   The set_term() function is used to switch between different terminals.
-   The screen reference 'new' becomes the new current terminal.
-   The previous terminal is returned by the routine.  This is the
-   only routine which manipulates SCREEN pointers; all other routines
-   affect only the current terminal.
-
-  PDCurses Description:
-   The resize_term() function is used to have PDCurses change its
-   internal structures to the new, specified size.
-
-   The is_termresized() function returns TRUE if the Curses screen has
-   been resized by external means, and requires a call to resize_term().
-
-   Due to the fact that newterm() does not yet exist in PDCurses,
-   there is no way to recover from an error in initscr().
-
-  X/Open Return Value:
-   All functions return NULL on error, except endwin(), which
-   returns ERR on error.
-
-  X/Open Errors:
-   No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      initscr                               Y        Y       Y
-      endwin                                Y        Y       Y
-      isendwin                              -        -      3.0
-      newterm                               -        -       Y
-      set_term                              -        -       Y
-      delscreen                             -        -      4.0
-      resize_term                           -        -       -
-      is_termresized                        -        -       -
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-WINDOW*  PDC_CDECL   Xinitscr(int argc, char *argv[])
-#else
-WINDOW*  PDC_CDECL   Xinitscr(argc,argv)
-int argc;
-char *argv[];
-#endif
-/***********************************************************************/
-{
-register int i=0;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("Xinitscr() - called\n");
-#endif
-
-   if (SP != (SCREEN *)NULL
-   &&  SP->alive)
-      return( NULL);
-
-#ifdef EMXVIDEO
-   v_init();
-#endif
-
-   if  (use_emalloc == EMALLOC_MAGIC)
-   {
-#if   EMALLOC
-      use_emalloc = TRUE;
-      mallc = emalloc;
-      callc = ecalloc;
-      fre   = efree;
-      reallc = erealloc;
-#endif
-   }
-   else
-   {
-      mallc = malloc;
-      callc = calloc;
-      fre   = free;
-      reallc = realloc;
-   }
-
-#ifdef UNIX
-   setupterm((char *)0,1,(int *)0);
-   if (enter_ca_mode != NULL)
-      putp(enter_ca_mode);
-#endif
-
-#if defined (XCURSES)
-   if (XCursesInitscr(NULL,argc,argv) == ERR)
-      exit(7);
-#endif
-
-#if defined (XCURSES)
-   if (SP == (SCREEN*)NULL) /* SP already attached in XCursesInitscr() */
-#else
-   if ((SP = (SCREEN*)callc(1,sizeof(SCREEN))) == (SCREEN*)NULL)
-#endif
-   {
-      fprintf( stderr, "initscr(): Unable to create SP\n" );
-      exit(8);
-   }
-
-   PDC_scr_open(SP, 0);
-
-#ifdef   FLEXOS
-   _flexos_16bitmode();
-#endif
-
-   LINES = SP->lines;
-   COLS = SP->cols;
-
-   if (LINES < 2 || COLS < 2)
-   {
-      fprintf( stderr, "initscr(): LINES=%d COLS=%d: too small.\n",LINES,COLS );
-      exit( 4 );
-   }
-
-   if ((curscr = newwin(LINES, COLS, 0, 0)) == (WINDOW *) NULL)
-   {
-      fprintf( stderr, "initscr(): Unable to create curscr.\n" );
-      exit( 2 );
-   }
-
-#ifdef XCURSES
-   if ((acs_map = (chtype *)(*mallc)(128*sizeof(chtype))) == (chtype *)NULL)
-   {
-      fprintf( stderr, "initscr(): Unable to create acs_map.\n" );
-      exit( 5 );
-   }
-   for (i=0;i<128;i++)
-   {
-      acs_map[i] = '#' | A_ALTCHARSET;
-   }
-   ACS_BSSB = (chtype)13|A_ALTCHARSET;
-   ACS_SSBB = (chtype)14|A_ALTCHARSET;
-   ACS_BBSS = (chtype)12|A_ALTCHARSET;
-   ACS_SBBS = (chtype)11|A_ALTCHARSET;
-   ACS_SBSS = (chtype)22|A_ALTCHARSET;
-   ACS_SSSB = (chtype)21|A_ALTCHARSET;
-   ACS_SSBS = (chtype)23|A_ALTCHARSET;
-   ACS_BSSS = (chtype)24|A_ALTCHARSET;
-   ACS_BSBS = (chtype)18|A_ALTCHARSET;
-   ACS_SBSB = (chtype)25|A_ALTCHARSET;
-   ACS_SSSS = (chtype)15|A_ALTCHARSET;
-   ACS_S1       = (chtype)16|A_ALTCHARSET;
-   ACS_S9       = (chtype)20|A_ALTCHARSET;
-   ACS_DIAMOND  = (chtype)1|A_ALTCHARSET;
-   ACS_CKBOARD  = (chtype)2|A_ALTCHARSET;
-   ACS_DEGREE   = (chtype)7|A_ALTCHARSET;
-   ACS_PLMINUS  = (chtype)8|A_ALTCHARSET;
-   ACS_BULLET   = (chtype)'*'|A_ALTCHARSET;
-   ACS_LARROW   = (chtype)'<'|A_ALTCHARSET;
-   ACS_RARROW   = (chtype)'>'|A_ALTCHARSET;
-   ACS_DARROW   = (chtype)'v'|A_ALTCHARSET;
-   ACS_UARROW   = (chtype)'^'|A_ALTCHARSET;
-   ACS_BOARD    = (chtype)'#'|A_ALTCHARSET;
-   ACS_LANTERN  = (chtype)'#'|A_ALTCHARSET;
-   ACS_BLOCK    = (chtype)0|A_ALTCHARSET;
-   /* extra, non-standard symbols */
-   ACS_S3      = (chtype)17|A_ALTCHARSET;
-   ACS_S7      = (chtype)19|A_ALTCHARSET;
-   ACS_LEQUAL  = (chtype)26|A_ALTCHARSET;
-   ACS_GEQUAL  = (chtype)27|A_ALTCHARSET;
-   ACS_PI      = (chtype)28|A_ALTCHARSET;
-   ACS_NEQUAL  = (chtype)29|A_ALTCHARSET;
-   ACS_STERLING= (chtype)30|A_ALTCHARSET;
-#endif
-
-   if (PDC_initial_slk)
-   {
-      (*PDC_initial_slk)();
-      LINES -= SP->slklines;
-   }
-
-/*
- * We have to sort out ripped off lines here and reduce the height
- * of stdscr by the number of lines ripped off
- */
-   for (i=0;i<linesrippedoff;i++)
-   {
-      if (linesripped[i].line < 0)
-         (*linesripped[i].init)(newwin(1,COLS,LINES-1,0),COLS);
-      else
-         (*linesripped[i].init)(newwin(1,COLS,SP->linesrippedoffontop++,0),COLS);
-      SP->linesrippedoff++;
-      LINES--;
-   }
-   linesrippedoff = 0;
-
-   if ((stdscr = newwin(LINES, COLS, SP->linesrippedoffontop, 0)) == (WINDOW *) NULL)
-   {
-      fprintf( stderr, "initscr(): Unable to create stdscr.\n" );
-      exit( 1 );
-   }
-
-   wclrtobot(stdscr);
-
-/*
- * If preserving the existing screen don't allow a screen clear...
- */
-if (SP->_preserve)
-   {
-   untouchwin(curscr);
-   untouchwin(stdscr);
-   stdscr->_clear = FALSE;
-   }
-
-   curscr->_clear = FALSE;
-
-#ifdef   REGISTERWINDOWS
-   SP->refreshall = FALSE;
-   _inswin(stdscr, (WINDOW *)NULL);
-#endif
-
-#if defined(CHTYPE_LONG)
-   PDC_init_atrtab(); /* set up default (BLACK on WHITE colours */
-#endif
-
-#ifdef EMXVIDEO
-   SP->tahead = -1;
-#endif
-
-   MOUSE_X_POS = MOUSE_Y_POS = (-1);
-   BUTTON_STATUS(1) = BUTTON_RELEASED;
-   BUTTON_STATUS(2) = BUTTON_RELEASED;
-   BUTTON_STATUS(3) = BUTTON_RELEASED;
-   Mouse_status.changes = 0;
-
-   SP->alive = TRUE;
-
-#ifdef UNIX
-   PDC_setup_keys();
-#else
-   def_shell_mode(); /* don't do this for UNIX as scropen has already changed things */
-#endif
-
-   return( stdscr );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-WINDOW*  PDC_CDECL   initscr(void)
-#else
-WINDOW*  PDC_CDECL   initscr()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("initscr() - called\n");
-#endif
-   return (Xinitscr( 0, NULL ) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int PDC_CDECL endwin(void)
-#else
-int PDC_CDECL endwin()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("endwin() - called\n");
-#endif
-
-#ifdef ORIGINAL_PDCURSES_BEHAVIOUR
-   PDC_scr_close();
-/* resetty();*/
-   if (SP->orig_font != SP->font)  /* screen has not been resized */
-   {
-      PDC_set_font(SP->orig_font);
-      resize_term(PDC_get_rows(),PDC_get_columns());
-   }
-
-   SP->visible_cursor = FALSE;   /* Force the visible cursor */
-   SP->cursor = SP->orig_cursor;
-   PDC_cursor_on();
-   /*
-    * Position cursor so that the screen will not scroll until they hit
-    * a carriage return. Do this BEFORE delwin(curscr) as PDC_gotoxy() uses
-    * curscr.
-    */
-   PDC_gotoxy(PDC_get_rows() - 2, 0);
-   delwin(stdscr);
-   delwin(curscr);
-   stdscr = (WINDOW *)NULL;
-   curscr = (WINDOW *)NULL;
-   SP->alive = FALSE;
-
-# if !defined (XCURSES)
-   if (SP)
-   {
-      fre(SP);
-      SP = (SCREEN *)NULL;
-   }
-# endif
-
-
-# ifdef  FLEXOS
-   _flexos_8bitmode();
-# endif
-/* PDC_fix_cursor(SP->orig_emulation);*/
-
-# ifdef UNIX
-   if (exit_ca_mode != NULL)
-      putp(exit_ca_mode);
-# endif
-
-# if defined(DOS) || defined(OS2)
-   reset_shell_mode();
-# endif
-
-# if DONOTKILLXFROMHERE
-#  if defined (XCURSES)
-   XCursesInstruct(CURSES_EXIT);
-   XCursesCleanupCursesProcess(0);
-#  endif
-# endif
-
-#else
-
-/*
- * New endwin() behaviour; to allow temporary exit from curses
- * using endwin().
- */
-
-   PDC_scr_close();
-
-# ifdef  FLEXOS
-   _flexos_8bitmode();
-# endif
-
-# if defined(DOS) || defined(OS2)
-   reset_shell_mode();
-# endif
-
-   curs_set(1);
-   /*
-    * Position cursor to the bottom left of the screen.
-    */
-#if defined(WIN32)
-   PDC_gotoxy(PDC_get_buffer_rows() - 2, 0);
-#else
-   PDC_gotoxy(PDC_get_rows() - 2, 0);
-#endif
-
-   SP->alive = FALSE;
-
-#endif
-
-   return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   isendwin(void)
-#else
-int   PDC_CDECL   isendwin()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("isendwin() - called\n");
-#endif
-
-   return((SP->alive) ? FALSE : TRUE);
-}
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-SCREEN*PDC_CDECL     newterm( char *type, FILE *outfd, FILE *infd )
-#else
-SCREEN*PDC_CDECL     newterm(type,outfd,infd)
-char *type;
-FILE *outfd;
-FILE *infd;
-#endif
-/***********************************************************************/
-{
-#ifdef   TC
-#  pragma argsused
-#endif
-
-#if 0
-extern   void* mallc(); /* malloc(size)      */
-extern   void* callc(); /* calloc(num,size)  */
-extern   void  fre();      /* free(ptr)      */
-
-extern   void* malloc();
-extern   void* calloc();
-extern   void  free();
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("newterm() - called\n");
-#endif
-
-   if  (SP->alive)
-      return( ERR );
-
-   if  (use_emalloc == EMALLOC_MAGIC)
-   {
-#if   EMALLOC
-      memset(SP, 0, sizeof(SCREEN));
-      use_emalloc = TRUE;
-      mallc = emalloc;
-      callc = ecalloc;
-      fre   = efree;
-      reallc = erealloc;
-#endif
-   }
-   else
-   {
-      memset(SP, 0, sizeof(SCREEN));
-      mallc = malloc;
-      callc = calloc;
-      fre   = free;
-      reallc = realloc;
-   }
-   PDC_scr_open(SP, 0);
-   SP->orig_cursor = SP->cursor;
-   SP->orig_font = PDC_get_font();
-   SP->orgcbr = PDC_get_ctrl_break();
-   SP->blank = ' ';
-#ifdef   FLEXOS
-   _flexos_16bitmode();
-#endif
-   savetty();
-   LINES = PDC_get_rows();
-   COLS = PDC_get_columns();
-
-   if ((curscr = newwin(LINES, COLS, 0, 0)) == (WINDOW *) ERR)
-   {
-      return( ERR );
-   }
-   if ((stdscr = newwin(LINES, COLS, 0, 0)) == (WINDOW *) ERR)
-   {
-      return( ERR );
-   }
-   curscr->_clear = FALSE;
-#ifdef   REGISTERWINDOWS
-   SP->refreshall = FALSE;
-   _inswin(stdscr, (WINDOW *)NULL);
-#endif
-   SP->alive = TRUE;
-   return( SP );
-#endif
-   return(NULL);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-SCREEN*  PDC_CDECL   set_term( SCREEN *new )
-#else
-SCREEN*  PDC_CDECL   set_term(new)
-SCREEN *new;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("set_term() - called\n");
-#endif
-
-#ifdef   TC
-#  pragma argsused
-#endif
-   return( SP );  /* We only have one screen supported right now */
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   resize_term(int nlines, int ncols)
-#else
-int   PDC_CDECL   resize_term(nlines,ncols)
-int nlines,ncols;
-#endif
-/***********************************************************************/
-{
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("resize_term() - called: nlines %d\n",nlines);
-#endif
-
-   if (stdscr == (WINDOW *)NULL)
-      return(ERR);
-
-   if (PDC_resize_screen(nlines,ncols) == ERR)
-      return ( ERR );
-
-   SP->lines = PDC_get_rows();
-   LINES = SP->lines - SP->linesrippedoff - SP->slklines;
-   SP->cols  = COLS  = PDC_get_columns();
-
-   /*
-    * We need to change the saved prog_mode details...
-    */
-   if ( c_pr_tty.been_set )
-   {
-      c_pr_tty.saved.lines = SP->lines;
-      c_pr_tty.saved.cols = SP->cols;
-   }
-
-   if ((curscr = resize_window(curscr, SP->lines, SP->cols)) == NULL)
-      return (ERR);
-
-   if ((stdscr = resize_window(stdscr, LINES, COLS)) == NULL)
-      return (ERR);
-
-   if (SP->slk_winptr)
-   {
-      if ((SP->slk_winptr = resize_window(SP->slk_winptr,SP->slklines, COLS)) == NULL)
-         return (ERR);
-      wmove(SP->slk_winptr, 0, 0);
-      wclrtobot(SP->slk_winptr);
-      (*PDC_initial_slk)();
-      slk_noutrefresh();
-   }
-
-   touchwin(stdscr);
-   wnoutrefresh(stdscr);
-
-   return (OK);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-bool  PDC_CDECL   is_termresized(void)
-#else
-bool  PDC_CDECL   is_termresized()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("is_termresized() - called\n");
-#endif
-   return( SP->resized );
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define  CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef HAVE_MEMORY_H
+#include <memory.h>
+#endif
+
+#ifdef UNIX
+#define NOTLIB
+#include <defs.h>
+#include <term.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef   initscr
+#undef   endwin
+#undef   isendwin
+#undef   newterm
+#undef   set_term
+#undef   delscreen
+#undef   resize_term
+#undef   is_termresized
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef move
+#  undef wmove
+#  undef resize_term
+#  undef touchwin
+#  undef wnoutrefresh
+#endif
+
+#ifdef UNIX
+#define NOTLIB
+#include <defs.h>
+#include <term.h>
+/* following is to stop compilation problems with #define of lines */
+#undef lines
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_initscr  = "$Id: initscr.c,v 1.4 2002/12/16 06:58:09 mark Exp $";
+#else
+char* _curses_notice = "PDCurses 2.2 - Public Domain 1994";
+#endif
+
+int   _default_lines = 25; /* default terminal height */
+
+SCREEN *PDC_SP = (SCREEN*)NULL;      /* curses variables     */
+WINDOW*  curscr=NULL;         /* the current screen image   */
+WINDOW*  stdscr=NULL;         /* the default screen window  */
+int   LINES=0;       /* current terminal height */
+int   COLS=0;        /* current terminal width  */
+MOUSE_STATUS Mouse_status;
+int    use_emalloc = FALSE;
+
+#if defined DOS
+Regs regs;
+#endif
+
+/*
+ * Global definitions for charget routines
+ */
+int   c_pindex = 0;     /* putter index */
+int   c_gindex = 1;     /* getter index */
+int   c_ungind = 0;     /* wungetch() push index */
+int   c_ungch[NUNGETCH];   /* array of ungotten chars */
+WINDOW*  _getch_win_=NULL;
+
+/*
+ * Global definitions for setmode routines
+ */
+struct cttyset c_sh_tty = {0};   /* tty modes for def_shell_mode */
+struct cttyset c_pr_tty = {0};   /* tty modes for def_prog_mode  */
+struct cttyset c_save_tty = {0};
+struct cttyset c_save_trm = {0};
+
+/*
+ * Global definitions for printscan routines
+ */
+char c_printscanbuf[513];  /* buffer used during I/O */
+
+/*
+ * Global definitions for strget routines
+ */
+char *c_strbeg;
+
+#if   EMALLOC
+void* emalloc( size_t );
+void* ecalloc( size_t, size_t );
+void  efree( void* );
+   
+extern   void* emalloc();  /* user's emalloc(size)    */
+extern   void* ecalloc();  /* user's ecalloc(num,size)   */
+extern   void  efree(); /* user's efree(ptr)    */
+#endif
+
+#if !defined(UNIX) && !defined(XCURSES)
+extern   void* malloc();   /* runtime's malloc(size)  */
+extern   void* calloc();   /* runtime's calloc(num,size) */
+extern   void  free();     /* runtime's free(ptr)     */
+#endif
+
+void* (*mallc)();    /* ptr to some malloc(size)   */
+void* (*callc)();    /* ptr to some ecalloc(num,size)*/
+void  (*fre)();      /* ptr to some free(ptr)   */
+void* (*reallc)();      /* ptr to some realloc(ptr,size) */
+
+#ifdef XCURSES
+chtype *acs_map;
+#endif
+
+extern RIPPEDOFFLINE linesripped[5];
+extern char linesrippedoff;
+
+#ifdef HAVE_PROTO
+extern void (*PDC_initial_slk)(void);
+#else
+extern void (*PDC_initial_slk)();
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                       initscr
+
+  Synopsis:
+   WINDOW *initscr(void);
+   WINDOW *Xinitscr(int argc, char *argv[]);
+   int endwin(void);
+   int isendwin(void);
+  *** SCREEN *newterm(char *type, FILE *outfd, FILE *infd);
+   SCREEN *set_term(SCREEN *new);
+  *** void delscreen(SCREEN *PDC_SP);
+
+   int resize_term(int nlines, int ncols);
+   bool is_termresized(void);
+
+  X/Open Description:
+   The first curses routine called should be initscr().  This will
+   determine the terminal type and initialize all curses data
+   structures.  The initscr() function also arranges that the
+   first call to refresh() will clear the screen.  If errors
+   occur, initscr() will write an appropriate error message to
+   standard error and exit.  If the program wants an indication
+   of error conditions, newterm() should be used instead of
+   initscr().
+
+   A program should always call endwin() before exiting or
+   escaping from curses mode temporarily.  This routine will
+   restore tty modes, move the cursor to the lower left corner
+   of the screen and reset the terminal into the proper non-visual
+   mode.  To resume curses after a temporary escape, refresh() or
+   doupdate() should be called.
+
+   The isendwin() function returns TRUE if endwin() has been called
+   without any subsequent calls to wrefresh(), and FALSE otherwise.
+
+   A program which outputs to more than one terminal should use
+   newterm() for each terminal instead of initscr().  The newterm()
+   function should be called once for each terminal.  It returns a 
+   value of type SCREEN* which should be saved as a reference to that
+   terminal. The arguments are the type of of terminal to be used
+   in place of TERM (environment variable), a file pointer for output
+   to the terminal and another file pointer for input from the terminal.
+   The program must also call endwin() for each terminal no longer being
+   used.
+
+   The set_term() function is used to switch between different terminals.
+   The screen reference 'new' becomes the new current terminal.
+   The previous terminal is returned by the routine.  This is the
+   only routine which manipulates SCREEN pointers; all other routines
+   affect only the current terminal.
+
+  PDCurses Description:
+   The resize_term() function is used to have PDCurses change its
+   internal structures to the new, specified size.
+
+   The is_termresized() function returns TRUE if the Curses screen has
+   been resized by external means, and requires a call to resize_term().
+
+   Due to the fact that newterm() does not yet exist in PDCurses,
+   there is no way to recover from an error in initscr().
+
+  X/Open Return Value:
+   All functions return NULL on error, except endwin(), which
+   returns ERR on error.
+
+  X/Open Errors:
+   No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      initscr                               Y        Y       Y
+      endwin                                Y        Y       Y
+      isendwin                              -        -      3.0
+      newterm                               -        -       Y
+      set_term                              -        -       Y
+      delscreen                             -        -      4.0
+      resize_term                           -        -       -
+      is_termresized                        -        -       -
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW*  PDC_CDECL   Xinitscr(int argc, char *argv[])
+#else
+WINDOW*  PDC_CDECL   Xinitscr(argc,argv)
+int argc;
+char *argv[];
+#endif
+/***********************************************************************/
+{
+register int i=0;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("Xinitscr() - called\n");
+#endif
+
+   if (PDC_SP != (SCREEN *)NULL
+   &&  PDC_SP->alive)
+      return( NULL);
+
+#ifdef EMXVIDEO
+   v_init();
+#endif
+
+   if  (use_emalloc == EMALLOC_MAGIC)
+   {
+#if   EMALLOC
+      use_emalloc = TRUE;
+      mallc = emalloc;
+      callc = ecalloc;
+      fre   = efree;
+      reallc = erealloc;
+#endif
+   }
+   else
+   {
+      mallc = malloc;
+      callc = calloc;
+      fre   = free;
+      reallc = realloc;
+   }
+
+#ifdef UNIX
+   setupterm((char *)0,1,(int *)0);
+   if (enter_ca_mode != NULL)
+      putp(enter_ca_mode);
+#endif
+
+#if defined (XCURSES)
+   if (XCursesInitscr(NULL,argc,argv) == ERR)
+      exit(7);
+#endif
+
+#if defined (XCURSES)
+   if (PDC_SP == (SCREEN*)NULL) /* PDC_SP already attached in XCursesInitscr() */
+#else
+   if ((PDC_SP = (SCREEN*)callc(1,sizeof(SCREEN))) == (SCREEN*)NULL)
+#endif
+   {
+      fprintf( stderr, "initscr(): Unable to create PDC_SP\n" );
+      exit(8);
+   }
+
+   PDC_scr_open(PDC_SP, 0);
+
+#ifdef   FLEXOS
+   _flexos_16bitmode();
+#endif
+
+   LINES = PDC_SP->lines;
+   COLS = PDC_SP->cols;
+
+   if (LINES < 2 || COLS < 2)
+   {
+      fprintf( stderr, "initscr(): LINES=%d COLS=%d: too small.\n",LINES,COLS );
+      exit( 4 );
+   }
+
+   if ((curscr = newwin(LINES, COLS, 0, 0)) == (WINDOW *) NULL)
+   {
+      fprintf( stderr, "initscr(): Unable to create curscr.\n" );
+      exit( 2 );
+   }
+
+#ifdef XCURSES
+   if ((acs_map = (chtype *)(*mallc)(128*sizeof(chtype))) == (chtype *)NULL)
+   {
+      fprintf( stderr, "initscr(): Unable to create acs_map.\n" );
+      exit( 5 );
+   }
+   for (i=0;i<128;i++)
+   {
+      acs_map[i] = '#' | A_ALTCHARSET;
+   }
+   ACS_BSSB = (chtype)13|A_ALTCHARSET;
+   ACS_SSBB = (chtype)14|A_ALTCHARSET;
+   ACS_BBSS = (chtype)12|A_ALTCHARSET;
+   ACS_SBBS = (chtype)11|A_ALTCHARSET;
+   ACS_SBSS = (chtype)22|A_ALTCHARSET;
+   ACS_SSSB = (chtype)21|A_ALTCHARSET;
+   ACS_SSBS = (chtype)23|A_ALTCHARSET;
+   ACS_BSSS = (chtype)24|A_ALTCHARSET;
+   ACS_BSBS = (chtype)18|A_ALTCHARSET;
+   ACS_SBSB = (chtype)25|A_ALTCHARSET;
+   ACS_SSSS = (chtype)15|A_ALTCHARSET;
+   ACS_S1       = (chtype)16|A_ALTCHARSET;
+   ACS_S9       = (chtype)20|A_ALTCHARSET;
+   ACS_DIAMOND  = (chtype)1|A_ALTCHARSET;
+   ACS_CKBOARD  = (chtype)2|A_ALTCHARSET;
+   ACS_DEGREE   = (chtype)7|A_ALTCHARSET;
+   ACS_PLMINUS  = (chtype)8|A_ALTCHARSET;
+   ACS_BULLET   = (chtype)'*'|A_ALTCHARSET;
+   ACS_LARROW   = (chtype)'<'|A_ALTCHARSET;
+   ACS_RARROW   = (chtype)'>'|A_ALTCHARSET;
+   ACS_DARROW   = (chtype)'v'|A_ALTCHARSET;
+   ACS_UARROW   = (chtype)'^'|A_ALTCHARSET;
+   ACS_BOARD    = (chtype)'#'|A_ALTCHARSET;
+   ACS_LANTERN  = (chtype)'#'|A_ALTCHARSET;
+   ACS_BLOCK    = (chtype)0|A_ALTCHARSET;
+   /* extra, non-standard symbols */
+   ACS_S3      = (chtype)17|A_ALTCHARSET;
+   ACS_S7      = (chtype)19|A_ALTCHARSET;
+   ACS_LEQUAL  = (chtype)26|A_ALTCHARSET;
+   ACS_GEQUAL  = (chtype)27|A_ALTCHARSET;
+   ACS_PI      = (chtype)28|A_ALTCHARSET;
+   ACS_NEQUAL  = (chtype)29|A_ALTCHARSET;
+   ACS_STERLING= (chtype)30|A_ALTCHARSET;
+#endif
+
+   if (PDC_initial_slk)
+   {
+      (*PDC_initial_slk)();
+      LINES -= PDC_SP->slklines;
+   }
+
+/*
+ * We have to sort out ripped off lines here and reduce the height
+ * of stdscr by the number of lines ripped off
+ */
+   for (i=0;i<linesrippedoff;i++)
+   {
+      if (linesripped[i].line < 0)
+         (*linesripped[i].init)(newwin(1,COLS,LINES-1,0),COLS);
+      else
+         (*linesripped[i].init)(newwin(1,COLS,PDC_SP->linesrippedoffontop++,0),COLS);
+      PDC_SP->linesrippedoff++;
+      LINES--;
+   }
+   linesrippedoff = 0;
+
+   if ((stdscr = newwin(LINES, COLS, PDC_SP->linesrippedoffontop, 0)) == (WINDOW *) NULL)
+   {
+      fprintf( stderr, "initscr(): Unable to create stdscr.\n" );
+      exit( 1 );
+   }
+
+   wclrtobot(stdscr);
+
+/*
+ * If preserving the existing screen don't allow a screen clear...
+ */
+if (PDC_SP->_preserve)
+   {
+   untouchwin(curscr);
+   untouchwin(stdscr);
+   stdscr->_clear = FALSE;
+   }
+
+   curscr->_clear = FALSE;
+
+#ifdef   REGISTERWINDOWS
+   PDC_SP->refreshall = FALSE;
+   _inswin(stdscr, (WINDOW *)NULL);
+#endif
+
+#if defined(CHTYPE_LONG)
+   PDC_init_atrtab(); /* set up default (BLACK on WHITE colours */
+#endif
+
+#ifdef EMXVIDEO
+   PDC_SP->tahead = -1;
+#endif
+
+   MOUSE_X_POS = MOUSE_Y_POS = (-1);
+   BUTTON_STATUS(1) = BUTTON_RELEASED;
+   BUTTON_STATUS(2) = BUTTON_RELEASED;
+   BUTTON_STATUS(3) = BUTTON_RELEASED;
+   Mouse_status.changes = 0;
+
+   PDC_SP->alive = TRUE;
+
+#ifdef UNIX
+   PDC_setup_keys();
+#else
+   def_shell_mode(); /* don't do this for UNIX as scropen has already changed things */
+#endif
+
+   return( stdscr );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW*  PDC_CDECL   initscr(void)
+#else
+WINDOW*  PDC_CDECL   initscr()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("initscr() - called\n");
+#endif
+   return (Xinitscr( 0, NULL ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL endwin(void)
+#else
+int PDC_CDECL endwin()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("endwin() - called\n");
+#endif
+
+#ifdef ORIGINAL_PDCURSES_BEHAVIOUR
+   PDC_scr_close();
+/* resetty();*/
+   if (PDC_SP->orig_font != PDC_SP->font)  /* screen has not been resized */
+   {
+      PDC_set_font(PDC_SP->orig_font);
+      resize_term(PDC_get_rows(),PDC_get_columns());
+   }
+
+   PDC_SP->visible_cursor = FALSE;   /* Force the visible cursor */
+   PDC_SP->cursor = PDC_SP->orig_cursor;
+   PDC_cursor_on();
+   /*
+    * Position cursor so that the screen will not scroll until they hit
+    * a carriage return. Do this BEFORE delwin(curscr) as PDC_gotoxy() uses
+    * curscr.
+    */
+   PDC_gotoxy(PDC_get_rows() - 2, 0);
+   delwin(stdscr);
+   delwin(curscr);
+   stdscr = (WINDOW *)NULL;
+   curscr = (WINDOW *)NULL;
+   PDC_SP->alive = FALSE;
+
+# if !defined (XCURSES)
+   if (PDC_SP)
+   {
+      fre(PDC_SP);
+      PDC_SP = (SCREEN *)NULL;
+   }
+# endif
+
+
+# ifdef  FLEXOS
+   _flexos_8bitmode();
+# endif
+/* PDC_fix_cursor(PDC_SP->orig_emulation);*/
+
+# ifdef UNIX
+   if (exit_ca_mode != NULL)
+      putp(exit_ca_mode);
+# endif
+
+# if defined(DOS) || defined(OS2)
+   reset_shell_mode();
+# endif
+
+# if DONOTKILLXFROMHERE
+#  if defined (XCURSES)
+   XCursesInstruct(CURSES_EXIT);
+   XCursesCleanupCursesProcess(0);
+#  endif
+# endif
+
+#else
+
+/*
+ * New endwin() behaviour; to allow temporary exit from curses
+ * using endwin().
+ */
+
+   PDC_scr_close();
+
+# ifdef  FLEXOS
+   _flexos_8bitmode();
+# endif
+
+# if defined(DOS) || defined(OS2)
+   reset_shell_mode();
+# endif
+
+   curs_set(1);
+   /*
+    * Position cursor to the bottom left of the screen.
+    */
+#if defined(WIN32)
+   PDC_gotoxy(PDC_get_buffer_rows() - 2, 0);
+#else
+   PDC_gotoxy(PDC_get_rows() - 2, 0);
+#endif
+
+   PDC_SP->alive = FALSE;
+
+#endif
+
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   isendwin(void)
+#else
+int   PDC_CDECL   isendwin()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("isendwin() - called\n");
+#endif
+
+   return((PDC_SP->alive) ? FALSE : TRUE);
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+SCREEN*PDC_CDECL     newterm( char *type, FILE *outfd, FILE *infd )
+#else
+SCREEN*PDC_CDECL     newterm(type,outfd,infd)
+char *type;
+FILE *outfd;
+FILE *infd;
+#endif
+/***********************************************************************/
+{
+#ifdef   TC
+#  pragma argsused
+#endif
+
+#if 0
+extern   void* mallc(); /* malloc(size)      */
+extern   void* callc(); /* calloc(num,size)  */
+extern   void  fre();      /* free(ptr)      */
+
+extern   void* malloc();
+extern   void* calloc();
+extern   void  free();
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("newterm() - called\n");
+#endif
+
+   if  (PDC_SP->alive)
+      return( ERR );
+
+   if  (use_emalloc == EMALLOC_MAGIC)
+   {
+#if   EMALLOC
+      memset(PDC_SP, 0, sizeof(SCREEN));
+      use_emalloc = TRUE;
+      mallc = emalloc;
+      callc = ecalloc;
+      fre   = efree;
+      reallc = erealloc;
+#endif
+   }
+   else
+   {
+      memset(PDC_SP, 0, sizeof(SCREEN));
+      mallc = malloc;
+      callc = calloc;
+      fre   = free;
+      reallc = realloc;
+   }
+   PDC_scr_open(PDC_SP, 0);
+   PDC_SP->orig_cursor = PDC_SP->cursor;
+   PDC_SP->orig_font = PDC_get_font();
+   PDC_SP->orgcbr = PDC_get_ctrl_break();
+   PDC_SP->blank = ' ';
+#ifdef   FLEXOS
+   _flexos_16bitmode();
+#endif
+   savetty();
+   LINES = PDC_get_rows();
+   COLS = PDC_get_columns();
+
+   if ((curscr = newwin(LINES, COLS, 0, 0)) == (WINDOW *) ERR)
+   {
+      return( ERR );
+   }
+   if ((stdscr = newwin(LINES, COLS, 0, 0)) == (WINDOW *) ERR)
+   {
+      return( ERR );
+   }
+   curscr->_clear = FALSE;
+#ifdef   REGISTERWINDOWS
+   PDC_SP->refreshall = FALSE;
+   _inswin(stdscr, (WINDOW *)NULL);
+#endif
+   PDC_SP->alive = TRUE;
+   return( PDC_SP );
+#endif
+   return(NULL);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+SCREEN*  PDC_CDECL   set_term( SCREEN *new )
+#else
+SCREEN*  PDC_CDECL   set_term(new)
+SCREEN *new;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("set_term() - called\n");
+#endif
+
+#ifdef   TC
+#  pragma argsused
+#endif
+   return( PDC_SP );  /* We only have one screen supported right now */
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   resize_term(int nlines, int ncols)
+#else
+int   PDC_CDECL   resize_term(nlines,ncols)
+int nlines,ncols;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("resize_term() - called: nlines %d\n",nlines);
+#endif
+
+   if (stdscr == (WINDOW *)NULL)
+      return(ERR);
+
+   if (PDC_resize_screen(nlines,ncols) == ERR)
+      return ( ERR );
+
+   PDC_SP->lines = PDC_get_rows();
+   LINES = PDC_SP->lines - PDC_SP->linesrippedoff - PDC_SP->slklines;
+   PDC_SP->cols  = COLS  = PDC_get_columns();
+
+   /*
+    * We need to change the saved prog_mode details...
+    */
+   if ( c_pr_tty.been_set )
+   {
+      c_pr_tty.saved.lines = PDC_SP->lines;
+      c_pr_tty.saved.cols = PDC_SP->cols;
+   }
+
+   if ((curscr = resize_window(curscr, PDC_SP->lines, PDC_SP->cols)) == NULL)
+      return (ERR);
+
+   if ((stdscr = resize_window(stdscr, LINES, COLS)) == NULL)
+      return (ERR);
+
+   if (PDC_SP->slk_winptr)
+   {
+      if ((PDC_SP->slk_winptr = resize_window(PDC_SP->slk_winptr,PDC_SP->slklines, COLS)) == NULL)
+         return (ERR);
+      wmove(PDC_SP->slk_winptr, 0, 0);
+      wclrtobot(PDC_SP->slk_winptr);
+      (*PDC_initial_slk)();
+      slk_noutrefresh();
+   }
+
+   touchwin(stdscr);
+   wnoutrefresh(stdscr);
+
+   return (OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool  PDC_CDECL   is_termresized(void)
+#else
+bool  PDC_CDECL   is_termresized()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("is_termresized() - called\n");
+#endif
+   return( PDC_SP->resized );
+}
Index: PDCurses/pdcurses/inopts.c
===================================================================
--- PDCurses/pdcurses/inopts.c	(revision 1)
+++ PDCurses/pdcurses/inopts.c	(working copy)
@@ -1,576 +1,576 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-#ifdef UNIX
-#define NOTLIB
-#include <defs.h>
-#include <term.h>
-#endif
-
-/* undefine any macros for functions defined in this module */
-#undef	cbreak
-#undef	nocbreak
-#undef	echo
-#undef	noecho
-#undef	halfdelay
-#undef	intrflush
-#undef	keypad
-#undef	meta
-#undef	nodelay
-#undef	notimeout
-#undef	raw
-#undef	noraw
-#undef	noqiflush
-#undef	qiflush
-#undef	timeout
-#undef	wtimeout
-#undef	typeahead
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef	move
-#  undef	wmove
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_inopts  = "$Id: inopts.c,v 1.1 2001/01/10 08:27:09 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                        inopts
-
-  Synopsis:
-  	int cbreak(void);
-  	int nocbreak(void);
-  	int echo(void);
-  	int noecho(void);
-  	int halfdelay(int tenths);
-  	int intrflush(WINDOW *win, bool bf);
-  	int keypad(WINDOW *win, bool bf);
-  	int meta(WINDOW *win, bool bf);
-  	int nodelay(WINDOW *win, bool bf);
-  	int notimeout(WINDOW *win, bool bf);
-  	int raw(void);
-  	int noraw(void);
-  ***	void noqiflush(void);
-  ***	void qiflush(void);
-  ***	int timeout(int delay);
-  ***	int wtimeout(WINDOW *win, int delay);
-  	int typeahead(int fildes);
-
-  X/Open Description:
- 	cbreak() and nocbreak() puts the terminal into and out of cbreak
- 	mode. In cbreak mode, characters typed by the user are immediately
- 	available to the program and erase/kill character processing is
- 	not performed.  When out of cbreak mode, the terminal driver
- 	will buffer characters typed until a newline or carriage return
- 	is typed.  Interrupt and flow control characters are unaffected
- 	by this mode.  Initially the terminal may or may not need be
- 	in cbreak mode.
-
- 	echo() and noecho() control whether characters typed by the user
- 	are echoed by the input routine.  Initially, input characters
- 	are echoed.  Subsequent calls to echo() and noecho() do not
- 	flush type-ahead.
-
- 	halfdelay is similar to cbreak() but allows for a specified time
- 	limit to be specified (in 1/10thes of a second). This causes getch()
- 	to block for that period before returning ERR if no key has been
- 	received.  tenths must be between 1 and 255.
-
- 	If the intrflush() option is enabled (bf is TRUE), and an interrupt
- 	is pressed on the keyboard (INTR, BREAK, or QUIT) all output in
- 	the terminal driver queue will be flushed, giving the effect
- 	of faster response to the interrupt but causing curses to have
- 	the wrong idea of what is on the screen.  Disabling the option
- 	prevents the flush.  The default for the option is inherited
- 	from the terminal driver settings.  The window argument is
- 	ignored.
-
- 	The keypad() function changes the keypad option of the user's terminal.
- 	If enabled (bf is TRUE), the user can press a function key (such
- 	as the left arrow key) and getch() will return a single value
- 	that represents the KEY_LEFT function key.  (See Section 11.3.3,
- 	Input Values.)  If disabled, curses will not treat function keys
- 	as special keys and the program has to interpret the escape
- 	sequences itself.  If the keypad is enabled, the terminal keypad
- 	is turned on before input begins.
-
- 	The meta() function forces the user's terminal to return 7 or 8
- 	significant bits on input.  To force 8 bits to be returned,
- 	invoke meta() with bf as TRUE.  To force 7 bits to be returned,
- 	invoke meta() with bf as FALSE.
- 	The window argument is always ignored, but it must still be a
- 	valid window to avoid compiler errors.
-
- 	The nodelay() function controls whether wgetch() is a non-blocking
- 	call. If the option is enabled, and no input is ready, wgetch()
- 	will return ERR. If disabled, wgetch() will hang until input
- 	is ready.
-
- 	While interpreting an input escape sequence, wgetch sets a timer while
- 	waiting for the next character.  If notimeout(win,TRUE) is called, then
- 	wgetch does not set a timer.  The purpose of the timeout is to
- 	differentiate between sequences received from a function key and those
- 	typed by a user.
-
- 	With raw() and noraw(), the terminal in placed into or out of raw 
- 	mode.  Raw mode is similar to cbreak mode, in that characters typed 
- 	are immediately passed through to the user program.  The differences
- 	are that in raw mode, the INTR, QUIT, SUSP, and STOP characters are 
- 	passed through without being interpreted, and without generating a
- 	signal.  The behaviour of the BREAK key depends on other
- 	parameters of the terminal drive that are not set by curses.
-
- 	The curses package does the "line-breakout optimisation" by
- 	looking for type-ahead periodically while updating the screen.
- 	If input is found, the current update will be postponed until
- 	refresh() or doupdate() are called again.  This allows faster
- 	response to commands typed in advance.  Normally, the input FILE
- 	pointer passed to newterm(), or stdin in the case when initscr()
- 	was called, will be used to do this type-ahead checking.  The
- 	typeahead() routine specified that the file descriptor fd is to
- 	be used to check for type-ahead instead.  If fd is -1, then no
- 	type-ahead checking will be done.
-
-  PDCurses Description:
- 	The meta() function is provided for portability.  By default, 8 bits
- 	are returned.
-
- 	notimeout() is a no-op in PDCurses.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      cbreak                                Y        Y       Y
-      nocbreak                              Y        Y       Y
-      echo                                  Y        Y       Y
-      noecho                                Y        Y       Y
-      halfdelay                             -        -       Y
-      intrflush                             Y        -       Y
-      keypad                                Y        -       Y
-      meta                                  -        -       Y
-      nodelay                               Y        -       Y
-      notimeout                             -        -       Y
-      raw                                   Y        Y       Y
-      noraw                                 Y        Y       Y
-      noqiflush                             -        -       Y
-      qiflush                               -        -       Y
-      timeout                               -        -       Y
-      wtimeout                              -        -       Y
-      typeahead                             Y        -       Y
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	cbreak(void)
-#else
-int	PDC_CDECL	cbreak()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("cbreak() - called\n");
-#endif
-
-#ifdef UNIX
-#ifdef USE_TERMIO
-	_CUR_TERM.prog_mode.c_lflag &= ~(ICANON);
-	_CUR_TERM.prog_mode.c_iflag &= ~(ICRNL);
-/*	_CUR_TERM.prog_mode.c_lflag |= ISIG;*/
-	_CUR_TERM.prog_mode.c_cc[VMIN] = 1;
-	_CUR_TERM.prog_mode.c_cc[VTIME] = 0;
-	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
-#else
-	_CUR_TERM.prog_mode.sg_flags |= CBREAK;
-	ioctl(_CUR_TERM.fd, TIOCSETP, &_CUR_TERM.prog_mode);
-#endif
-
-#endif
-
-	SP->cbreak = TRUE;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	nocbreak(void)
-#else
-int	PDC_CDECL	nocbreak()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("nocbreak() - called\n");
-#endif
-
-#ifdef UNIX
-#ifdef USE_TERMIO
-	_CUR_TERM.prog_mode.c_lflag |= ICANON;
-	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
-#else 
-	_CUR_TERM->prog_mode.sg_flags &= ~CBREAK;
-	ioctl(_CUR_TERM.fd, TIOCSETP,&_CUR_TERM.prog_mode);
-#endif
-#endif
-
-	SP->cbreak = FALSE;
-	SP->delaytenths = 0;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	echo(void)
-#else
-int	PDC_CDECL	echo()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("echo() - called\n");
-#endif
-
-#ifdef UNIX
-#ifdef USE_TERMIO
-	_CUR_TERM.prog_mode.c_lflag |= ECHOCTL|ECHOKE;
-	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
-#else
-	_CUR_TERM.prog_mode.sg_flags |= ECHO;
-	ioctl(_CUR_TERM.fd, TIOCSETP, &_CUR_TERM.prog_mode);
-#endif
-#endif
-
-	SP->echo = TRUE;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	noecho(void)
-#else
-int	PDC_CDECL	noecho()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("noecho() - called\n");
-#endif
-
-#ifdef UNIX
-#ifdef USE_TERMIO
-	_CUR_TERM.prog_mode.c_lflag &= ~(ECHO|ECHOPRT);
-	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
-#else
-	_CUR_TERM.prog_mode.sg_flags &= ~ECHO;
-	ioctl(_CUR_TERM.fd, TIOCSETP, &_CUR_TERM.prog_mode);
-#endif
-#endif
-
-	SP->echo = FALSE;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	halfdelay(int tenths)
-#else
-int	PDC_CDECL	halfdelay(tenths)
-int tenths;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("nodelay() - called\n");
-#endif
-	if (tenths < 1 || tenths > 255)
-		return (ERR);
-	SP->delaytenths = tenths;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	intrflush( WINDOW *win, bool bf )
-#else
-int	PDC_CDECL	intrflush(win,bf)
-WINDOW *win;
-bool bf;
-#endif
-/***********************************************************************/
-{
-#ifdef	TC
-#  pragma argsused
-#endif
-	int	y;
-	int	maxy;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("intrflush() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	maxy = win->_maxy - 1;
-
-	for (y = 0; y <= maxy; y++)
-	{
-		win->_firstch[y] = _NO_CHANGE;
-	}
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	keypad( WINDOW *win, bool bf )
-#else
-int	PDC_CDECL	keypad(win,bf)
-WINDOW *win;
-bool bf;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("keypad() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	win->_use_keypad = bf;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	meta( WINDOW *win, bool bf )
-#else
-int	PDC_CDECL	meta(win,bf)
-WINDOW *win;
-bool bf;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("meta() - called\n");
-#endif
-
-#ifdef UNIX
-/* INCOMPLETE */
-#endif
-
-#ifdef	TC
-# pragma argsused;
-#endif
-	SP->raw_inp = bf;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	nodelay( WINDOW *win, bool flag )
-#else
-int	PDC_CDECL	nodelay(win,flag)
-WINDOW *win;
-bool flag;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("nodelay() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	win->_nodelay = flag;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	notimeout( WINDOW *win, bool flag )
-#else
-int	PDC_CDECL	notimeout(win,flag)
-WINDOW *win;
-bool flag;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("notimeout() - called\n");
-#endif
-
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	raw(void)
-#else
-int	PDC_CDECL	raw()
-#endif
-/***********************************************************************/
-{
-#ifdef OS2
-# ifndef EMXVIDEO
-	KBDINFO KbdInfo;
-# endif
-#endif
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("raw() - called\n");
-#endif
-
-#ifdef OS2
-# ifndef EMXVIDEO
-	KbdGetStatus(&KbdInfo,0);
-	KbdInfo.fsMask |= KEYBOARD_BINARY_MODE;
-	KbdInfo.fsMask &= ~KEYBOARD_ASCII_MODE;
-	KbdSetStatus(&KbdInfo,0);
-# endif
-#endif
-
-#if defined( UNIX )	/* || defined( EMXVIDEO )	NOT COMPLETED */
-#ifdef USE_TERMIO
-#if 0
-	_CUR_TERM.prog_mode.c_lflag &= ~(ICANON|ISIG);
-	_CUR_TERM.prog_mode.c_iflag &= ~(INPCK|ISTRIP|IXON);
-	_CUR_TERM.prog_mode.c_oflag &= ~(OPOST);
-	_CUR_TERM.prog_mode.c_cc[VMIN] = 1;
-	_CUR_TERM.prog_mode.c_cc[VTIME] = 0;
-	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
-#endif
-	_CUR_TERM.prog_mode.c_lflag &= ~(ICANON|ISIG);
-	_CUR_TERM.prog_mode.c_iflag &= ~(IXON);
-	_CUR_TERM.prog_mode.c_iflag |= ICRNL;
-	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
-#else
-	_CUR_TERM.prog_mode.sg_flags |= RAW;
-	ioctl(_CUR_TERM.fd, TIOCSETP, &_CUR_TERM.prog_mode);
-#endif
-#endif
-
-	SP->raw_inp = TRUE;
-	PDC_set_ctrl_break(FALSE);      /* disallow ^BREAK on disk I/O */
-/*	flushinp(); */
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	noraw(void)
-#else
-int	PDC_CDECL	noraw()
-#endif
-/***********************************************************************/
-{
-#ifdef OS2
-# ifndef EMXVIDEO
-	KBDINFO KbdInfo;
-# endif
-#endif
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("noraw() - called\n");
-#endif
-
-#ifdef OS2
-# ifndef EMXVIDEO
-	KbdGetStatus(&KbdInfo,0);
-	KbdInfo.fsMask |= KEYBOARD_ASCII_MODE;
-	KbdInfo.fsMask &= ~KEYBOARD_BINARY_MODE;
-	KbdSetStatus(&KbdInfo,0);
-# endif
-#endif
-
-#if defined( UNIX ) /* || defined( EMXVIDEO ) NOT COMPLETE */
-#ifdef USE_TERMIO
-#if 0
-	_CUR_TERM.prog_mode.c_lflag |= ISIG|ICANON;
-	_CUR_TERM.prog_mode.c_iflag |= IXON|INPCK|ISTRIP;
-	_CUR_TERM.prog_mode.c_oflag |= OPOST;
-	_CUR_TERM.prog_mode.c_cc[VMIN] = _CUR_TERM.shell_mode.c_cc[VMIN];
-	_CUR_TERM.prog_mode.c_cc[VTIME] = _CUR_TERM.shell_mode.c_cc[VTIME];
-#endif
-	_CUR_TERM.prog_mode.c_lflag |= ICANON;
-	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
-#else
-	_CUR_TERM.prog_mode.sg_flags &= ~RAW;
-	ioctl(_CUR_TERM.fd, TIOCSETP, &_CUR_TERM.prog_mode);
-#endif
-#endif
-
-	SP->raw_inp = FALSE;
-	PDC_set_ctrl_break(TRUE);
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	typeahead( int fildes )
-#else
-int	PDC_CDECL	typeahead(fildes)
-int fildes;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("typeahead() - called\n");
-#endif
-
-	if (fildes < 0)
-		SP->refrbrk = FALSE;
-	else
-		SP->refrbrk = TRUE;
-	return(OK);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	timeout( int delay )
-#else
-int	PDC_CDECL	timeout(delay)
-int delay;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("timeout() - called\n");
-#endif
-/*************** this does nothing at the moment *************/
-	return(OK);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	wtimeout( WINDOW *win, int delay )
-#else
-int	PDC_CDECL	wtimeout(win,delay)
-WINDOW *win;
-int delay;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wtimeout() - called\n");
-#endif
-/*************** this does nothing at the moment *************/
-	return(OK);
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef UNIX
+#define NOTLIB
+#include <defs.h>
+#include <term.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef	cbreak
+#undef	nocbreak
+#undef	echo
+#undef	noecho
+#undef	halfdelay
+#undef	intrflush
+#undef	keypad
+#undef	meta
+#undef	nodelay
+#undef	notimeout
+#undef	raw
+#undef	noraw
+#undef	noqiflush
+#undef	qiflush
+#undef	timeout
+#undef	wtimeout
+#undef	typeahead
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	move
+#  undef	wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_inopts  = "$Id: inopts.c,v 1.1 2001/01/10 08:27:09 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        inopts
+
+  Synopsis:
+  	int cbreak(void);
+  	int nocbreak(void);
+  	int echo(void);
+  	int noecho(void);
+  	int halfdelay(int tenths);
+  	int intrflush(WINDOW *win, bool bf);
+  	int keypad(WINDOW *win, bool bf);
+  	int meta(WINDOW *win, bool bf);
+  	int nodelay(WINDOW *win, bool bf);
+  	int notimeout(WINDOW *win, bool bf);
+  	int raw(void);
+  	int noraw(void);
+  ***	void noqiflush(void);
+  ***	void qiflush(void);
+  ***	int timeout(int delay);
+  ***	int wtimeout(WINDOW *win, int delay);
+  	int typeahead(int fildes);
+
+  X/Open Description:
+ 	cbreak() and nocbreak() puts the terminal into and out of cbreak
+ 	mode. In cbreak mode, characters typed by the user are immediately
+ 	available to the program and erase/kill character processing is
+ 	not performed.  When out of cbreak mode, the terminal driver
+ 	will buffer characters typed until a newline or carriage return
+ 	is typed.  Interrupt and flow control characters are unaffected
+ 	by this mode.  Initially the terminal may or may not need be
+ 	in cbreak mode.
+
+ 	echo() and noecho() control whether characters typed by the user
+ 	are echoed by the input routine.  Initially, input characters
+ 	are echoed.  Subsequent calls to echo() and noecho() do not
+ 	flush type-ahead.
+
+ 	halfdelay is similar to cbreak() but allows for a specified time
+ 	limit to be specified (in 1/10thes of a second). This causes getch()
+ 	to block for that period before returning ERR if no key has been
+ 	received.  tenths must be between 1 and 255.
+
+ 	If the intrflush() option is enabled (bf is TRUE), and an interrupt
+ 	is pressed on the keyboard (INTR, BREAK, or QUIT) all output in
+ 	the terminal driver queue will be flushed, giving the effect
+ 	of faster response to the interrupt but causing curses to have
+ 	the wrong idea of what is on the screen.  Disabling the option
+ 	prevents the flush.  The default for the option is inherited
+ 	from the terminal driver settings.  The window argument is
+ 	ignored.
+
+ 	The keypad() function changes the keypad option of the user's terminal.
+ 	If enabled (bf is TRUE), the user can press a function key (such
+ 	as the left arrow key) and getch() will return a single value
+ 	that represents the KEY_LEFT function key.  (See Section 11.3.3,
+ 	Input Values.)  If disabled, curses will not treat function keys
+ 	as special keys and the program has to interpret the escape
+ 	sequences itself.  If the keypad is enabled, the terminal keypad
+ 	is turned on before input begins.
+
+ 	The meta() function forces the user's terminal to return 7 or 8
+ 	significant bits on input.  To force 8 bits to be returned,
+ 	invoke meta() with bf as TRUE.  To force 7 bits to be returned,
+ 	invoke meta() with bf as FALSE.
+ 	The window argument is always ignored, but it must still be a
+ 	valid window to avoid compiler errors.
+
+ 	The nodelay() function controls whether wgetch() is a non-blocking
+ 	call. If the option is enabled, and no input is ready, wgetch()
+ 	will return ERR. If disabled, wgetch() will hang until input
+ 	is ready.
+
+ 	While interpreting an input escape sequence, wgetch sets a timer while
+ 	waiting for the next character.  If notimeout(win,TRUE) is called, then
+ 	wgetch does not set a timer.  The purpose of the timeout is to
+ 	differentiate between sequences received from a function key and those
+ 	typed by a user.
+
+ 	With raw() and noraw(), the terminal in placed into or out of raw 
+ 	mode.  Raw mode is similar to cbreak mode, in that characters typed 
+ 	are immediately passed through to the user program.  The differences
+ 	are that in raw mode, the INTR, QUIT, SUSP, and STOP characters are 
+ 	passed through without being interpreted, and without generating a
+ 	signal.  The behaviour of the BREAK key depends on other
+ 	parameters of the terminal drive that are not set by curses.
+
+ 	The curses package does the "line-breakout optimisation" by
+ 	looking for type-ahead periodically while updating the screen.
+ 	If input is found, the current update will be postponed until
+ 	refresh() or doupdate() are called again.  This allows faster
+ 	response to commands typed in advance.  Normally, the input FILE
+ 	pointer passed to newterm(), or stdin in the case when initscr()
+ 	was called, will be used to do this type-ahead checking.  The
+ 	typeahead() routine specified that the file descriptor fd is to
+ 	be used to check for type-ahead instead.  If fd is -1, then no
+ 	type-ahead checking will be done.
+
+  PDCurses Description:
+ 	The meta() function is provided for portability.  By default, 8 bits
+ 	are returned.
+
+ 	notimeout() is a no-op in PDCurses.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      cbreak                                Y        Y       Y
+      nocbreak                              Y        Y       Y
+      echo                                  Y        Y       Y
+      noecho                                Y        Y       Y
+      halfdelay                             -        -       Y
+      intrflush                             Y        -       Y
+      keypad                                Y        -       Y
+      meta                                  -        -       Y
+      nodelay                               Y        -       Y
+      notimeout                             -        -       Y
+      raw                                   Y        Y       Y
+      noraw                                 Y        Y       Y
+      noqiflush                             -        -       Y
+      qiflush                               -        -       Y
+      timeout                               -        -       Y
+      wtimeout                              -        -       Y
+      typeahead                             Y        -       Y
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	cbreak(void)
+#else
+int	PDC_CDECL	cbreak()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("cbreak() - called\n");
+#endif
+
+#ifdef UNIX
+#ifdef USE_TERMIO
+	_CUR_TERM.prog_mode.c_lflag &= ~(ICANON);
+	_CUR_TERM.prog_mode.c_iflag &= ~(ICRNL);
+/*	_CUR_TERM.prog_mode.c_lflag |= ISIG;*/
+	_CUR_TERM.prog_mode.c_cc[VMIN] = 1;
+	_CUR_TERM.prog_mode.c_cc[VTIME] = 0;
+	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
+#else
+	_CUR_TERM.prog_mode.sg_flags |= CBREAK;
+	ioctl(_CUR_TERM.fd, TIOCSETP, &_CUR_TERM.prog_mode);
+#endif
+
+#endif
+
+	PDC_SP->cbreak = TRUE;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	nocbreak(void)
+#else
+int	PDC_CDECL	nocbreak()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("nocbreak() - called\n");
+#endif
+
+#ifdef UNIX
+#ifdef USE_TERMIO
+	_CUR_TERM.prog_mode.c_lflag |= ICANON;
+	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
+#else 
+	_CUR_TERM->prog_mode.sg_flags &= ~CBREAK;
+	ioctl(_CUR_TERM.fd, TIOCSETP,&_CUR_TERM.prog_mode);
+#endif
+#endif
+
+	PDC_SP->cbreak = FALSE;
+	PDC_SP->delaytenths = 0;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	echo(void)
+#else
+int	PDC_CDECL	echo()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("echo() - called\n");
+#endif
+
+#ifdef UNIX
+#ifdef USE_TERMIO
+	_CUR_TERM.prog_mode.c_lflag |= ECHOCTL|ECHOKE;
+	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
+#else
+	_CUR_TERM.prog_mode.sg_flags |= ECHO;
+	ioctl(_CUR_TERM.fd, TIOCSETP, &_CUR_TERM.prog_mode);
+#endif
+#endif
+
+	PDC_SP->echo = TRUE;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	noecho(void)
+#else
+int	PDC_CDECL	noecho()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("noecho() - called\n");
+#endif
+
+#ifdef UNIX
+#ifdef USE_TERMIO
+	_CUR_TERM.prog_mode.c_lflag &= ~(ECHO|ECHOPRT);
+	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
+#else
+	_CUR_TERM.prog_mode.sg_flags &= ~ECHO;
+	ioctl(_CUR_TERM.fd, TIOCSETP, &_CUR_TERM.prog_mode);
+#endif
+#endif
+
+	PDC_SP->echo = FALSE;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	halfdelay(int tenths)
+#else
+int	PDC_CDECL	halfdelay(tenths)
+int tenths;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("nodelay() - called\n");
+#endif
+	if (tenths < 1 || tenths > 255)
+		return (ERR);
+	PDC_SP->delaytenths = tenths;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	intrflush( WINDOW *win, bool bf )
+#else
+int	PDC_CDECL	intrflush(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef	TC
+#  pragma argsused
+#endif
+	int	y;
+	int	maxy;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("intrflush() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	maxy = win->_maxy - 1;
+
+	for (y = 0; y <= maxy; y++)
+	{
+		win->_firstch[y] = _NO_CHANGE;
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	keypad( WINDOW *win, bool bf )
+#else
+int	PDC_CDECL	keypad(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("keypad() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	win->_use_keypad = bf;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	meta( WINDOW *win, bool bf )
+#else
+int	PDC_CDECL	meta(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("meta() - called\n");
+#endif
+
+#ifdef UNIX
+/* INCOMPLETE */
+#endif
+
+#ifdef	TC
+# pragma argsused;
+#endif
+	PDC_SP->raw_inp = bf;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	nodelay( WINDOW *win, bool flag )
+#else
+int	PDC_CDECL	nodelay(win,flag)
+WINDOW *win;
+bool flag;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("nodelay() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	win->_nodelay = flag;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	notimeout( WINDOW *win, bool flag )
+#else
+int	PDC_CDECL	notimeout(win,flag)
+WINDOW *win;
+bool flag;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("notimeout() - called\n");
+#endif
+
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	raw(void)
+#else
+int	PDC_CDECL	raw()
+#endif
+/***********************************************************************/
+{
+#ifdef OS2
+# ifndef EMXVIDEO
+	KBDINFO KbdInfo;
+# endif
+#endif
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("raw() - called\n");
+#endif
+
+#ifdef OS2
+# ifndef EMXVIDEO
+	KbdGetStatus(&KbdInfo,0);
+	KbdInfo.fsMask |= KEYBOARD_BINARY_MODE;
+	KbdInfo.fsMask &= ~KEYBOARD_ASCII_MODE;
+	KbdSetStatus(&KbdInfo,0);
+# endif
+#endif
+
+#if defined( UNIX )	/* || defined( EMXVIDEO )	NOT COMPLETED */
+#ifdef USE_TERMIO
+#if 0
+	_CUR_TERM.prog_mode.c_lflag &= ~(ICANON|ISIG);
+	_CUR_TERM.prog_mode.c_iflag &= ~(INPCK|ISTRIP|IXON);
+	_CUR_TERM.prog_mode.c_oflag &= ~(OPOST);
+	_CUR_TERM.prog_mode.c_cc[VMIN] = 1;
+	_CUR_TERM.prog_mode.c_cc[VTIME] = 0;
+	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
+#endif
+	_CUR_TERM.prog_mode.c_lflag &= ~(ICANON|ISIG);
+	_CUR_TERM.prog_mode.c_iflag &= ~(IXON);
+	_CUR_TERM.prog_mode.c_iflag |= ICRNL;
+	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
+#else
+	_CUR_TERM.prog_mode.sg_flags |= RAW;
+	ioctl(_CUR_TERM.fd, TIOCSETP, &_CUR_TERM.prog_mode);
+#endif
+#endif
+
+	PDC_SP->raw_inp = TRUE;
+	PDC_set_ctrl_break(FALSE);      /* disallow ^BREAK on disk I/O */
+/*	flushinp(); */
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	noraw(void)
+#else
+int	PDC_CDECL	noraw()
+#endif
+/***********************************************************************/
+{
+#ifdef OS2
+# ifndef EMXVIDEO
+	KBDINFO KbdInfo;
+# endif
+#endif
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("noraw() - called\n");
+#endif
+
+#ifdef OS2
+# ifndef EMXVIDEO
+	KbdGetStatus(&KbdInfo,0);
+	KbdInfo.fsMask |= KEYBOARD_ASCII_MODE;
+	KbdInfo.fsMask &= ~KEYBOARD_BINARY_MODE;
+	KbdSetStatus(&KbdInfo,0);
+# endif
+#endif
+
+#if defined( UNIX ) /* || defined( EMXVIDEO ) NOT COMPLETE */
+#ifdef USE_TERMIO
+#if 0
+	_CUR_TERM.prog_mode.c_lflag |= ISIG|ICANON;
+	_CUR_TERM.prog_mode.c_iflag |= IXON|INPCK|ISTRIP;
+	_CUR_TERM.prog_mode.c_oflag |= OPOST;
+	_CUR_TERM.prog_mode.c_cc[VMIN] = _CUR_TERM.shell_mode.c_cc[VMIN];
+	_CUR_TERM.prog_mode.c_cc[VTIME] = _CUR_TERM.shell_mode.c_cc[VTIME];
+#endif
+	_CUR_TERM.prog_mode.c_lflag |= ICANON;
+	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
+#else
+	_CUR_TERM.prog_mode.sg_flags &= ~RAW;
+	ioctl(_CUR_TERM.fd, TIOCSETP, &_CUR_TERM.prog_mode);
+#endif
+#endif
+
+	PDC_SP->raw_inp = FALSE;
+	PDC_set_ctrl_break(TRUE);
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	typeahead( int fildes )
+#else
+int	PDC_CDECL	typeahead(fildes)
+int fildes;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("typeahead() - called\n");
+#endif
+
+	if (fildes < 0)
+		PDC_SP->refrbrk = FALSE;
+	else
+		PDC_SP->refrbrk = TRUE;
+	return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	timeout( int delay )
+#else
+int	PDC_CDECL	timeout(delay)
+int delay;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("timeout() - called\n");
+#endif
+/*************** this does nothing at the moment *************/
+	return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wtimeout( WINDOW *win, int delay )
+#else
+int	PDC_CDECL	wtimeout(win,delay)
+WINDOW *win;
+int delay;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wtimeout() - called\n");
+#endif
+/*************** this does nothing at the moment *************/
+	return(OK);
+}
Index: PDCurses/pdcurses/outopts.c
===================================================================
--- PDCurses/pdcurses/outopts.c	(revision 1)
+++ PDCurses/pdcurses/outopts.c	(working copy)
@@ -1,392 +1,392 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	clearok
-#undef	idlok
-#undef	idcok
-#undef	immedok
-#undef	leaveok
-#undef	setscrreg
-#undef	wsetscrreg
-#undef	scrollok
-#undef	nl
-#undef	nonl
-#undef	raw_output
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_outopts  = "$Id: outopts.c,v 1.1 2001/01/10 08:27:17 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                       outopts
-
-  Synopsis:
-  	int clearok(WINDOW *win, bool bf);
-  	int idlok( WINDOW *win, bool bf );
-  	int idcok( WINDOW *win, bool bf );
-  	int immedok( WINDOW *win, bool bf );
-  	int leaveok( WINDOW *win, bool bf );
-  	int setscrreg(int top, int bot);
-  	int wsetscrreg(WINDOW *win, int top, int bot);
-  	int scrollok(WINDOW *win, bool bf);
-  	int nl(void);
-  	int nonl(void);
-
-  	int raw_output(bool bf);
-
-  X/Open Description:
- 	With the clearok() routine, if bf is TRUE, the next call to 
- 	wrefresh() with this window will clear the screen completely 
- 	and redraw the entire screen.
-
- 	If idlok() is enabled (bf is TRUE), curses will use the insert/delete
- 	line feature of terminals so equipped.  If disabled, curses will not
- 	use this feature.  (The insert/delete character feature is always
- 	used.)  This option should be enabled only if the application
- 	needs insert/delete line; for example, for a screen editor.  It
- 	is disabled by default because insert/delete line tends to be
- 	visually annoying when used in applications where it isn't really
- 	needed.  If insert/delete line cannot be used, curses will redraw
- 	the changed portions of all lines.
-
- 	With the idcok() routine, if enabled (bf is TRUE), curses considers
- 	using the hardware insert/delete character feature of terminals so 
- 	equipped. This is enabled by default.
-
- 	The immedok() routine, called with a second argument of TRUE, 
- 	causes an automatic wrefrsh() to be called on the window every time
- 	a change is made to that window, due to calls like; waddch(),
- 	wclrtoeol(), etc... Not surprisingly, this causes a severe performance
- 	overhead.
-
- 	Normally, the hardware cursor is left at the location of the
- 	window being refreshed.  leaveok() allows the cursor to be
- 	left wherever the update happens to leave it.  It is useful
- 	for applications where the cursor is not used, since it reduces
- 	the need for cursor motions.  If possible, the cursor is made
- 	invisible when this option is enabled.
-
- 	The setscrreg() and wsetscrreg() functions allow the user to set 
- 	a software scrolling region in a window.  The parameters 'top' 
- 	and 'bot' are the line numbers of the top and bottom margin of the 
- 	scrolling region.  (Line 0 is the top line of the window.)  If this 
- 	option and scrollok() are enabled, an attempt to move off the bottom 
- 	margin will cause all lines in the scrolling region to scroll up one 
- 	line.  Only the text of the window is scrolled.
-
- 	The nl() function enables the translation of newline into a
- 	carriage return and a line-feed on output, and a carriage return
- 	is translated into a newline on input.  Initially, the translations
- 	do occur.  By disabling these translations, curses is able to
- 	make better use of the line-feed capability, resulting in faster
- 	cursor motion.
-
- 	The nonl() function disables the translation of newline into a
- 	carriage return and a line-feed on output, and a carriage return
- 	is translated into a newline on input.  Initially, the translations
- 	do occur.  By disabling these translations, curses is able to
- 	make better use of the line-feed capability, resulting in faster
- 	cursor motion.
-
-  PDCurses Description:
- 	idlok() and idcok() are provided for portability.  
- 	This may have some value for the FLEXOS platform, but there is 
- 	no code in PDCurses at this time (910725) that takes advantage 
- 	of this.
-
- 	Though not explicitly stated, the cursor will be made visible
- 	again, if leaveok() is passed a FALSE value.
- 			(Frotz:911226 Comments?)
-
- 	The raw_output() routine enables the output of raw characters using 
- 	the 'standard' *add* and *ins* curses functions.
- 	To force 8 bit output and no translation of control characters,
- 	invoke raw_output() with bf as TRUE.  To force 7 bit output and
- 	translation of control characters, invoke raw_output() with bf
- 	as FALSE.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      clearok                               Y        Y       Y
-      idlok                                 Y        Y       Y
-      idcok                                 -        -      4.0
-      immedok                               -        -      4.0
-      leaveok                               Y        Y       Y
-      setscrreg                             Y        Y       Y
-      wsetscrreg                            Y        Y       Y
-      scrollok                              Y        Y       Y
-      nl                                    Y        Y       Y
-      nonl                                  Y        Y       Y
-      raw_output                            -        -       -
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	clearok(WINDOW *win, bool bf)
-#else
-int	PDC_CDECL	clearok(win,bf)
-WINDOW *win;
-bool bf;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("clearok() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	win->_clear = bf;
-#if 0
-	if( bf )
-		touchwin( win );
-#endif
-
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	idlok( WINDOW *win, bool bf )
-#else
-int	PDC_CDECL	idlok(win,bf)
-WINDOW *win;
-bool bf;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("idlok() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	win->_use_idl = bf;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	idcok( WINDOW *win, bool bf )
-#else
-int	PDC_CDECL	idcok(win,bf)
-WINDOW *win;
-bool bf;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("idcok() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	win->_use_idc = bf;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	immedok( WINDOW *win, bool bf )
-#else
-int	PDC_CDECL	immedok(win,bf)
-WINDOW *win;
-bool bf;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("immedok() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	win->_immed = bf;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	leaveok( WINDOW *win, bool bf )
-#else
-int	PDC_CDECL	leaveok(win,bf)
-WINDOW *win;
-bool bf;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("leaveok() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if  ((win->_leaveit = bf) != 0)	PDC_cursor_off();
-	else				PDC_cursor_on();
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	setscrreg(int top, int bottom)
-#else
-int	PDC_CDECL	setscrreg(top,bottom)
-int top;
-int bottom;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("setscrreg() - called: top %d bottom %d\n",top,bottom);
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return (ERR);
-
-	if ((0 <= top) &&
-	    (top <= stdscr->_cury) &&
-	    (stdscr->_cury <= bottom) &&
-	    (bottom < LINES))
-	{
-		stdscr->_tmarg = top;
-		stdscr->_bmarg = bottom;
-		return (OK);
-	}
-	else
-	{
-		return (ERR);
-	}
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	wsetscrreg(WINDOW *win, int top, int bottom)
-#else
-int	PDC_CDECL	wsetscrreg(win,top,bottom)
-WINDOW *win;
-int top;
-int bottom;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wsetscrreg() - called: top %d bottom %d\n",top,bottom);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return (ERR);
-
-	if ((0 <= top) &&
-	    (top <= win->_cury) &&
-	    (win->_cury <= bottom) &&
-	    (bottom < win->_maxy))
-	{
-		win->_tmarg = top;
-		win->_bmarg = bottom;
-		return (OK);
-	}
-	else
-	{
-		return (ERR);
-	}
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	scrollok(WINDOW *win, bool bf)
-#else
-int	PDC_CDECL	scrollok(win,bf)
-WINDOW *win;
-bool bf;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("scrollok() - called\n");
-#endif
-
-	if  (win == (WINDOW *)NULL)
-		return( ERR );
-
-	win->_scroll	= bf;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	nl(void)
-#else
-int	PDC_CDECL	nl()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("nl() - called\n");
-#endif
-
-	SP->autocr = TRUE;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	nonl(void)
-#else
-int	PDC_CDECL	nonl()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("nonl() - called\n");
-#endif
-
-	SP->autocr = FALSE;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	raw_output(bool bf)
-#else
-int	PDC_CDECL	raw_output(bf)
-bool bf;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("raw_output() - called\n");
-#endif
-
-	SP->raw_out = bf;
-	return( OK );
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	clearok
+#undef	idlok
+#undef	idcok
+#undef	immedok
+#undef	leaveok
+#undef	setscrreg
+#undef	wsetscrreg
+#undef	scrollok
+#undef	nl
+#undef	nonl
+#undef	raw_output
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_outopts  = "$Id: outopts.c,v 1.1 2001/01/10 08:27:17 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                       outopts
+
+  Synopsis:
+  	int clearok(WINDOW *win, bool bf);
+  	int idlok( WINDOW *win, bool bf );
+  	int idcok( WINDOW *win, bool bf );
+  	int immedok( WINDOW *win, bool bf );
+  	int leaveok( WINDOW *win, bool bf );
+  	int setscrreg(int top, int bot);
+  	int wsetscrreg(WINDOW *win, int top, int bot);
+  	int scrollok(WINDOW *win, bool bf);
+  	int nl(void);
+  	int nonl(void);
+
+  	int raw_output(bool bf);
+
+  X/Open Description:
+ 	With the clearok() routine, if bf is TRUE, the next call to 
+ 	wrefresh() with this window will clear the screen completely 
+ 	and redraw the entire screen.
+
+ 	If idlok() is enabled (bf is TRUE), curses will use the insert/delete
+ 	line feature of terminals so equipped.  If disabled, curses will not
+ 	use this feature.  (The insert/delete character feature is always
+ 	used.)  This option should be enabled only if the application
+ 	needs insert/delete line; for example, for a screen editor.  It
+ 	is disabled by default because insert/delete line tends to be
+ 	visually annoying when used in applications where it isn't really
+ 	needed.  If insert/delete line cannot be used, curses will redraw
+ 	the changed portions of all lines.
+
+ 	With the idcok() routine, if enabled (bf is TRUE), curses considers
+ 	using the hardware insert/delete character feature of terminals so 
+ 	equipped. This is enabled by default.
+
+ 	The immedok() routine, called with a second argument of TRUE, 
+ 	causes an automatic wrefrsh() to be called on the window every time
+ 	a change is made to that window, due to calls like; waddch(),
+ 	wclrtoeol(), etc... Not surprisingly, this causes a severe performance
+ 	overhead.
+
+ 	Normally, the hardware cursor is left at the location of the
+ 	window being refreshed.  leaveok() allows the cursor to be
+ 	left wherever the update happens to leave it.  It is useful
+ 	for applications where the cursor is not used, since it reduces
+ 	the need for cursor motions.  If possible, the cursor is made
+ 	invisible when this option is enabled.
+
+ 	The setscrreg() and wsetscrreg() functions allow the user to set 
+ 	a software scrolling region in a window.  The parameters 'top' 
+ 	and 'bot' are the line numbers of the top and bottom margin of the 
+ 	scrolling region.  (Line 0 is the top line of the window.)  If this 
+ 	option and scrollok() are enabled, an attempt to move off the bottom 
+ 	margin will cause all lines in the scrolling region to scroll up one 
+ 	line.  Only the text of the window is scrolled.
+
+ 	The nl() function enables the translation of newline into a
+ 	carriage return and a line-feed on output, and a carriage return
+ 	is translated into a newline on input.  Initially, the translations
+ 	do occur.  By disabling these translations, curses is able to
+ 	make better use of the line-feed capability, resulting in faster
+ 	cursor motion.
+
+ 	The nonl() function disables the translation of newline into a
+ 	carriage return and a line-feed on output, and a carriage return
+ 	is translated into a newline on input.  Initially, the translations
+ 	do occur.  By disabling these translations, curses is able to
+ 	make better use of the line-feed capability, resulting in faster
+ 	cursor motion.
+
+  PDCurses Description:
+ 	idlok() and idcok() are provided for portability.  
+ 	This may have some value for the FLEXOS platform, but there is 
+ 	no code in PDCurses at this time (910725) that takes advantage 
+ 	of this.
+
+ 	Though not explicitly stated, the cursor will be made visible
+ 	again, if leaveok() is passed a FALSE value.
+ 			(Frotz:911226 Comments?)
+
+ 	The raw_output() routine enables the output of raw characters using 
+ 	the 'standard' *add* and *ins* curses functions.
+ 	To force 8 bit output and no translation of control characters,
+ 	invoke raw_output() with bf as TRUE.  To force 7 bit output and
+ 	translation of control characters, invoke raw_output() with bf
+ 	as FALSE.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      clearok                               Y        Y       Y
+      idlok                                 Y        Y       Y
+      idcok                                 -        -      4.0
+      immedok                               -        -      4.0
+      leaveok                               Y        Y       Y
+      setscrreg                             Y        Y       Y
+      wsetscrreg                            Y        Y       Y
+      scrollok                              Y        Y       Y
+      nl                                    Y        Y       Y
+      nonl                                  Y        Y       Y
+      raw_output                            -        -       -
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	clearok(WINDOW *win, bool bf)
+#else
+int	PDC_CDECL	clearok(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("clearok() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	win->_clear = bf;
+#if 0
+	if( bf )
+		touchwin( win );
+#endif
+
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	idlok( WINDOW *win, bool bf )
+#else
+int	PDC_CDECL	idlok(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("idlok() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	win->_use_idl = bf;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	idcok( WINDOW *win, bool bf )
+#else
+int	PDC_CDECL	idcok(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("idcok() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	win->_use_idc = bf;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	immedok( WINDOW *win, bool bf )
+#else
+int	PDC_CDECL	immedok(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("immedok() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	win->_immed = bf;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	leaveok( WINDOW *win, bool bf )
+#else
+int	PDC_CDECL	leaveok(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("leaveok() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if  ((win->_leaveit = bf) != 0)	PDC_cursor_off();
+	else				PDC_cursor_on();
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	setscrreg(int top, int bottom)
+#else
+int	PDC_CDECL	setscrreg(top,bottom)
+int top;
+int bottom;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("setscrreg() - called: top %d bottom %d\n",top,bottom);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return (ERR);
+
+	if ((0 <= top) &&
+	    (top <= stdscr->_cury) &&
+	    (stdscr->_cury <= bottom) &&
+	    (bottom < LINES))
+	{
+		stdscr->_tmarg = top;
+		stdscr->_bmarg = bottom;
+		return (OK);
+	}
+	else
+	{
+		return (ERR);
+	}
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wsetscrreg(WINDOW *win, int top, int bottom)
+#else
+int	PDC_CDECL	wsetscrreg(win,top,bottom)
+WINDOW *win;
+int top;
+int bottom;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wsetscrreg() - called: top %d bottom %d\n",top,bottom);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return (ERR);
+
+	if ((0 <= top) &&
+	    (top <= win->_cury) &&
+	    (win->_cury <= bottom) &&
+	    (bottom < win->_maxy))
+	{
+		win->_tmarg = top;
+		win->_bmarg = bottom;
+		return (OK);
+	}
+	else
+	{
+		return (ERR);
+	}
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	scrollok(WINDOW *win, bool bf)
+#else
+int	PDC_CDECL	scrollok(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("scrollok() - called\n");
+#endif
+
+	if  (win == (WINDOW *)NULL)
+		return( ERR );
+
+	win->_scroll	= bf;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	nl(void)
+#else
+int	PDC_CDECL	nl()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("nl() - called\n");
+#endif
+
+	PDC_SP->autocr = TRUE;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	nonl(void)
+#else
+int	PDC_CDECL	nonl()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("nonl() - called\n");
+#endif
+
+	PDC_SP->autocr = FALSE;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	raw_output(bool bf)
+#else
+int	PDC_CDECL	raw_output(bf)
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("raw_output() - called\n");
+#endif
+
+	PDC_SP->raw_out = bf;
+	return( OK );
+}
Index: PDCurses/pdcurses/pdcdebug.c
===================================================================
--- PDCurses/pdcurses/pdcdebug.c	(revision 1)
+++ PDCurses/pdcurses/pdcdebug.c	(working copy)
@@ -1,101 +1,101 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define  CURSES_LIBRARY 1
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif
-#include <curses.h>
-
-#include <string.h>
-#include <sys/types.h>
-#include <time.h>
-
-
-#undef   PDC_debug
-
-#if defined(HAVE_STDARG_H) && defined(HAVE_PROTO)
-# include <stdarg.h>
-# define HAVE_STDARG_H_HAVE_PROTO
-#else
-# include <varargs.h>
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_PDCdebug  = "$Id: pdcdebug.c,v 1.2 2002/06/23 04:13:02 mark Exp $";
-#endif
-
-   bool trace_on = FALSE;
-
-/*man-start*********************************************************************
-
-  PDC_debug()  - Write debugging info to log file.
-
-  PDCurses Description:
-   This is a private PDCurses routine.
-
-  PDCurses Return Value:
-   No return value.
-
-  PDCurses Errors:
-   No errors are defined for this function.
-
-  Portability:
-   PDCurses void PDC_debug( char *,... );
-
-**man-end**********************************************************************/
-
-#ifdef HAVE_STDARG_H_HAVE_PROTO
-void  PDC_CDECL   PDC_debug( char *fmt, ... )
-#else
-void  PDC_CDECL   PDC_debug(fmt,va_alist)
-char *fmt;
-va_dcl
-#endif
-{
-   va_list args;
-   FILE *dbfp=NULL;
-   char buffer[256];
-
-   /*
-    * open debug log file append
-    */
-   buffer[0] = '\0';
-   if (!trace_on)
-      return; 
-   dbfp = fopen("trace","a");
-   if (dbfp == NULL)
-   {
-      fprintf( stderr, "PDC_debug(): Unable to open debug log file\n" );
-      return;
-   }
-
-#ifdef HAVE_STDARG_H_HAVE_PROTO
-   va_start(args, fmt);
-#else
-   va_start(args);
-#endif
-
-   fprintf( dbfp, "At: %8.8d - %d secs ", clock(), clock() / CLOCKS_PER_SEC );
-   vsprintf(buffer,fmt,args);
-   fputs(buffer,dbfp);
-   va_end(args);
-   fclose(dbfp);
-   return;
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define  CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+#include <curses.h>
+
+#include <string.h>
+#include <sys/types.h>
+#include <time.h>
+
+
+#undef   PDC_debug
+
+#if defined(HAVE_STDARG_H) && defined(HAVE_PROTO)
+# include <stdarg.h>
+# define HAVE_STDARG_H_HAVE_PROTO
+#else
+# include <varargs.h>
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_PDCdebug  = "$Id: pdcdebug.c,v 1.2 2002/06/23 04:13:02 mark Exp $";
+#endif
+
+   bool trace_on = FALSE;
+
+/*man-start*********************************************************************
+
+  PDC_debug()  - Write debugging info to log file.
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+  PDCurses Return Value:
+   No return value.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses void PDC_debug( char *,... );
+
+**man-end**********************************************************************/
+
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+void  PDC_CDECL   PDC_debug( char *fmt, ... )
+#else
+void  PDC_CDECL   PDC_debug(fmt,va_alist)
+char *fmt;
+va_dcl
+#endif
+{
+   va_list args;
+   FILE *dbfp=NULL;
+   char buffer[256];
+
+   /*
+    * open debug log file append
+    */
+   buffer[0] = '\0';
+   if (!trace_on)
+      return; 
+   dbfp = fopen("trace","a");
+   if (dbfp == NULL)
+   {
+      fprintf( stderr, "PDC_debug(): Unable to open debug log file\n" );
+      return;
+   }
+
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+   va_start(args, fmt);
+#else
+   va_start(args);
+#endif
+
+   fprintf( dbfp, "At: %8.8d - %d secs ", clock(), clock() / CLOCKS_PER_SEC );
+   vsprintf(buffer,fmt,args);
+   fputs(buffer,dbfp);
+   va_end(args);
+   fclose(dbfp);
+   return;
+}
Index: PDCurses/pdcurses/border.c
===================================================================
--- PDCurses/pdcurses/border.c	(revision 1)
+++ PDCurses/pdcurses/border.c	(working copy)
@@ -1,581 +1,581 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	border
-#undef	wborder
-#undef	box
-#undef	hline
-#undef	whline
-#undef	vline
-#undef	wvline
-#undef	PDC_wunderline
-#undef	PDC_leftline
-#undef	PDC_rightline
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_border  = "$Id: border.c,v 1.3 2001/03/02 13:40:26 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                        border
-
-  Synopsis:
-  	int border(chtype ls, chtype rs, chtype ts, chtype bs, chtype tl, 
-  	           chtype tr, chtype bl, chtype br);
-  	int wborder(WINDOW *win, chtype ls, chtype rs, chtype ts, 
-  	            chtype bs, chtype tl, chtype tr, chtype bl, chtype br);
-  	int box(WINDOW *win, chtype verch, chtype horch);
-  	int hline(chtype ch, int n);
-  	int vline(chtype ch, int n);
-  	int whline(WINDOW *win, chtype ch, int n);
-  	int wvline(WINDOW *win, chtype ch, int n);
-  	int PDC_wunderline(WINDOW *win, int n, bool state);
-  	int PDC_wleftline(WINDOW *win, int n, bool state);
-  	int PDC_wrightline(WINDOW *win, int n, bool state);
-
-  X/Open Description:
- 	The border(), wborder(), and box() routines, a border is drawn
- 	around the edge of the window. If any of the arguments is zero,
- 	an appropriate default is used. These default values are specified
- 	in <curses.h>. The arguments and defaults to these functions are:
- 		ls	left side of border		ACS_VLINE
- 		rs	right side of border		ACS_VLINE
- 		ts	top side of border		ACS_HLINE
- 		bs	bottom side of border		ACS_HLINE
- 		tl	top left corner of border	ACS_ULCORNER
- 		tr	top right corner of border	ACS_URCORNER
- 		bl	bottom left corner of border	ACS_BLCORNER
- 		br	bottom right corner of border	ACS_BLCORNER
-
- 	The hline() and whline() functions draw a left to right line
- 	using ch starting from the current cursor position. The cursor
- 	position does not change. The line is at most n characters long
- 	or as many as will fit in the window.
-
- 	The vline() and wvline() functions draw a top to bottom line
- 	using ch starting from the current cursor position. The cursor
- 	position does not change. The line is at most n characters long
- 	or as many as will fit in the window.
-
- 	border(), box(), hline(), and vline() are implemented as macros.
-
-  X/Open Return Value:
- 	These functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for these functions.
-
-  Portability                             X/Open    BSD    SYS V  PDCurses
-                                          Dec '88
-      border                                -        -      4.0      Y
-      wborder                               -        -      4.0      Y
-      box                                   Y        Y       Y       Y
-      hline                                 -        -      4.0      Y
-      whline                                -        -      4.0      Y
-      vline                                 -        -      4.0      Y
-      wvline                                -        -      4.0      Y
-      PDC_wunderline                        -        -       -       Y
-      PDC_wleftline                         -        -       -       Y
-      PDC_wrightline                        -        -       -       Y
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	wborder(WINDOW *win, chtype ls, chtype rs, chtype ts, chtype bs,
-            chtype tl, chtype tr, chtype bl, chtype br)
-#else
-int	PDC_CDECL	wborder(win,ls,rs,ts,bs,tl,tr,bl,br)
-WINDOW *win;
-chtype ls;
-chtype rs;
-chtype ts;
-chtype bs;
-chtype tl;
-chtype tr;
-chtype bl;
-chtype br;
-#endif
-/***********************************************************************/
-{
-	int ymax,xmax;
-	int ymin,xmin;
-	int	i;
-	chtype	vattr;
-	chtype	hattr;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wborder() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-	ymax = win->_maxy - 1;
-	xmax = win->_maxx - 1;
-	ymin = 0;
-	xmin = 0;
-
-	if ((ts	& A_ATTRIBUTES)	== 0)
-	   hattr	= win->_attrs;
-	else
-	   if ((ts & A_COLOR) == 0)
-	      hattr = (ts & A_ATTRIBUTES) | win->_attrs;
-	   else
-	      hattr = (ts & A_ATTRIBUTES);
-
-	if ((ls	& A_ATTRIBUTES)	== 0)
-	   vattr	= win->_attrs;
-	else
-	   if ((ls & A_COLOR) == 0)
-	      vattr = (ls & A_ATTRIBUTES) | win->_attrs;
-	   else
-	      vattr = (ls & A_ATTRIBUTES);
-
-	ls = (ls == 0) ? ACS_VLINE | vattr : ls;
-	rs = (rs == 0) ? ACS_VLINE | vattr : rs;
-	ts = (ts == 0) ? ACS_HLINE | hattr : ts;
-	bs = (bs == 0) ? ACS_HLINE | hattr : bs;
-	tl = (tl == 0) ? ACS_ULCORNER | vattr : tl;
-	tr = (tr == 0) ? ACS_URCORNER | vattr : tr;
-	bl = (bl == 0) ? ACS_LLCORNER | vattr : bl;
-	br = (br == 0) ? ACS_LRCORNER | vattr : br;
-
-	ls = (ls & A_ATTRIBUTES) ? ls : ls | vattr;
-	rs = (rs & A_ATTRIBUTES) ? rs : rs | vattr;
-	ts = (ts & A_ATTRIBUTES) ? ts : ts | hattr;
-	bs = (bs & A_ATTRIBUTES) ? bs : bs | hattr;
-	tl = (tl & A_ATTRIBUTES) ? tl : tl | vattr;
-	tr = (tr & A_ATTRIBUTES) ? tr : tr | vattr;
-	bl = (bl & A_ATTRIBUTES) ? bl : bl | vattr;
-	br = (br & A_ATTRIBUTES) ? br : br | vattr;
-
-	for (i = xmin + 1; i <= xmax - 1; i++)
-	{
-		win->_y[ymin][i] = ts;
-		win->_y[ymax][i] = bs;
-	}
-
-	for (i = ymin + 1; i <= ymax - 1; i++)
-	{
-		win->_y[i][xmin] = ls;
-		win->_y[i][xmax] = rs;
-	}
-
-	win->_y[ymin][xmin] = tl;
-	win->_y[ymin][xmax] = tr;
-	win->_y[ymax][xmin] = bl;
-	win->_y[ymax][xmax] = br;
-
-	for (i = ymin; i <= ymax; i++)
-	{
-		if (win->_firstch[i] == _NO_CHANGE)
-		{
-			win->_firstch[i] = xmin;
-			win->_lastch[i] = xmax;
-		}
-		else
-		{
-			win->_firstch[i] = min(win->_firstch[i], xmin);
-			win->_lastch[i] = max(win->_lastch[i], xmax);
-		}
-	}
-	PDC_sync(win);
-	return (OK);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	border(chtype ls, chtype rs, chtype ts, chtype bs,
-           chtype tl, chtype tr, chtype bl, chtype br)
-#else
-int	PDC_CDECL	border(ls,rs,ts,bs,tl,tr,bl,br)
-chtype ls;
-chtype rs;
-chtype ts;
-chtype bs;
-chtype tl;
-chtype tr;
-chtype bl;
-chtype br;
-#endif
-/***********************************************************************/
-{
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("border() - called\n");
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	return(wborder(stdscr,ls,rs,ts,bs,tl,tr,bl,br));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	box(WINDOW *win, chtype verch, chtype horch)
-#else
-int	PDC_CDECL	box(win,verch,horch)
-WINDOW *win;
-chtype verch;
-chtype horch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("box() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	return(wborder(win,verch,verch,horch,horch,0,0,0,0));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	hline(chtype ch, int n)
-#else
-int	PDC_CDECL	hline(ch,n)
-chtype ch;
-int n;
-#endif
-/***********************************************************************/
-{
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("hline() - called\n");
-#endif
-
-	return(whline(stdscr,ch,n));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	whline(WINDOW *win, chtype inch, int n)
-#else
-int	PDC_CDECL	whline(win,inch,n)
-WINDOW *win;
-chtype inch;
-int n;
-#endif
-/***********************************************************************/
-{
-	chtype	attr;
-	chtype	ch=inch;
-	int	startpos;
-	int	endpos;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("whline() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if (n < 1)
-		return( ERR );
-
-	endpos = min(win->_curx + n -1, win->_maxx);
-
-	/*
-	** If the incoming character doesn't have it's own attribute
-	** then use the current attributes for the window.
-	*/
-
-	if ((ch & A_ATTRIBUTES) == 0)
-		attr = win->_attrs;
-	else
-	{
-		if ((ch & A_COLOR) == 0)
-			attr = (ch & A_ATTRIBUTES) | win->_attrs;
-		else
-			attr = (ch & A_ATTRIBUTES);
-	}
-
-	ch &= A_CHARTEXT;
-
-	/*
-	** If the incoming character is zero then use the default horizontal
-	** line character.
-	*/
-
-	if (ch == 0)
-{
-		ch = ACS_HLINE;
-}
-
-	ch |= attr;
-	startpos = win->_curx;
-
-	for (n = win->_curx; n <= endpos; n++)
-		win->_y[win->_cury][n] = ch;
-
-	n = win->_cury;
-
-	if (win->_firstch[n] == _NO_CHANGE)
-	{
-		win->_firstch[n] = startpos;
-		win->_lastch[n] = endpos;
-	}
-	else
-	{
-		win->_firstch[n] = min(win->_firstch[n], startpos);
-		win->_lastch[n] = max(win->_lastch[n], endpos);
-	}
-
-	PDC_sync(win);
-	return (OK);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	vline(chtype ch, int n)
-#else
-int	PDC_CDECL	vline(ch,n)
-chtype ch;
-int n;
-#endif
-/***********************************************************************/
-{
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("vline() - called\n");
-#endif
-
-	return(wvline(stdscr,ch,n));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	wvline(WINDOW *win, chtype ch, int n)
-#else
-int	PDC_CDECL	wvline(win,ch,n)
-WINDOW *win;
-chtype ch;
-int n;
-#endif
-/***********************************************************************/
-{
-	chtype	attr;
-	int	endpos;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wvline() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if (n < 1)
-		return( ERR );
-
-	endpos = min(win->_cury + n -1, win->_maxy);
-
-	/*
-	** If the incoming character doesn't have it's own attribute
-	** then use the current attributes for the window.
-	*/
-
-	if ((ch & A_ATTRIBUTES) == 0)
-		attr = win->_attrs;
-	else
-		if ((ch & A_COLOR) == 0)
-			attr = (ch & A_ATTRIBUTES) | win->_attrs;
-		else
-			attr = (ch & A_ATTRIBUTES);
-
-	ch &= A_CHARTEXT;
-
-	/*
-	** If the incoming character is zero then use the default vertical
-	** line character.
-	*/
-
-	if (ch == 0)
-		ch = ACS_VLINE;
-
-	ch |= attr;
-
-	for (n = win->_cury; n <= endpos; n++)
-	{
-		win->_y[n][win->_curx] = ch;
-
-		if (win->_firstch[n] == _NO_CHANGE)
-		{
-			win->_firstch[n] = win->_curx;
-			win->_lastch[n] = win->_curx;
-		}
-		else
-		{
-			win->_firstch[n] = min(win->_firstch[n], win->_curx);
-			win->_lastch[n] = max(win->_lastch[n], win->_curx);
-		}
-	}
-
-	PDC_sync(win);
-	return (OK);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	PDC_wunderline(WINDOW *win, int n, bool state)
-#else
-int	PDC_CDECL	PDC_wunderline(win,n,state)
-WINDOW *win;
-int n;
-bool state;
-#endif
-/***********************************************************************/
-{
-	int	endpos;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_wunderline() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if (n < 1)
-		return( ERR );
-
-	endpos = min(win->_cury + n -1, win->_maxy);
-
-	for (n = win->_cury; n <= endpos; n++)
-	{
-		if ( state ) 
-			win->_y[n][win->_curx] |= A_UNDERLINE; /* Turn ON A_UNDERLINE */
-		else
-			win->_y[n][win->_curx] |= ~A_UNDERLINE; /* Turn OFF A_UNDERLINE */
-
-		if (win->_firstch[n] == _NO_CHANGE)
-		{
-			win->_firstch[n] = win->_curx;
-			win->_lastch[n] = win->_curx;
-		}
-		else
-		{
-			win->_firstch[n] = min(win->_firstch[n], win->_curx);
-			win->_lastch[n] = max(win->_lastch[n], win->_curx);
-		}
-	}
-
-	PDC_sync(win);
-	return (OK);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	PDC_wleftline(WINDOW *win, int n, bool state)
-#else
-int	PDC_CDECL	PDC_wleftline(win,n,state)
-WINDOW *win;
-int n;
-bool state;
-#endif
-/***********************************************************************/
-{
-	int	endpos;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_wleftline() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if (n < 1)
-		return( ERR );
-
-	endpos = min(win->_cury + n -1, win->_maxy);
-
-	for (n = win->_cury; n <= endpos; n++)
-	{
-		if ( state ) 
-			win->_y[n][win->_curx] |= A_LEFTLINE; /* Turn ON A_LEFTLINE */
-		else
-			win->_y[n][win->_curx] |= ~A_LEFTLINE; /* Turn OFF A_LEFTLINE */
-
-		if (win->_firstch[n] == _NO_CHANGE)
-		{
-			win->_firstch[n] = win->_curx;
-			win->_lastch[n] = win->_curx;
-		}
-		else
-		{
-			win->_firstch[n] = min(win->_firstch[n], win->_curx);
-			win->_lastch[n] = max(win->_lastch[n], win->_curx);
-		}
-	}
-
-	PDC_sync(win);
-	return (OK);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	PDC_wrightline(WINDOW *win, int n, bool state)
-#else
-int	PDC_CDECL	PDC_wrightline(win,n,state)
-WINDOW *win;
-int n;
-bool state;
-#endif
-/***********************************************************************/
-{
-	int	endpos;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_wrightline() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if (n < 1)
-		return( ERR );
-
-	endpos = min(win->_cury + n -1, win->_maxy);
-
-	for (n = win->_cury; n <= endpos; n++)
-	{
-		if ( state ) 
-			win->_y[n][win->_curx] |= A_RIGHTLINE; /* Turn ON A_RIGHTLINE */
-		else
-			win->_y[n][win->_curx] |= ~A_RIGHTLINE; /* Turn OFF A_RIGHTLINE */
-
-		if (win->_firstch[n] == _NO_CHANGE)
-		{
-			win->_firstch[n] = win->_curx;
-			win->_lastch[n] = win->_curx;
-		}
-		else
-		{
-			win->_firstch[n] = min(win->_firstch[n], win->_curx);
-			win->_lastch[n] = max(win->_lastch[n], win->_curx);
-		}
-	}
-
-	PDC_sync(win);
-	return (OK);
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	border
+#undef	wborder
+#undef	box
+#undef	hline
+#undef	whline
+#undef	vline
+#undef	wvline
+#undef	PDC_wunderline
+#undef	PDC_leftline
+#undef	PDC_rightline
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_border  = "$Id: border.c,v 1.3 2001/03/02 13:40:26 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        border
+
+  Synopsis:
+  	int border(chtype ls, chtype rs, chtype ts, chtype bs, chtype tl, 
+  	           chtype tr, chtype bl, chtype br);
+  	int wborder(WINDOW *win, chtype ls, chtype rs, chtype ts, 
+  	            chtype bs, chtype tl, chtype tr, chtype bl, chtype br);
+  	int box(WINDOW *win, chtype verch, chtype horch);
+  	int hline(chtype ch, int n);
+  	int vline(chtype ch, int n);
+  	int whline(WINDOW *win, chtype ch, int n);
+  	int wvline(WINDOW *win, chtype ch, int n);
+  	int PDC_wunderline(WINDOW *win, int n, bool state);
+  	int PDC_wleftline(WINDOW *win, int n, bool state);
+  	int PDC_wrightline(WINDOW *win, int n, bool state);
+
+  X/Open Description:
+ 	The border(), wborder(), and box() routines, a border is drawn
+ 	around the edge of the window. If any of the arguments is zero,
+ 	an appropriate default is used. These default values are specified
+ 	in <curses.h>. The arguments and defaults to these functions are:
+ 		ls	left side of border		ACS_VLINE
+ 		rs	right side of border		ACS_VLINE
+ 		ts	top side of border		ACS_HLINE
+ 		bs	bottom side of border		ACS_HLINE
+ 		tl	top left corner of border	ACS_ULCORNER
+ 		tr	top right corner of border	ACS_URCORNER
+ 		bl	bottom left corner of border	ACS_BLCORNER
+ 		br	bottom right corner of border	ACS_BLCORNER
+
+ 	The hline() and whline() functions draw a left to right line
+ 	using ch starting from the current cursor position. The cursor
+ 	position does not change. The line is at most n characters long
+ 	or as many as will fit in the window.
+
+ 	The vline() and wvline() functions draw a top to bottom line
+ 	using ch starting from the current cursor position. The cursor
+ 	position does not change. The line is at most n characters long
+ 	or as many as will fit in the window.
+
+ 	border(), box(), hline(), and vline() are implemented as macros.
+
+  X/Open Return Value:
+ 	These functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for these functions.
+
+  Portability                             X/Open    BSD    SYS V  PDCurses
+                                          Dec '88
+      border                                -        -      4.0      Y
+      wborder                               -        -      4.0      Y
+      box                                   Y        Y       Y       Y
+      hline                                 -        -      4.0      Y
+      whline                                -        -      4.0      Y
+      vline                                 -        -      4.0      Y
+      wvline                                -        -      4.0      Y
+      PDC_wunderline                        -        -       -       Y
+      PDC_wleftline                         -        -       -       Y
+      PDC_wrightline                        -        -       -       Y
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wborder(WINDOW *win, chtype ls, chtype rs, chtype ts, chtype bs,
+            chtype tl, chtype tr, chtype bl, chtype br)
+#else
+int	PDC_CDECL	wborder(win,ls,rs,ts,bs,tl,tr,bl,br)
+WINDOW *win;
+chtype ls;
+chtype rs;
+chtype ts;
+chtype bs;
+chtype tl;
+chtype tr;
+chtype bl;
+chtype br;
+#endif
+/***********************************************************************/
+{
+	int ymax,xmax;
+	int ymin,xmin;
+	int	i;
+	chtype	vattr;
+	chtype	hattr;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wborder() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+	ymax = win->_maxy - 1;
+	xmax = win->_maxx - 1;
+	ymin = 0;
+	xmin = 0;
+
+	if ((ts	& A_ATTRIBUTES)	== 0)
+	   hattr	= win->_attrs;
+	else
+	   if ((ts & A_COLOR) == 0)
+	      hattr = (ts & A_ATTRIBUTES) | win->_attrs;
+	   else
+	      hattr = (ts & A_ATTRIBUTES);
+
+	if ((ls	& A_ATTRIBUTES)	== 0)
+	   vattr	= win->_attrs;
+	else
+	   if ((ls & A_COLOR) == 0)
+	      vattr = (ls & A_ATTRIBUTES) | win->_attrs;
+	   else
+	      vattr = (ls & A_ATTRIBUTES);
+
+	ls = (ls == 0) ? ACS_VLINE | vattr : ls;
+	rs = (rs == 0) ? ACS_VLINE | vattr : rs;
+	ts = (ts == 0) ? ACS_HLINE | hattr : ts;
+	bs = (bs == 0) ? ACS_HLINE | hattr : bs;
+	tl = (tl == 0) ? ACS_ULCORNER | vattr : tl;
+	tr = (tr == 0) ? ACS_URCORNER | vattr : tr;
+	bl = (bl == 0) ? ACS_LLCORNER | vattr : bl;
+	br = (br == 0) ? ACS_LRCORNER | vattr : br;
+
+	ls = (ls & A_ATTRIBUTES) ? ls : ls | vattr;
+	rs = (rs & A_ATTRIBUTES) ? rs : rs | vattr;
+	ts = (ts & A_ATTRIBUTES) ? ts : ts | hattr;
+	bs = (bs & A_ATTRIBUTES) ? bs : bs | hattr;
+	tl = (tl & A_ATTRIBUTES) ? tl : tl | vattr;
+	tr = (tr & A_ATTRIBUTES) ? tr : tr | vattr;
+	bl = (bl & A_ATTRIBUTES) ? bl : bl | vattr;
+	br = (br & A_ATTRIBUTES) ? br : br | vattr;
+
+	for (i = xmin + 1; i <= xmax - 1; i++)
+	{
+		win->_y[ymin][i] = ts;
+		win->_y[ymax][i] = bs;
+	}
+
+	for (i = ymin + 1; i <= ymax - 1; i++)
+	{
+		win->_y[i][xmin] = ls;
+		win->_y[i][xmax] = rs;
+	}
+
+	win->_y[ymin][xmin] = tl;
+	win->_y[ymin][xmax] = tr;
+	win->_y[ymax][xmin] = bl;
+	win->_y[ymax][xmax] = br;
+
+	for (i = ymin; i <= ymax; i++)
+	{
+		if (win->_firstch[i] == _NO_CHANGE)
+		{
+			win->_firstch[i] = xmin;
+			win->_lastch[i] = xmax;
+		}
+		else
+		{
+			win->_firstch[i] = min(win->_firstch[i], xmin);
+			win->_lastch[i] = max(win->_lastch[i], xmax);
+		}
+	}
+	PDC_sync(win);
+	return (OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	border(chtype ls, chtype rs, chtype ts, chtype bs,
+           chtype tl, chtype tr, chtype bl, chtype br)
+#else
+int	PDC_CDECL	border(ls,rs,ts,bs,tl,tr,bl,br)
+chtype ls;
+chtype rs;
+chtype ts;
+chtype bs;
+chtype tl;
+chtype tr;
+chtype bl;
+chtype br;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("border() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	return(wborder(stdscr,ls,rs,ts,bs,tl,tr,bl,br));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	box(WINDOW *win, chtype verch, chtype horch)
+#else
+int	PDC_CDECL	box(win,verch,horch)
+WINDOW *win;
+chtype verch;
+chtype horch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("box() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(wborder(win,verch,verch,horch,horch,0,0,0,0));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	hline(chtype ch, int n)
+#else
+int	PDC_CDECL	hline(ch,n)
+chtype ch;
+int n;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("hline() - called\n");
+#endif
+
+	return(whline(stdscr,ch,n));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	whline(WINDOW *win, chtype inch, int n)
+#else
+int	PDC_CDECL	whline(win,inch,n)
+WINDOW *win;
+chtype inch;
+int n;
+#endif
+/***********************************************************************/
+{
+	chtype	attr;
+	chtype	ch=inch;
+	int	startpos;
+	int	endpos;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("whline() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (n < 1)
+		return( ERR );
+
+	endpos = min(win->_curx + n -1, win->_maxx);
+
+	/*
+	** If the incoming character doesn't have it's own attribute
+	** then use the current attributes for the window.
+	*/
+
+	if ((ch & A_ATTRIBUTES) == 0)
+		attr = win->_attrs;
+	else
+	{
+		if ((ch & A_COLOR) == 0)
+			attr = (ch & A_ATTRIBUTES) | win->_attrs;
+		else
+			attr = (ch & A_ATTRIBUTES);
+	}
+
+	ch &= A_CHARTEXT;
+
+	/*
+	** If the incoming character is zero then use the default horizontal
+	** line character.
+	*/
+
+	if (ch == 0)
+{
+		ch = ACS_HLINE;
+}
+
+	ch |= attr;
+	startpos = win->_curx;
+
+	for (n = win->_curx; n <= endpos; n++)
+		win->_y[win->_cury][n] = ch;
+
+	n = win->_cury;
+
+	if (win->_firstch[n] == _NO_CHANGE)
+	{
+		win->_firstch[n] = startpos;
+		win->_lastch[n] = endpos;
+	}
+	else
+	{
+		win->_firstch[n] = min(win->_firstch[n], startpos);
+		win->_lastch[n] = max(win->_lastch[n], endpos);
+	}
+
+	PDC_sync(win);
+	return (OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	vline(chtype ch, int n)
+#else
+int	PDC_CDECL	vline(ch,n)
+chtype ch;
+int n;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("vline() - called\n");
+#endif
+
+	return(wvline(stdscr,ch,n));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wvline(WINDOW *win, chtype ch, int n)
+#else
+int	PDC_CDECL	wvline(win,ch,n)
+WINDOW *win;
+chtype ch;
+int n;
+#endif
+/***********************************************************************/
+{
+	chtype	attr;
+	int	endpos;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wvline() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (n < 1)
+		return( ERR );
+
+	endpos = min(win->_cury + n -1, win->_maxy);
+
+	/*
+	** If the incoming character doesn't have it's own attribute
+	** then use the current attributes for the window.
+	*/
+
+	if ((ch & A_ATTRIBUTES) == 0)
+		attr = win->_attrs;
+	else
+		if ((ch & A_COLOR) == 0)
+			attr = (ch & A_ATTRIBUTES) | win->_attrs;
+		else
+			attr = (ch & A_ATTRIBUTES);
+
+	ch &= A_CHARTEXT;
+
+	/*
+	** If the incoming character is zero then use the default vertical
+	** line character.
+	*/
+
+	if (ch == 0)
+		ch = ACS_VLINE;
+
+	ch |= attr;
+
+	for (n = win->_cury; n <= endpos; n++)
+	{
+		win->_y[n][win->_curx] = ch;
+
+		if (win->_firstch[n] == _NO_CHANGE)
+		{
+			win->_firstch[n] = win->_curx;
+			win->_lastch[n] = win->_curx;
+		}
+		else
+		{
+			win->_firstch[n] = min(win->_firstch[n], win->_curx);
+			win->_lastch[n] = max(win->_lastch[n], win->_curx);
+		}
+	}
+
+	PDC_sync(win);
+	return (OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	PDC_wunderline(WINDOW *win, int n, bool state)
+#else
+int	PDC_CDECL	PDC_wunderline(win,n,state)
+WINDOW *win;
+int n;
+bool state;
+#endif
+/***********************************************************************/
+{
+	int	endpos;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_wunderline() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (n < 1)
+		return( ERR );
+
+	endpos = min(win->_cury + n -1, win->_maxy);
+
+	for (n = win->_cury; n <= endpos; n++)
+	{
+		if ( state ) 
+			win->_y[n][win->_curx] |= A_UNDERLINE; /* Turn ON A_UNDERLINE */
+		else
+			win->_y[n][win->_curx] |= ~A_UNDERLINE; /* Turn OFF A_UNDERLINE */
+
+		if (win->_firstch[n] == _NO_CHANGE)
+		{
+			win->_firstch[n] = win->_curx;
+			win->_lastch[n] = win->_curx;
+		}
+		else
+		{
+			win->_firstch[n] = min(win->_firstch[n], win->_curx);
+			win->_lastch[n] = max(win->_lastch[n], win->_curx);
+		}
+	}
+
+	PDC_sync(win);
+	return (OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	PDC_wleftline(WINDOW *win, int n, bool state)
+#else
+int	PDC_CDECL	PDC_wleftline(win,n,state)
+WINDOW *win;
+int n;
+bool state;
+#endif
+/***********************************************************************/
+{
+	int	endpos;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_wleftline() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (n < 1)
+		return( ERR );
+
+	endpos = min(win->_cury + n -1, win->_maxy);
+
+	for (n = win->_cury; n <= endpos; n++)
+	{
+		if ( state ) 
+			win->_y[n][win->_curx] |= A_LEFTLINE; /* Turn ON A_LEFTLINE */
+		else
+			win->_y[n][win->_curx] |= ~A_LEFTLINE; /* Turn OFF A_LEFTLINE */
+
+		if (win->_firstch[n] == _NO_CHANGE)
+		{
+			win->_firstch[n] = win->_curx;
+			win->_lastch[n] = win->_curx;
+		}
+		else
+		{
+			win->_firstch[n] = min(win->_firstch[n], win->_curx);
+			win->_lastch[n] = max(win->_lastch[n], win->_curx);
+		}
+	}
+
+	PDC_sync(win);
+	return (OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	PDC_wrightline(WINDOW *win, int n, bool state)
+#else
+int	PDC_CDECL	PDC_wrightline(win,n,state)
+WINDOW *win;
+int n;
+bool state;
+#endif
+/***********************************************************************/
+{
+	int	endpos;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_wrightline() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (n < 1)
+		return( ERR );
+
+	endpos = min(win->_cury + n -1, win->_maxy);
+
+	for (n = win->_cury; n <= endpos; n++)
+	{
+		if ( state ) 
+			win->_y[n][win->_curx] |= A_RIGHTLINE; /* Turn ON A_RIGHTLINE */
+		else
+			win->_y[n][win->_curx] |= ~A_RIGHTLINE; /* Turn OFF A_RIGHTLINE */
+
+		if (win->_firstch[n] == _NO_CHANGE)
+		{
+			win->_firstch[n] = win->_curx;
+			win->_lastch[n] = win->_curx;
+		}
+		else
+		{
+			win->_firstch[n] = min(win->_firstch[n], win->_curx);
+			win->_lastch[n] = max(win->_lastch[n], win->_curx);
+		}
+	}
+
+	PDC_sync(win);
+	return (OK);
+}
Index: PDCurses/pdcurses/color.c
===================================================================
--- PDCurses/pdcurses/color.c	(revision 1)
+++ PDCurses/pdcurses/color.c	(working copy)
@@ -1,439 +1,439 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-#ifdef HAVE_STRING_H
-# include <string.h>
-#endif
-
-#ifdef UNIX
-#include <defs.h>
-#include <term.h>
-#endif
-
-/* undefine any macros for functions defined in this module */
-#undef	start_color
-#undef	init_pair
-#undef	init_color
-#undef	has_colors
-#undef	can_change_color
-#undef	color_content
-#undef	pair_content
-#undef	PDC_set_line_color
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#endif
-
-#ifdef HAVE_PROTO
-static int PDC_init_pair(short,short,short);
-#else
-static int PDC_init_pair();
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_color  = "$Id: color.c,v 1.3 2002/03/22 22:36:50 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                         color
-
-  Synopsis:
-  	int start_color(void);
-  	int init_pair(short pair, short fg, short bg);
-  ***	int init_color(short color, short red, short green, short blue);
-  	bool has_colors(void);
-  	bool can_change_color(void);
-  ***	int color_content(short color, short *redp, short *greenp, short *bluep);
-  	int pair_content(short pair, short *fgp, short *bgp);
-  	int PDC_set_line_color(short color);
-
-  X/Open Description:
- 	To use these routines, start_color() must be called, usually
- 	immediately after initscr(). Colors are always used in pairs refered
- 	to as color-pairs. A color-pair consists of a foreground color and
- 	a background color. A color-pair is initialized with init_pair().
- 	After it has been initialized, COLOR_PAIR(n), a macro defined in
- 	<curses.h>, can be used like any other video attribute.
-
- 	start_color() initializes eight basic colors (black,red,green,yellow,
- 	blue,magenta,cyan, and white), and two global variables; COLORS
- 	and COLOR_PAIRS (respectively defining the maximum number of
- 	colors and color-pairs the terminal is capable of displaying).
-
- 	init_pair() changes the definitions of a color-pair.
- 	The routine takes three arguments: the number of the color-pair
- 	to be redefined, and the new values of the foreground and
- 	background colors.
- 	The value of color-pair must be between 1 and COLOR_PAIRS-1.
- 	The values of foreground and background must be between 0 and
- 	COLORS-1 (this is a PDCurses abberation; normally it is 0 and
- 	COLORS)
- 	If the color pair was previously initialized, the screen is refreshed
- 	and all occurrences of that color-pair are changed to the new
- 	definition.
-
- 	has_colors() indicates if the terminal supports, and can maniplulate
- 	color. It returns TRUE or FALSE.
-
- 	can_change_color() indicates if the terminal has the capability 
- 	to change the definition of its colors. Although this is possible,
- 	at least with VGA monitors, this function always returns FALSE.
-
- 	pair_content() is used to determine what the colors of a given 
- 	color-pair consist of.
-
- 	PDC_set_line_color() is used to set the color, globally, for the
- 	color of the lines drawn for the attributes: A_UNDERLINE, A_OVERLINE, 
- 	A_LEFTLINE and A_RIGHTLINE.  PDCurses only feature.
-
- 	NOTE: has_colors() is implemented as a macro.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error except for
- 	has_colors() and can_change_colors() which return TRUE or FALSE.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V   PDCurses
-                                          Dec '88
-      start_color                           -        -      3.2
-      init_pair                             -        -      3.2
-      init_color                            -        -      3.2
-      has_colors                            -        -      3.2
-      can_change_color                      -        -      3.2
-      color_content                         -        -      3.2
-      pair_content                          -        -      3.2
-      PDC_set_line_color                    -        -       -       Y
-
-**man-end**********************************************************************/
-
-int	COLORS = PDC_COLORS;
-int	COLOR_PAIRS = PDC_COLOR_PAIRS;
-
-#if defined(CHTYPE_LONG)
-#   if defined(XCURSES)
-unsigned char *atrtab=NULL;
-#   else
-unsigned char atrtab[MAX_ATRTAB]; /* COLOR_PAIR to attribute encoding table. */
-#   endif
-#else
-unsigned char  atrtab[MAX_ATRTAB] = /* COLOR_PAIR to attribute encoding table. */
- {0x07,0x0F,0x70,0x78,0x87,0x8F,0xF0,0xF8, /* A_NORMAL */
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
-  0x70,0x00,0x17,0x00,0x00,0x00,0x00,0x00  /* for flash() */
-  };
-#endif
-
-unsigned char colourset[PDC_COLOR_PAIRS];
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	start_color(void)
-#else
-int	PDC_CDECL	start_color()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("start_color() - called\n");
-#endif
- if (SP->mono)
-    return(ERR);
- COLORS = 8;
-#if defined(CHTYPE_LONG)
- COLOR_PAIRS = PDC_COLOR_PAIRS;
-/* PDC_init_atrtab(); - already done in initscr() */
-#else
- COLOR_PAIRS = 33;  /* actually only allows 32 */
-#endif
- memset(colourset,0,PDC_COLOR_PAIRS);
- return(OK);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	init_pair(short colorpair,short foreground,short background)
-#else
-int	PDC_CDECL	init_pair(colorpair,foreground,background)
-short colorpair;
-short foreground;
-short background;
-#endif
-/***********************************************************************/
-{
- short oldforeground, oldbackground;
- unsigned char norm;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("init_pair() - called: colorpair %d fore %d back %d\n",colorpair,foreground,background);
-#endif
-
- if (colorpair >= COLOR_PAIRS || colorpair < 1)
-    return(ERR);
-
- norm = (unsigned char)(foreground & 0x0007) + ((background & 0x0007)<<4);
- oldforeground = (short)(atrtab[colorpair*PDC_OFFSET] & 0x0F);
- oldbackground = (short)((atrtab[colorpair*PDC_OFFSET] & 0xF0)>>4);
-
-#if defined(CHTYPE_LONG)
-#  if defined(XCURSES)
- atrtab[colorpair*PDC_OFFSET] = norm;
-#  else
- PDC_init_pair(colorpair,foreground,background);
-#  endif
-#else
- atrtab[(colorpair*PDC_OFFSET)+0] = norm;                         /* normal */
- atrtab[(colorpair*PDC_OFFSET)+1] = norm + 8;                       /* bold */
- atrtab[(colorpair*PDC_OFFSET)+4] = norm + 128;                    /* blink */
- atrtab[(colorpair*PDC_OFFSET)+5] = norm + 8 + 128;           /* bold-blink */
-#endif
-
-/*
- * To allow the PDC_PRESERVE_SCREEN option to work, we only reset
- * curscr if this call to init_pair() alters a color pair created
- * by the user.
- */
- if (colourset[colorpair])
-   {
-    if ( oldforeground != foreground || oldbackground != background )
-        curscr->_clear = TRUE;
-   }
- colourset[colorpair] = TRUE;
- return(OK);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-bool	PDC_CDECL	has_colors(void)
-#else
-bool	PDC_CDECL	has_colors()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("has_colors() - called\n");
-#endif
-	if (SP->mono)
-		return(FALSE);
-	return(TRUE);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	init_color(short color,short red,short green,short blue)
-#else
-int	PDC_CDECL	init_color(color,red,green,blue)
-short color;
-short red;
-short green;
-short blue;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("init_color() - called\n");
-#endif
-/*************** this does nothing at the moment ******************/
-	return(OK);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	color_content(short color,short *red,short *green,short *blue)
-#else
-int	PDC_CDECL	color_content(color,red,green,blue)
-short color;
-short *red;
-short *green;
-short *blue;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("color_content() - called\n");
-#endif
-/*************** this does nothing at the moment ******************/
-	return(OK);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	can_change_color(void)
-#else
-int	PDC_CDECL	can_change_color()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("can_change_color() - called\n");
-#endif
-
-#ifdef UNIX
-	if (can_change)
-		return(TRUE);
-	else
-		return(FALSE);
-#else
-	return(FALSE);
-#endif
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	pair_content(int colorpair,short *foreground,short *background)
-#else
-int	PDC_CDECL	pair_content(colorpair,foreground,background)
-int colorpair;
-short *foreground;
-short *background;
-#endif
-/***********************************************************************/
-{
-
- if (colorpair >= COLOR_PAIRS || colorpair < 1)
-    return(ERR);
-
- *foreground = (short)(atrtab[colorpair*PDC_OFFSET] & 0x0F);
- *background = (short)((atrtab[colorpair*PDC_OFFSET] & 0xF0)>>4);
-
- /*
-  * End of patch by:
-  * William McBrine <wmcbrine@clark.net> 30-Dec-1998
-  */
-#if 0
- if ( *foreground <= 0 && *background <= 0 )
- 	return(ERR);
-#endif
- /*
-  * End of patch by:
-  * William McBrine <wmcbrine@clark.net> 30-Dec-1998
-  */
-
- return(OK);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	PDC_set_line_color(short color)
-#else
-int	PDC_CDECL	PDC_set_line_color(color)
-short color;
-#endif
-/***********************************************************************/
-{
-
- if (color >= COLORS || color < 0)
-    return(ERR);
- SP->line_color = color;
- return(OK);
-}
-
-#if defined(CHTYPE_LONG)
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_init_atrtab(void)
-#else
-int	PDC_init_atrtab()
-#endif
-/***********************************************************************/
-{
- register int i=0;
-
- for (i=0;i<PDC_COLOR_PAIRS;i++)
-    PDC_init_pair(i,COLOR_WHITE,COLOR_BLACK);
- PDC_init_pair(PDC_COLOR_PAIRS,COLOR_BLACK,COLOR_WHITE);
- return(0);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-static	int PDC_init_pair(short pairnum,short fg,short bg)
-#else
-static	int PDC_init_pair(pairnum,fg,bg)
-short pairnum;
-short fg;
-short bg;
-#endif
-/***********************************************************************/
-{
- register int i=0;
- unsigned char temp_bg=0;
- int ttt,uuu;
-
- for (i=0;i<PDC_OFFSET;i++)
-   {
-    atrtab[(pairnum*PDC_OFFSET)+i] = fg | (bg << 4);
-    ttt = A_REVERSE >> 19;
-    uuu = i&ttt;
-    if (uuu == ttt)
-       atrtab[(pairnum*PDC_OFFSET)+i] = 0x70;
-    ttt = A_UNDERLINE >> 19;
-    uuu = i&ttt;
-    if (uuu == ttt)
-       atrtab[(pairnum*PDC_OFFSET)+i] = 1;
-    ttt = A_INVIS >> 19;
-    uuu = i&ttt;
-    if (uuu == ttt)
-      {
-       temp_bg = (atrtab[(pairnum*PDC_OFFSET)+i])>>4;
-       atrtab[(pairnum*PDC_OFFSET)+i] = temp_bg<<4|temp_bg;
-      }
-    ttt = A_BOLD >> 19;
-    uuu = i&ttt;
-    if (uuu == ttt)
-       atrtab[(pairnum*PDC_OFFSET)+i] |= 8;
-    ttt = A_BLINK >> 19;
-    uuu = i&ttt;
-    if (uuu == ttt)
-       atrtab[(pairnum*PDC_OFFSET)+i] |= 128;
-   }
- return(0);
-}
-#endif
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif
+
+#ifdef UNIX
+#include <defs.h>
+#include <term.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef	start_color
+#undef	init_pair
+#undef	init_color
+#undef	has_colors
+#undef	can_change_color
+#undef	color_content
+#undef	pair_content
+#undef	PDC_set_line_color
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef HAVE_PROTO
+static int PDC_init_pair(short,short,short);
+#else
+static int PDC_init_pair();
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_color  = "$Id: color.c,v 1.3 2002/03/22 22:36:50 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         color
+
+  Synopsis:
+  	int start_color(void);
+  	int init_pair(short pair, short fg, short bg);
+  ***	int init_color(short color, short red, short green, short blue);
+  	bool has_colors(void);
+  	bool can_change_color(void);
+  ***	int color_content(short color, short *redp, short *greenp, short *bluep);
+  	int pair_content(short pair, short *fgp, short *bgp);
+  	int PDC_set_line_color(short color);
+
+  X/Open Description:
+ 	To use these routines, start_color() must be called, usually
+ 	immediately after initscr(). Colors are always used in pairs refered
+ 	to as color-pairs. A color-pair consists of a foreground color and
+ 	a background color. A color-pair is initialized with init_pair().
+ 	After it has been initialized, COLOR_PAIR(n), a macro defined in
+ 	<curses.h>, can be used like any other video attribute.
+
+ 	start_color() initializes eight basic colors (black,red,green,yellow,
+ 	blue,magenta,cyan, and white), and two global variables; COLORS
+ 	and COLOR_PAIRS (respectively defining the maximum number of
+ 	colors and color-pairs the terminal is capable of displaying).
+
+ 	init_pair() changes the definitions of a color-pair.
+ 	The routine takes three arguments: the number of the color-pair
+ 	to be redefined, and the new values of the foreground and
+ 	background colors.
+ 	The value of color-pair must be between 1 and COLOR_PAIRS-1.
+ 	The values of foreground and background must be between 0 and
+ 	COLORS-1 (this is a PDCurses abberation; normally it is 0 and
+ 	COLORS)
+ 	If the color pair was previously initialized, the screen is refreshed
+ 	and all occurrences of that color-pair are changed to the new
+ 	definition.
+
+ 	has_colors() indicates if the terminal supports, and can maniplulate
+ 	color. It returns TRUE or FALSE.
+
+ 	can_change_color() indicates if the terminal has the capability 
+ 	to change the definition of its colors. Although this is possible,
+ 	at least with VGA monitors, this function always returns FALSE.
+
+ 	pair_content() is used to determine what the colors of a given 
+ 	color-pair consist of.
+
+ 	PDC_set_line_color() is used to set the color, globally, for the
+ 	color of the lines drawn for the attributes: A_UNDERLINE, A_OVERLINE, 
+ 	A_LEFTLINE and A_RIGHTLINE.  PDCurses only feature.
+
+ 	NOTE: has_colors() is implemented as a macro.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error except for
+ 	has_colors() and can_change_colors() which return TRUE or FALSE.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V   PDCurses
+                                          Dec '88
+      start_color                           -        -      3.2
+      init_pair                             -        -      3.2
+      init_color                            -        -      3.2
+      has_colors                            -        -      3.2
+      can_change_color                      -        -      3.2
+      color_content                         -        -      3.2
+      pair_content                          -        -      3.2
+      PDC_set_line_color                    -        -       -       Y
+
+**man-end**********************************************************************/
+
+int	COLORS = PDC_COLORS;
+int	COLOR_PAIRS = PDC_COLOR_PAIRS;
+
+#if defined(CHTYPE_LONG)
+#   if defined(XCURSES)
+unsigned char *atrtab=NULL;
+#   else
+unsigned char atrtab[MAX_ATRTAB]; /* COLOR_PAIR to attribute encoding table. */
+#   endif
+#else
+unsigned char  atrtab[MAX_ATRTAB] = /* COLOR_PAIR to attribute encoding table. */
+ {0x07,0x0F,0x70,0x78,0x87,0x8F,0xF0,0xF8, /* A_NORMAL */
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x70,0x00,0x17,0x00,0x00,0x00,0x00,0x00  /* for flash() */
+  };
+#endif
+
+unsigned char colourset[PDC_COLOR_PAIRS];
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	start_color(void)
+#else
+int	PDC_CDECL	start_color()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("start_color() - called\n");
+#endif
+ if (PDC_SP->mono)
+    return(ERR);
+ COLORS = 8;
+#if defined(CHTYPE_LONG)
+ COLOR_PAIRS = PDC_COLOR_PAIRS;
+/* PDC_init_atrtab(); - already done in initscr() */
+#else
+ COLOR_PAIRS = 33;  /* actually only allows 32 */
+#endif
+ memset(colourset,0,PDC_COLOR_PAIRS);
+ return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	init_pair(short colorpair,short foreground,short background)
+#else
+int	PDC_CDECL	init_pair(colorpair,foreground,background)
+short colorpair;
+short foreground;
+short background;
+#endif
+/***********************************************************************/
+{
+ short oldforeground, oldbackground;
+ unsigned char norm;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("init_pair() - called: colorpair %d fore %d back %d\n",colorpair,foreground,background);
+#endif
+
+ if (colorpair >= COLOR_PAIRS || colorpair < 1)
+    return(ERR);
+
+ norm = (unsigned char)(foreground & 0x0007) + ((background & 0x0007)<<4);
+ oldforeground = (short)(atrtab[colorpair*PDC_OFFSET] & 0x0F);
+ oldbackground = (short)((atrtab[colorpair*PDC_OFFSET] & 0xF0)>>4);
+
+#if defined(CHTYPE_LONG)
+#  if defined(XCURSES)
+ atrtab[colorpair*PDC_OFFSET] = norm;
+#  else
+ PDC_init_pair(colorpair,foreground,background);
+#  endif
+#else
+ atrtab[(colorpair*PDC_OFFSET)+0] = norm;                         /* normal */
+ atrtab[(colorpair*PDC_OFFSET)+1] = norm + 8;                       /* bold */
+ atrtab[(colorpair*PDC_OFFSET)+4] = norm + 128;                    /* blink */
+ atrtab[(colorpair*PDC_OFFSET)+5] = norm + 8 + 128;           /* bold-blink */
+#endif
+
+/*
+ * To allow the PDC_PRESERVE_SCREEN option to work, we only reset
+ * curscr if this call to init_pair() alters a color pair created
+ * by the user.
+ */
+ if (colourset[colorpair])
+   {
+    if ( oldforeground != foreground || oldbackground != background )
+        curscr->_clear = TRUE;
+   }
+ colourset[colorpair] = TRUE;
+ return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool	PDC_CDECL	has_colors(void)
+#else
+bool	PDC_CDECL	has_colors()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("has_colors() - called\n");
+#endif
+	if (PDC_SP->mono)
+		return(FALSE);
+	return(TRUE);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	init_color(short color,short red,short green,short blue)
+#else
+int	PDC_CDECL	init_color(color,red,green,blue)
+short color;
+short red;
+short green;
+short blue;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("init_color() - called\n");
+#endif
+/*************** this does nothing at the moment ******************/
+	return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	color_content(short color,short *red,short *green,short *blue)
+#else
+int	PDC_CDECL	color_content(color,red,green,blue)
+short color;
+short *red;
+short *green;
+short *blue;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("color_content() - called\n");
+#endif
+/*************** this does nothing at the moment ******************/
+	return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	can_change_color(void)
+#else
+int	PDC_CDECL	can_change_color()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("can_change_color() - called\n");
+#endif
+
+#ifdef UNIX
+	if (can_change)
+		return(TRUE);
+	else
+		return(FALSE);
+#else
+	return(FALSE);
+#endif
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	pair_content(int colorpair,short *foreground,short *background)
+#else
+int	PDC_CDECL	pair_content(colorpair,foreground,background)
+int colorpair;
+short *foreground;
+short *background;
+#endif
+/***********************************************************************/
+{
+
+ if (colorpair >= COLOR_PAIRS || colorpair < 1)
+    return(ERR);
+
+ *foreground = (short)(atrtab[colorpair*PDC_OFFSET] & 0x0F);
+ *background = (short)((atrtab[colorpair*PDC_OFFSET] & 0xF0)>>4);
+
+ /*
+  * End of patch by:
+  * William McBrine <wmcbrine@clark.net> 30-Dec-1998
+  */
+#if 0
+ if ( *foreground <= 0 && *background <= 0 )
+ 	return(ERR);
+#endif
+ /*
+  * End of patch by:
+  * William McBrine <wmcbrine@clark.net> 30-Dec-1998
+  */
+
+ return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	PDC_set_line_color(short color)
+#else
+int	PDC_CDECL	PDC_set_line_color(color)
+short color;
+#endif
+/***********************************************************************/
+{
+
+ if (color >= COLORS || color < 0)
+    return(ERR);
+ PDC_SP->line_color = color;
+ return(OK);
+}
+
+#if defined(CHTYPE_LONG)
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_init_atrtab(void)
+#else
+int	PDC_init_atrtab()
+#endif
+/***********************************************************************/
+{
+ register int i=0;
+
+ for (i=0;i<PDC_COLOR_PAIRS;i++)
+    PDC_init_pair(i,COLOR_WHITE,COLOR_BLACK);
+ PDC_init_pair(PDC_COLOR_PAIRS,COLOR_BLACK,COLOR_WHITE);
+ return(0);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+static	int PDC_init_pair(short pairnum,short fg,short bg)
+#else
+static	int PDC_init_pair(pairnum,fg,bg)
+short pairnum;
+short fg;
+short bg;
+#endif
+/***********************************************************************/
+{
+ register int i=0;
+ unsigned char temp_bg=0;
+ int ttt,uuu;
+
+ for (i=0;i<PDC_OFFSET;i++)
+   {
+    atrtab[(pairnum*PDC_OFFSET)+i] = fg | (bg << 4);
+    ttt = A_REVERSE >> 19;
+    uuu = i&ttt;
+    if (uuu == ttt)
+       atrtab[(pairnum*PDC_OFFSET)+i] = 0x70;
+    ttt = A_UNDERLINE >> 19;
+    uuu = i&ttt;
+    if (uuu == ttt)
+       atrtab[(pairnum*PDC_OFFSET)+i] = 1;
+    ttt = A_INVIS >> 19;
+    uuu = i&ttt;
+    if (uuu == ttt)
+      {
+       temp_bg = (atrtab[(pairnum*PDC_OFFSET)+i])>>4;
+       atrtab[(pairnum*PDC_OFFSET)+i] = temp_bg<<4|temp_bg;
+      }
+    ttt = A_BOLD >> 19;
+    uuu = i&ttt;
+    if (uuu == ttt)
+       atrtab[(pairnum*PDC_OFFSET)+i] |= 8;
+    ttt = A_BLINK >> 19;
+    uuu = i&ttt;
+    if (uuu == ttt)
+       atrtab[(pairnum*PDC_OFFSET)+i] |= 128;
+   }
+ return(0);
+}
+#endif
Index: PDCurses/pdcurses/addstr.c
===================================================================
--- PDCurses/pdcurses/addstr.c	(revision 1)
+++ PDCurses/pdcurses/addstr.c	(working copy)
@@ -1,352 +1,352 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	addstr
-#undef	addnstr
-#undef	waddstr
-#undef	waddnstr
-#undef	mvaddstr
-#undef	mvaddnstr
-#undef	mvwaddstr
-#undef	mvwaddnstr
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef	move
-#  undef	wmove
-#  undef	addch
-#  undef	waddch
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_addstr  = "$Id: addstr.c,v 1.1 2001/01/10 08:26:47 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                        addstr
-
-  Synopsis:
-  	int addstr(char *str);
-  	int addnstr(char *str, int n);
-  	int waddstr(WINDOW *win, char *str);
-  	int waddnstr(WINDOW *win, char *str, int n);
-  	int mvaddstr(int y, int x, char *str);
-  	int mvaddnstr(int y, int x, char *str, int n);
-  	int mvwaddstr(WINDOW *, int y, int x, char *str);
-  	int mvwaddnstr(WINDOW *, int y, int x, char *str, int n);
-
-  X/Open Description:
- 	These routines write all the characters of the null-terminated
- 	string str on the given window.  The functionality is equivalent
- 	to calling waddch() once for each character in the string.  The four
- 	routines with n as the last argument write at most n characters.  If n
- 	is negative, then the entire string will be added.
-
- 	NOTE:	addstr(), mvaddstr(), and mvwaddstr() are implemented as macros.
- 		addnstr(), mvaddnstr(), and mvwaddnstr() are implemented as macros.
-
-  PDCurses Description:
- 	The *raw*() routines output 8 bit values.  These contrast to their
- 	normal counterparts which output 7 bit values and convert control
- 	character to the ^X notation.
-
- 	str is a standard 8 bit character string WITHOUT embedded attributes.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      addstr                                Y        Y       Y
-      waddstr                               Y        Y       Y
-      mvaddstr                              Y        Y       Y
-      mvwaddstr                             Y        Y       Y
-      addnstr                               -        -      4.0
-      waddnstr                              -        -      4.0
-      mvaddnstr                             -        -      4.0
-      mvwaddnstr                            -        -      4.0
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	addstr(char *str)
-#else
-int	PDC_CDECL	addstr(str)
-char *str;
-#endif
-/***********************************************************************/
-{
-	int i;
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("addstr() - called: string=\"%s\"\n",str);
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	while (*str)
-	{
-		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
-		if (PDC_chadd( stdscr, (chtype)i, (bool)(!(SP->raw_out)), TRUE ) == ERR)
-		{
-			return( ERR );
-		}
-	}
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	addnstr(char *str, int n)
-#else
-int	PDC_CDECL	addnstr(str,n)
-char *str;
-int n;
-#endif
-/***********************************************************************/
-{
-	int ic = 0;
-	int i;
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("addnstr() - called: string=\"%s\" n %d \n",str,n);
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	while ( *str && (ic < n || n < 0) )
-	{
-		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
-		if (PDC_chadd( stdscr, (chtype)i, (bool)(!(SP->raw_out)), TRUE ) == ERR)
-		{
-			return( ERR );
-		}
-		ic++;
-	}
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	waddstr(WINDOW *win, char *str)
-#else
-int	PDC_CDECL	waddstr(win,str)
-WINDOW *win;
-char *str;
-#endif
-/***********************************************************************/
-{
-	int i;
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("waddstr() - called: string=\"%s\"\n",str);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	while (*str)
-	{
-		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
-		if (PDC_chadd( win, (chtype)i, (bool)(!(SP->raw_out)), TRUE ) == ERR)
-		{
-			return( ERR );
-		}
-	}
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	waddnstr(WINDOW *win, char *str, int n)
-#else
-int	PDC_CDECL	waddnstr(win,str,n)
-WINDOW *win;
-char *str;
-int n;
-#endif
-/***********************************************************************/
-{
-	int ic = 0;
-	int i;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("waddnstr() - called: string=\"%s\" n %d \n",str,n);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	while ( *str && (ic < n || n < 0) )
-	{
-		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
-		if (PDC_chadd( win, (chtype)i, (bool)(!(SP->raw_out)), TRUE ) == ERR)
-		{
-			return( ERR );
-		}
-		ic++;
-	}
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvaddstr(int y, int x, char *str)
-#else
-int	PDC_CDECL	mvaddstr(y,x,str)
-int y;
-int x;
-char *str;
-#endif
-/***********************************************************************/
-{
-	int i;
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvaddstr() - called: y %d x %d string=\"%s\"\n",y,x,str);
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	if (wmove(stdscr,y,x) == ERR)
-		return( ERR );
-
-	while (*str)
-	{     
-		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
-		if (PDC_chadd( stdscr, (chtype)i, (bool)(!(SP->raw_out)), TRUE ) == ERR)
-		{
-			return( ERR );
-		}
-	}
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvaddnstr(int y, int x, char *str, int n)
-#else
-int	PDC_CDECL	mvaddnstr(y,x,str,n)
-int y;
-int x;
-char *str;
-int n;
-#endif
-/***********************************************************************/
-{
-	int ic = 0;
-	int i;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvaddnstr() - called: y %d x %d string=\"%s\" n %d \n",y,x,str,n);
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	if (wmove(stdscr,y,x) == ERR)
-		return( ERR );
-
-	while ( *str && (ic < n || n < 0) )
-	{                
-		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
-		if (PDC_chadd( stdscr, (chtype)i, (bool)(!(SP->raw_out)), TRUE ) == ERR)
-		{
-			return( ERR );
-		}
-		ic++;
-	}
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvwaddstr(WINDOW *win, int y, int x, char *str)
-#else
-int	PDC_CDECL	mvwaddstr(win,y,x,str)
-WINDOW *win;
-int y;
-int x;
-char *str;
-#endif
-/***********************************************************************/
-{
-	int i;
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("waddstr() - called: string=\"%s\"\n",str);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if (wmove(win,y,x) == ERR)
-		return( ERR );
-
-	while (*str)
-	{     
-		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
-		if (PDC_chadd( win, (chtype)i, (bool)(!(SP->raw_out)), TRUE ) == ERR)
-		{
-			return( ERR );
-		}
-	}
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvwaddnstr(WINDOW *win,int y, int x, char *str, int n)
-#else
-int	PDC_CDECL	mvwaddnstr(win,y,x,str,n)
-WINDOW *win;
-int y;
-int x;
-char *str;
-int n;
-#endif
-/***********************************************************************/
-{
-	int ic = 0;
-	int i;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvwaddnstr() - called: y %d x %d string=\"%s\" n %d \n",y,x,str,n);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if (wmove(win,y,x) == ERR)
-		return( ERR );
-
-	while ( *str && (ic < n || n < 0) )
-	{     
-		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
-		if (PDC_chadd( win, (chtype)i, (bool)(!(SP->raw_out)), TRUE ) == ERR)
-		{
-			return( ERR );
-		}
-		ic++;
-	}
-	return( OK );
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	addstr
+#undef	addnstr
+#undef	waddstr
+#undef	waddnstr
+#undef	mvaddstr
+#undef	mvaddnstr
+#undef	mvwaddstr
+#undef	mvwaddnstr
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	move
+#  undef	wmove
+#  undef	addch
+#  undef	waddch
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_addstr  = "$Id: addstr.c,v 1.1 2001/01/10 08:26:47 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        addstr
+
+  Synopsis:
+  	int addstr(char *str);
+  	int addnstr(char *str, int n);
+  	int waddstr(WINDOW *win, char *str);
+  	int waddnstr(WINDOW *win, char *str, int n);
+  	int mvaddstr(int y, int x, char *str);
+  	int mvaddnstr(int y, int x, char *str, int n);
+  	int mvwaddstr(WINDOW *, int y, int x, char *str);
+  	int mvwaddnstr(WINDOW *, int y, int x, char *str, int n);
+
+  X/Open Description:
+ 	These routines write all the characters of the null-terminated
+ 	string str on the given window.  The functionality is equivalent
+ 	to calling waddch() once for each character in the string.  The four
+ 	routines with n as the last argument write at most n characters.  If n
+ 	is negative, then the entire string will be added.
+
+ 	NOTE:	addstr(), mvaddstr(), and mvwaddstr() are implemented as macros.
+ 		addnstr(), mvaddnstr(), and mvwaddnstr() are implemented as macros.
+
+  PDCurses Description:
+ 	The *raw*() routines output 8 bit values.  These contrast to their
+ 	normal counterparts which output 7 bit values and convert control
+ 	character to the ^X notation.
+
+ 	str is a standard 8 bit character string WITHOUT embedded attributes.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      addstr                                Y        Y       Y
+      waddstr                               Y        Y       Y
+      mvaddstr                              Y        Y       Y
+      mvwaddstr                             Y        Y       Y
+      addnstr                               -        -      4.0
+      waddnstr                              -        -      4.0
+      mvaddnstr                             -        -      4.0
+      mvwaddnstr                            -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	addstr(char *str)
+#else
+int	PDC_CDECL	addstr(str)
+char *str;
+#endif
+/***********************************************************************/
+{
+	int i;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("addstr() - called: string=\"%s\"\n",str);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	while (*str)
+	{
+		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
+		if (PDC_chadd( stdscr, (chtype)i, (bool)(!(PDC_SP->raw_out)), TRUE ) == ERR)
+		{
+			return( ERR );
+		}
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	addnstr(char *str, int n)
+#else
+int	PDC_CDECL	addnstr(str,n)
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+	int ic = 0;
+	int i;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("addnstr() - called: string=\"%s\" n %d \n",str,n);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	while ( *str && (ic < n || n < 0) )
+	{
+		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
+		if (PDC_chadd( stdscr, (chtype)i, (bool)(!(PDC_SP->raw_out)), TRUE ) == ERR)
+		{
+			return( ERR );
+		}
+		ic++;
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	waddstr(WINDOW *win, char *str)
+#else
+int	PDC_CDECL	waddstr(win,str)
+WINDOW *win;
+char *str;
+#endif
+/***********************************************************************/
+{
+	int i;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("waddstr() - called: string=\"%s\"\n",str);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	while (*str)
+	{
+		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
+		if (PDC_chadd( win, (chtype)i, (bool)(!(PDC_SP->raw_out)), TRUE ) == ERR)
+		{
+			return( ERR );
+		}
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	waddnstr(WINDOW *win, char *str, int n)
+#else
+int	PDC_CDECL	waddnstr(win,str,n)
+WINDOW *win;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+	int ic = 0;
+	int i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("waddnstr() - called: string=\"%s\" n %d \n",str,n);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	while ( *str && (ic < n || n < 0) )
+	{
+		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
+		if (PDC_chadd( win, (chtype)i, (bool)(!(PDC_SP->raw_out)), TRUE ) == ERR)
+		{
+			return( ERR );
+		}
+		ic++;
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvaddstr(int y, int x, char *str)
+#else
+int	PDC_CDECL	mvaddstr(y,x,str)
+int y;
+int x;
+char *str;
+#endif
+/***********************************************************************/
+{
+	int i;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvaddstr() - called: y %d x %d string=\"%s\"\n",y,x,str);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(stdscr,y,x) == ERR)
+		return( ERR );
+
+	while (*str)
+	{     
+		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
+		if (PDC_chadd( stdscr, (chtype)i, (bool)(!(PDC_SP->raw_out)), TRUE ) == ERR)
+		{
+			return( ERR );
+		}
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvaddnstr(int y, int x, char *str, int n)
+#else
+int	PDC_CDECL	mvaddnstr(y,x,str,n)
+int y;
+int x;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+	int ic = 0;
+	int i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvaddnstr() - called: y %d x %d string=\"%s\" n %d \n",y,x,str,n);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(stdscr,y,x) == ERR)
+		return( ERR );
+
+	while ( *str && (ic < n || n < 0) )
+	{                
+		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
+		if (PDC_chadd( stdscr, (chtype)i, (bool)(!(PDC_SP->raw_out)), TRUE ) == ERR)
+		{
+			return( ERR );
+		}
+		ic++;
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwaddstr(WINDOW *win, int y, int x, char *str)
+#else
+int	PDC_CDECL	mvwaddstr(win,y,x,str)
+WINDOW *win;
+int y;
+int x;
+char *str;
+#endif
+/***********************************************************************/
+{
+	int i;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("waddstr() - called: string=\"%s\"\n",str);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(win,y,x) == ERR)
+		return( ERR );
+
+	while (*str)
+	{     
+		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
+		if (PDC_chadd( win, (chtype)i, (bool)(!(PDC_SP->raw_out)), TRUE ) == ERR)
+		{
+			return( ERR );
+		}
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwaddnstr(WINDOW *win,int y, int x, char *str, int n)
+#else
+int	PDC_CDECL	mvwaddnstr(win,y,x,str,n)
+WINDOW *win;
+int y;
+int x;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+	int ic = 0;
+	int i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwaddnstr() - called: y %d x %d string=\"%s\" n %d \n",y,x,str,n);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(win,y,x) == ERR)
+		return( ERR );
+
+	while ( *str && (ic < n || n < 0) )
+	{     
+		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
+		if (PDC_chadd( win, (chtype)i, (bool)(!(PDC_SP->raw_out)), TRUE ) == ERR)
+		{
+			return( ERR );
+		}
+		ic++;
+	}
+	return( OK );
+}
Index: PDCurses/pdcurses/overlay.c
===================================================================
--- PDCurses/pdcurses/overlay.c	(revision 1)
+++ PDCurses/pdcurses/overlay.c	(working copy)
@@ -1,310 +1,310 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	overlay
-#undef	overwrite
-#undef	copywin
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef	move
-#  undef	wmove
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_overlay  = "$Id: overlay.c,v 1.1 2001/01/10 08:27:18 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                       overlay
-
-  Synopsis:
-  	int	overlay(WINDOW *src_w, WINDOW *dst_w)
-  	int	overwrite(WINDOW *src_w, WINDOW *dst_w)
-  	int	copywin(WINDOW *src_w, WINDOW *dst_w, int src_tr,
-  			int src_tc, int dst_tr, int dst_tc, int dst_br, int dst_bc,
-  			bool overlay)
-
-  X/Open Description:
- 	The overlay() and overwrite() functions overlay src_w on top of 
- 	dst_w; that is, all text in src_w is copied into dst_w. The windows
- 	src_w and dst_w are not required to be the same size. The
- 	copy starts at (0, 0) on each window. The difference between
- 	the two functions is that overlay() is non-destructive
- 	(blanks are not copied) while overwrite() is destructive
- 	(blanks are copied).
-
- 	copywin() is similar to overwrite() and overlay() but copywin()
- 	does not require that the two windows overlap.
- 	The arguments src_tc and src_tr specify the top left corner of the
- 	region to be copied to the destination window.
- 	The arguments dst_tc,dst_tr,dst_br,dst_bc specify the region within
- 	the destination window to where the copy is made.
- 	The argument overlay, if TRUE, indicates that the copy is done
- 	non-destructively (as in overlay()). Blanks in the source window
- 	are not copied to the destination window. When overlay is FALSE,
- 	(as in overwrite()), the copy is destructive; blanks are copied
- 	to the destination window.
-
-  PDCurses Description:
- 	The above description for overlay() and overwrite() is misleading 
- 	in the actual behaviour exhibited by both SysV and BSD curses. 
- 	The above implies that the character in 0,0 of the source window 
- 	is copied to 0,0 of the destination window. What actually happens 
- 	is that those characters in the source window that intersect with 
- 	characters in the destination window RELATIVE TO ABSOLUTE 0,0 ON 
- 	THE SCREEN, are copied to the destination window so that the 
- 	characters appear in the same physical position on the screen.
-
- 	Thanks to Andreas Otte (venn@@uni-paderborn.de) for the correction
- 	and code changes.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      overlay                               Y        Y       Y
-      overwrite                             Y        Y       Y
-      copywin                               -        -      3.0
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	overlay(WINDOW *src_w, WINDOW *dst_w)
-#else
-int	PDC_CDECL	overlay(src_w,dst_w)
-WINDOW *src_w;
-WINDOW *dst_w;
-#endif
-/***********************************************************************/
-{
-	int	last_line;
-	int	last_col;
-	int	first_line;
-	int	first_col;
-	int	src_start_x;
-	int	src_start_y;
-	int	dst_start_x;
-	int	dst_start_y;
-	int	xdiff;
-	int	ydiff;
-	int	rc;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("overlay() - called\n");
-#endif
-
-	if (src_w == (WINDOW *)NULL)	return( ERR );
-	if (dst_w == (WINDOW *)NULL)	return( ERR );
-
-	first_col  = max(dst_w->_begx,src_w->_begx);
-	first_line = max(dst_w->_begy,src_w->_begy);
-	last_col   = min(src_w->_begx+src_w->_maxx, dst_w->_begx+dst_w->_maxx);
-	last_line  = min(src_w->_begy+src_w->_maxy, dst_w->_begy+dst_w->_maxy);
-
-/* determine the overlapping region of the two windows in real coordinates */
-	if ((last_col < first_col) || (last_line < first_line))
-    return(OK);  /* if no overlapping region, do nothing */
-
-/* size of overlapping region */
-	xdiff = last_col - first_col;
-	ydiff = last_line - first_line;
-
-	if (src_w->_begx <= dst_w->_begx)
-		{
-		src_start_x = dst_w->_begx - src_w->_begx;
-		dst_start_x = 0;
-		}
-	else
-		{
-		dst_start_x = src_w->_begx - dst_w->_begx;
-		src_start_x = 0;
-		}
-	if (src_w->_begy <= dst_w->_begy)
-		{
-		src_start_y = dst_w->_begy - src_w->_begy;
-		dst_start_y = 0;
-		}
-	else
-		{
-		dst_start_y = src_w->_begy - dst_w->_begy;
-		src_start_y = 0;
-		}
-
-	rc = PDC_copy_win(src_w,dst_w,src_start_y,src_start_x,
-		src_start_y+ydiff,src_start_x+xdiff,dst_start_y,dst_start_x,
-		dst_start_y+ydiff,dst_start_x+xdiff,TRUE);
-
-	return( rc );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	overwrite(WINDOW *src_w, WINDOW *dst_w)
-#else
-int	PDC_CDECL	overwrite(src_w,dst_w)
-WINDOW *src_w;
-WINDOW *dst_w;
-#endif
-/***********************************************************************/
-{
-	int	last_line;
-	int	last_col;
-	int	first_line;
-	int	first_col;
-	int	src_start_x;
-	int	src_start_y;
-	int	dst_start_x;
-	int	dst_start_y;
-	int	xdiff;
-	int	ydiff;
-	int	rc;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("overwrit() - called\n");
-#endif
-
-	if (src_w == (WINDOW *)NULL)	return( ERR );
-	if (dst_w == (WINDOW *)NULL)	return( ERR );
-
-	first_col  = max(dst_w->_begx,src_w->_begx);
-	first_line = max(dst_w->_begy,src_w->_begy);
-	last_col   = min(src_w->_begx+src_w->_maxx, dst_w->_begx+dst_w->_maxx);
-	last_line  = min(src_w->_begy+src_w->_maxy, dst_w->_begy+dst_w->_maxy);
-
-/* determine the overlapping region of the two windows in real coordinates */
-	if ((last_col < first_col) || (last_line < first_line))
-    return(OK);  /* if no overlapping region, do nothing */
-
-/* size of overlapping region */
-	xdiff = last_col - first_col;
-	ydiff = last_line - first_line;
-
-	if (src_w->_begx <= dst_w->_begx)
-		{
-		src_start_x = dst_w->_begx - src_w->_begx;
-		dst_start_x = 0;
-		}
-	else
-		{
-		dst_start_x = src_w->_begx - dst_w->_begx;
-		src_start_x = 0;
-		}
-	if (src_w->_begy <= dst_w->_begy)
-		{
-		src_start_y = dst_w->_begy - src_w->_begy;
-		dst_start_y = 0;
-		}
-	else
-		{
-		dst_start_y = src_w->_begy - dst_w->_begy;
-		src_start_y = 0;
-		}
-
-	rc = PDC_copy_win(src_w,dst_w,src_start_y,src_start_x,
-		src_start_y+ydiff,src_start_x+xdiff,dst_start_y,dst_start_x,
-		dst_start_y+ydiff,dst_start_x+xdiff,FALSE);
-
-	return( rc );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	copywin(WINDOW *src_w, WINDOW *dst_w, int src_tr, int src_tc, int dst_tr,
-	int dst_tc, int dst_br, int dst_bc, int overlay)
-#else
-int	PDC_CDECL	copywin(src_w,dst_w,src_tr,src_tc,dst_tr,dst_tc,dst_br,dst_bc,overlay)
-WINDOW *src_w;
-WINDOW *dst_w;
-int src_tr;
-int src_tc;
-int dst_tr;
-int dst_tc;
-int dst_br;
-int dst_bc;
-int overlay;
-#endif
-/***********************************************************************/
-{
-	int	src_start_x = src_tc;
-	int	src_start_y = src_tr;
-	int	dst_start_x = dst_tc;
-	int	dst_start_y = dst_tr;
-	int	src_end_x;
-	int	src_end_y;
-	int	dst_end_x;
-	int	dst_end_y;
-	int	src_rows,src_cols;
-	int	dst_rows,dst_cols;
-	int	min_rows,min_cols;
-	int	rc;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("copywin() - called\n");
-#endif
-
-	if (src_w == (WINDOW *)NULL
-	||  dst_w == (WINDOW *)NULL)
-		return( ERR );
-
-	if (dst_w == curscr)	return( ERR );
-
-#if 0
-	if (dst_br >= dst_w->_maxy
-	||  dst_bc >= dst_w->_maxx
-	||  dst_tr < 0
-	||  dst_tc < 0)
-		return( ERR );
-#else
-	if (dst_br > dst_w->_maxy
-	||  dst_bc > dst_w->_maxx
-	||  dst_tr < 0
-	||  dst_tc < 0)
-		return( ERR );
-#endif
-
-	src_rows = src_w->_maxy - src_tr;
-	src_cols = src_w->_maxx - src_tc;
-	dst_rows = dst_br - dst_tr;
-	dst_cols = dst_bc - dst_tc;
-
-	min_rows = min(src_rows,dst_rows);
-	min_cols = min(src_cols,dst_cols);
-
-	src_end_y = src_tr + min_rows;
-	src_end_x = src_tc + min_cols;
-	dst_end_y = dst_tr + min_rows;
-	dst_end_x = dst_tc + min_cols;
-
-	rc = PDC_copy_win(src_w,dst_w,src_start_y,src_start_x,src_end_y,src_end_x,
-		dst_start_y,dst_start_x,dst_end_y,dst_end_x,overlay);
-
-	return( rc );
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	overlay
+#undef	overwrite
+#undef	copywin
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	move
+#  undef	wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_overlay  = "$Id: overlay.c,v 1.1 2001/01/10 08:27:18 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                       overlay
+
+  Synopsis:
+  	int	overlay(WINDOW *src_w, WINDOW *dst_w)
+  	int	overwrite(WINDOW *src_w, WINDOW *dst_w)
+  	int	copywin(WINDOW *src_w, WINDOW *dst_w, int src_tr,
+  			int src_tc, int dst_tr, int dst_tc, int dst_br, int dst_bc,
+  			bool overlay)
+
+  X/Open Description:
+ 	The overlay() and overwrite() functions overlay src_w on top of 
+ 	dst_w; that is, all text in src_w is copied into dst_w. The windows
+ 	src_w and dst_w are not required to be the same size. The
+ 	copy starts at (0, 0) on each window. The difference between
+ 	the two functions is that overlay() is non-destructive
+ 	(blanks are not copied) while overwrite() is destructive
+ 	(blanks are copied).
+
+ 	copywin() is similar to overwrite() and overlay() but copywin()
+ 	does not require that the two windows overlap.
+ 	The arguments src_tc and src_tr specify the top left corner of the
+ 	region to be copied to the destination window.
+ 	The arguments dst_tc,dst_tr,dst_br,dst_bc specify the region within
+ 	the destination window to where the copy is made.
+ 	The argument overlay, if TRUE, indicates that the copy is done
+ 	non-destructively (as in overlay()). Blanks in the source window
+ 	are not copied to the destination window. When overlay is FALSE,
+ 	(as in overwrite()), the copy is destructive; blanks are copied
+ 	to the destination window.
+
+  PDCurses Description:
+ 	The above description for overlay() and overwrite() is misleading 
+ 	in the actual behaviour exhibited by both SysV and BSD curses. 
+ 	The above implies that the character in 0,0 of the source window 
+ 	is copied to 0,0 of the destination window. What actually happens 
+ 	is that those characters in the source window that intersect with 
+ 	characters in the destination window RELATIVE TO ABSOLUTE 0,0 ON 
+ 	THE SCREEN, are copied to the destination window so that the 
+ 	characters appear in the same physical position on the screen.
+
+ 	Thanks to Andreas Otte (venn@@uni-paderborn.de) for the correction
+ 	and code changes.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      overlay                               Y        Y       Y
+      overwrite                             Y        Y       Y
+      copywin                               -        -      3.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	overlay(WINDOW *src_w, WINDOW *dst_w)
+#else
+int	PDC_CDECL	overlay(src_w,dst_w)
+WINDOW *src_w;
+WINDOW *dst_w;
+#endif
+/***********************************************************************/
+{
+	int	last_line;
+	int	last_col;
+	int	first_line;
+	int	first_col;
+	int	src_start_x;
+	int	src_start_y;
+	int	dst_start_x;
+	int	dst_start_y;
+	int	xdiff;
+	int	ydiff;
+	int	rc;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("overlay() - called\n");
+#endif
+
+	if (src_w == (WINDOW *)NULL)	return( ERR );
+	if (dst_w == (WINDOW *)NULL)	return( ERR );
+
+	first_col  = max(dst_w->_begx,src_w->_begx);
+	first_line = max(dst_w->_begy,src_w->_begy);
+	last_col   = min(src_w->_begx+src_w->_maxx, dst_w->_begx+dst_w->_maxx);
+	last_line  = min(src_w->_begy+src_w->_maxy, dst_w->_begy+dst_w->_maxy);
+
+/* determine the overlapping region of the two windows in real coordinates */
+	if ((last_col < first_col) || (last_line < first_line))
+    return(OK);  /* if no overlapping region, do nothing */
+
+/* size of overlapping region */
+	xdiff = last_col - first_col;
+	ydiff = last_line - first_line;
+
+	if (src_w->_begx <= dst_w->_begx)
+		{
+		src_start_x = dst_w->_begx - src_w->_begx;
+		dst_start_x = 0;
+		}
+	else
+		{
+		dst_start_x = src_w->_begx - dst_w->_begx;
+		src_start_x = 0;
+		}
+	if (src_w->_begy <= dst_w->_begy)
+		{
+		src_start_y = dst_w->_begy - src_w->_begy;
+		dst_start_y = 0;
+		}
+	else
+		{
+		dst_start_y = src_w->_begy - dst_w->_begy;
+		src_start_y = 0;
+		}
+
+	rc = PDC_copy_win(src_w,dst_w,src_start_y,src_start_x,
+		src_start_y+ydiff,src_start_x+xdiff,dst_start_y,dst_start_x,
+		dst_start_y+ydiff,dst_start_x+xdiff,TRUE);
+
+	return( rc );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	overwrite(WINDOW *src_w, WINDOW *dst_w)
+#else
+int	PDC_CDECL	overwrite(src_w,dst_w)
+WINDOW *src_w;
+WINDOW *dst_w;
+#endif
+/***********************************************************************/
+{
+	int	last_line;
+	int	last_col;
+	int	first_line;
+	int	first_col;
+	int	src_start_x;
+	int	src_start_y;
+	int	dst_start_x;
+	int	dst_start_y;
+	int	xdiff;
+	int	ydiff;
+	int	rc;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("overwrit() - called\n");
+#endif
+
+	if (src_w == (WINDOW *)NULL)	return( ERR );
+	if (dst_w == (WINDOW *)NULL)	return( ERR );
+
+	first_col  = max(dst_w->_begx,src_w->_begx);
+	first_line = max(dst_w->_begy,src_w->_begy);
+	last_col   = min(src_w->_begx+src_w->_maxx, dst_w->_begx+dst_w->_maxx);
+	last_line  = min(src_w->_begy+src_w->_maxy, dst_w->_begy+dst_w->_maxy);
+
+/* determine the overlapping region of the two windows in real coordinates */
+	if ((last_col < first_col) || (last_line < first_line))
+    return(OK);  /* if no overlapping region, do nothing */
+
+/* size of overlapping region */
+	xdiff = last_col - first_col;
+	ydiff = last_line - first_line;
+
+	if (src_w->_begx <= dst_w->_begx)
+		{
+		src_start_x = dst_w->_begx - src_w->_begx;
+		dst_start_x = 0;
+		}
+	else
+		{
+		dst_start_x = src_w->_begx - dst_w->_begx;
+		src_start_x = 0;
+		}
+	if (src_w->_begy <= dst_w->_begy)
+		{
+		src_start_y = dst_w->_begy - src_w->_begy;
+		dst_start_y = 0;
+		}
+	else
+		{
+		dst_start_y = src_w->_begy - dst_w->_begy;
+		src_start_y = 0;
+		}
+
+	rc = PDC_copy_win(src_w,dst_w,src_start_y,src_start_x,
+		src_start_y+ydiff,src_start_x+xdiff,dst_start_y,dst_start_x,
+		dst_start_y+ydiff,dst_start_x+xdiff,FALSE);
+
+	return( rc );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	copywin(WINDOW *src_w, WINDOW *dst_w, int src_tr, int src_tc, int dst_tr,
+	int dst_tc, int dst_br, int dst_bc, int overlay)
+#else
+int	PDC_CDECL	copywin(src_w,dst_w,src_tr,src_tc,dst_tr,dst_tc,dst_br,dst_bc,overlay)
+WINDOW *src_w;
+WINDOW *dst_w;
+int src_tr;
+int src_tc;
+int dst_tr;
+int dst_tc;
+int dst_br;
+int dst_bc;
+int overlay;
+#endif
+/***********************************************************************/
+{
+	int	src_start_x = src_tc;
+	int	src_start_y = src_tr;
+	int	dst_start_x = dst_tc;
+	int	dst_start_y = dst_tr;
+	int	src_end_x;
+	int	src_end_y;
+	int	dst_end_x;
+	int	dst_end_y;
+	int	src_rows,src_cols;
+	int	dst_rows,dst_cols;
+	int	min_rows,min_cols;
+	int	rc;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("copywin() - called\n");
+#endif
+
+	if (src_w == (WINDOW *)NULL
+	||  dst_w == (WINDOW *)NULL)
+		return( ERR );
+
+	if (dst_w == curscr)	return( ERR );
+
+#if 0
+	if (dst_br >= dst_w->_maxy
+	||  dst_bc >= dst_w->_maxx
+	||  dst_tr < 0
+	||  dst_tc < 0)
+		return( ERR );
+#else
+	if (dst_br > dst_w->_maxy
+	||  dst_bc > dst_w->_maxx
+	||  dst_tr < 0
+	||  dst_tc < 0)
+		return( ERR );
+#endif
+
+	src_rows = src_w->_maxy - src_tr;
+	src_cols = src_w->_maxx - src_tc;
+	dst_rows = dst_br - dst_tr;
+	dst_cols = dst_bc - dst_tc;
+
+	min_rows = min(src_rows,dst_rows);
+	min_cols = min(src_cols,dst_cols);
+
+	src_end_y = src_tr + min_rows;
+	src_end_x = src_tc + min_cols;
+	dst_end_y = dst_tr + min_rows;
+	dst_end_x = dst_tc + min_cols;
+
+	rc = PDC_copy_win(src_w,dst_w,src_start_y,src_start_x,src_end_y,src_end_x,
+		dst_start_y,dst_start_x,dst_end_y,dst_end_x,overlay);
+
+	return( rc );
+}
Index: PDCurses/pdcurses/inch.c
===================================================================
--- PDCurses/pdcurses/inch.c	(revision 1)
+++ PDCurses/pdcurses/inch.c	(working copy)
@@ -1,138 +1,138 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	inch
-#undef	winch
-#undef	mvinch
-#undef	mvwinch
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef	move
-#  undef	wmove
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_inch  = "$Id: inch.c,v 1.1 2001/01/10 08:27:04 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                          inch
-
-  Synopsis:
-  	chtype inch(void);
-  	chtype winch(WINDOW *win);
-  	chtype mvinch(int y, int x);
-  	chtype mvwinch(WINDOW *win, int y, int x);
-
-  X/Open Description:
-
- 	NOTE: All these functions are implemented as macros.
-
-  PDCurses Description:
- 	Depending upon the state of the raw character output, 7- or
- 	8-bit characters will be output.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      inch                                  Y        Y       Y
-      winch                                 Y        Y       Y
-      mvinch                                Y        Y       Y
-      mvwinch                               Y        Y       Y
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-chtype	PDC_CDECL	inch(void)
-#else
-chtype	PDC_CDECL	inch()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("inch() - called\n");
-#endif
-
-	return( stdscr->_y[stdscr->_cury][stdscr->_curx] );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-chtype	PDC_CDECL	winch(WINDOW *win)
-#else
-chtype	PDC_CDECL	winch(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("winch() - called\n");
-#endif
-
-	return( win->_y[win->_cury][win->_curx] );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-chtype	PDC_CDECL	mvinch(int y, int x)
-#else
-chtype	PDC_CDECL	mvinch(y,x)
-int y;
-int x;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvinch() - called\n");
-#endif
-
-	(void)(move(y,x));
-	return( stdscr->_y[stdscr->_cury][stdscr->_curx] );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-chtype	PDC_CDECL	mvwinch(WINDOW *win, int y, int x)
-#else
-chtype	PDC_CDECL	mvwinch(win,y,x)
-WINDOW *win;
-int y;
-int x;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvwinch() - called\n");
-#endif
-
-	(void)(wmove(win,y,x));
-	return( win->_y[win->_cury][win->_curx] );
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	inch
+#undef	winch
+#undef	mvinch
+#undef	mvwinch
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	move
+#  undef	wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_inch  = "$Id: inch.c,v 1.1 2001/01/10 08:27:04 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                          inch
+
+  Synopsis:
+  	chtype inch(void);
+  	chtype winch(WINDOW *win);
+  	chtype mvinch(int y, int x);
+  	chtype mvwinch(WINDOW *win, int y, int x);
+
+  X/Open Description:
+
+ 	NOTE: All these functions are implemented as macros.
+
+  PDCurses Description:
+ 	Depending upon the state of the raw character output, 7- or
+ 	8-bit characters will be output.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      inch                                  Y        Y       Y
+      winch                                 Y        Y       Y
+      mvinch                                Y        Y       Y
+      mvwinch                               Y        Y       Y
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+chtype	PDC_CDECL	inch(void)
+#else
+chtype	PDC_CDECL	inch()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("inch() - called\n");
+#endif
+
+	return( stdscr->_y[stdscr->_cury][stdscr->_curx] );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+chtype	PDC_CDECL	winch(WINDOW *win)
+#else
+chtype	PDC_CDECL	winch(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winch() - called\n");
+#endif
+
+	return( win->_y[win->_cury][win->_curx] );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+chtype	PDC_CDECL	mvinch(int y, int x)
+#else
+chtype	PDC_CDECL	mvinch(y,x)
+int y;
+int x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvinch() - called\n");
+#endif
+
+	(void)(move(y,x));
+	return( stdscr->_y[stdscr->_cury][stdscr->_curx] );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+chtype	PDC_CDECL	mvwinch(WINDOW *win, int y, int x)
+#else
+chtype	PDC_CDECL	mvwinch(win,y,x)
+WINDOW *win;
+int y;
+int x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwinch() - called\n");
+#endif
+
+	(void)(wmove(win,y,x));
+	return( win->_y[win->_cury][win->_curx] );
+}
Index: PDCurses/pdcurses/insstr.c
===================================================================
--- PDCurses/pdcurses/insstr.c	(revision 1)
+++ PDCurses/pdcurses/insstr.c	(working copy)
@@ -1,290 +1,290 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-#ifdef HAVE_STRING_H
-# include <string.h>
-#endif
-
-/* undefine any macros for functions defined in this module */
-#undef	insstr
-#undef	insnstr
-#undef	winsstr
-#undef	winsnstr
-#undef	mvinsstr
-#undef	mvinsnstr
-#undef	mvwinsstr
-#undef	mvwinsnstr
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef	move
-#  undef	wmove
-#  undef	addch
-#  undef	waddch
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_insstr  = "$Id: insstr.c,v 1.2 2002/03/22 22:36:52 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                        insstr
-
-  Synopsis:
-  	int insstr(char *str);
-  	int insnstr(char *str, int n);
-  	int winsstr(WINDOW *win, char *str);
-  	int winsnstr(WINDOW *win, char *str, int n);
-  	int mvinsstr(int y, int x, char *str);
-  	int mvinsnstr(int y, int x, char *str, int n);
-  	int mvwinsstr(WINDOW *, int y, int x, char *str);
-  	int mvwinsnstr(WINDOW *, int y, int x, char *str, int n);
-
-  System V Curses Description:
-  	With these routines, a character string (as many characters as 
-  	will fit on the line) is inserted before the character under 
-  	the cursor.  All characters to the right of the cursor are moved 
-  	to the right, with the possibility of the rightmost characters 
-  	on the line being lost.  The cursor position does not change 
-  	(after moving to y,x if specified).  The four routines with n as 
-  	the last argument insert at most n characters.  If n<=0, then 
-  	the entire string is inserted.
-
- 	NOTE:	insstr(), mvinsstr(), and mvwinsstr() are implemented as macros.
- 		insnstr(), mvinsnstr(), and mvwinsnstr() are implemented as macros.
-
-  PDCurses Description:
- 	The *raw*() routines output 8 bit values.  These contrast to their
- 	normal counterparts which output 7 bit values and convert control
- 	character to the ^X notation.
-
- 	str is a standard 8 bit character string WITHOUT embedded attributes.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      insstr                                -        -      4.0
-      winsstr                               -        -      4.0
-      mvinsstr                              -        -      4.0
-      mvwinsstr                             -        -      4.0
-      insnstr                               -        -      4.0
-      winsnstr                              -        -      4.0
-      mvinsnstr                             -        -      4.0
-      mvwinsnstr                            -        -      4.0
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	insstr(char *str)
-#else
-int	PDC_CDECL	insstr(str)
-char *str;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("insstr() - called: string=\"%s\"\n",str);
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	return(winsnstr(stdscr,str,(-1)));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	insnstr(char *str, int n)
-#else
-int	PDC_CDECL	insnstr(str,n)
-char *str;
-int n;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("insnstr() - called: string=\"%s\" n %d \n",str,n);
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	return(winsnstr(stdscr,str,n));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	winsstr(WINDOW *win, char *str)
-#else
-int	PDC_CDECL	winsstr(win,str)
-WINDOW *win;
-char *str;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("winsstr() - called: string=\"%s\"\n",str);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	return(winsnstr(win,str,(-1)));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	winsnstr(WINDOW *win, char *str, int n)
-#else
-int	PDC_CDECL	winsnstr(win,str,n)
-WINDOW *win;
-char *str;
-int n;
-#endif
-/***********************************************************************/
-{
-	int ic = strlen(str);
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("winsnstr() - called: string=\"%s\" n %d \n",str,n);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if( n > 0 )
-		ic = ((ic<n)?ic:n) - 1;
-	else
-		ic = ic - 1;
-
-	for ( ; ic >= 0; ic-- )
-	{
-		if (winsch(win, *(str+ic) ) == ERR)
-		{
-			return( ERR );
-		}
-	}
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvinsstr(int y, int x, char *str)
-#else
-int	PDC_CDECL	mvinsstr(y,x,str)
-int y;
-int x;
-char *str;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvinsstr() - called: y %d x %d string=\"%s\"\n",y,x,str);
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	if (move(y,x) == ERR)
-		return( ERR );
-
-	return(winsnstr(stdscr,str,(-1)));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvinsnstr(int y, int x, char *str, int n)
-#else
-int	PDC_CDECL	mvinsnstr(y,x,str,n)
-int y;
-int x;
-char *str;
-int n;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvinsnstr() - called: y %d x %d string=\"%s\" n %d \n",y,x,str,n);
-#endif
-
-	if (stdscr == (WINDOW *)NULL)
-		return( ERR );
-
-	if (move(y,x) == ERR)
-		return( ERR );
-
-	return(winsnstr(stdscr,str,n));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvwinsstr(WINDOW *win, int y, int x, char *str)
-#else
-int	PDC_CDECL	mvwinsstr(win,y,x,str)
-WINDOW *win;
-int y;
-int x;
-char *str;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("winsstr() - called: string=\"%s\"\n",str);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if (wmove(win,y,x) == ERR)
-		return( ERR );
-
-	return(winsnstr(win,str,(-1)));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mvwinsnstr(WINDOW *win,int y, int x, char *str, int n)
-#else
-int	PDC_CDECL	mvwinsnstr(win,y,x,str,n)
-WINDOW *win;
-int y;
-int x;
-char *str;
-int n;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mvwinsnstr() - called: y %d x %d string=\"%s\" n %d \n",y,x,str,n);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if (wmove(win,y,x) == ERR)
-		return( ERR );
-
-	return(winsnstr(win,str,n));
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef	insstr
+#undef	insnstr
+#undef	winsstr
+#undef	winsnstr
+#undef	mvinsstr
+#undef	mvinsnstr
+#undef	mvwinsstr
+#undef	mvwinsnstr
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	move
+#  undef	wmove
+#  undef	addch
+#  undef	waddch
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_insstr  = "$Id: insstr.c,v 1.2 2002/03/22 22:36:52 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        insstr
+
+  Synopsis:
+  	int insstr(char *str);
+  	int insnstr(char *str, int n);
+  	int winsstr(WINDOW *win, char *str);
+  	int winsnstr(WINDOW *win, char *str, int n);
+  	int mvinsstr(int y, int x, char *str);
+  	int mvinsnstr(int y, int x, char *str, int n);
+  	int mvwinsstr(WINDOW *, int y, int x, char *str);
+  	int mvwinsnstr(WINDOW *, int y, int x, char *str, int n);
+
+  System V Curses Description:
+  	With these routines, a character string (as many characters as 
+  	will fit on the line) is inserted before the character under 
+  	the cursor.  All characters to the right of the cursor are moved 
+  	to the right, with the possibility of the rightmost characters 
+  	on the line being lost.  The cursor position does not change 
+  	(after moving to y,x if specified).  The four routines with n as 
+  	the last argument insert at most n characters.  If n<=0, then 
+  	the entire string is inserted.
+
+ 	NOTE:	insstr(), mvinsstr(), and mvwinsstr() are implemented as macros.
+ 		insnstr(), mvinsnstr(), and mvwinsnstr() are implemented as macros.
+
+  PDCurses Description:
+ 	The *raw*() routines output 8 bit values.  These contrast to their
+ 	normal counterparts which output 7 bit values and convert control
+ 	character to the ^X notation.
+
+ 	str is a standard 8 bit character string WITHOUT embedded attributes.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      insstr                                -        -      4.0
+      winsstr                               -        -      4.0
+      mvinsstr                              -        -      4.0
+      mvwinsstr                             -        -      4.0
+      insnstr                               -        -      4.0
+      winsnstr                              -        -      4.0
+      mvinsnstr                             -        -      4.0
+      mvwinsnstr                            -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	insstr(char *str)
+#else
+int	PDC_CDECL	insstr(str)
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("insstr() - called: string=\"%s\"\n",str);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	return(winsnstr(stdscr,str,(-1)));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	insnstr(char *str, int n)
+#else
+int	PDC_CDECL	insnstr(str,n)
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("insnstr() - called: string=\"%s\" n %d \n",str,n);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	return(winsnstr(stdscr,str,n));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	winsstr(WINDOW *win, char *str)
+#else
+int	PDC_CDECL	winsstr(win,str)
+WINDOW *win;
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winsstr() - called: string=\"%s\"\n",str);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(winsnstr(win,str,(-1)));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	winsnstr(WINDOW *win, char *str, int n)
+#else
+int	PDC_CDECL	winsnstr(win,str,n)
+WINDOW *win;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+	int ic = strlen(str);
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winsnstr() - called: string=\"%s\" n %d \n",str,n);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if( n > 0 )
+		ic = ((ic<n)?ic:n) - 1;
+	else
+		ic = ic - 1;
+
+	for ( ; ic >= 0; ic-- )
+	{
+		if (winsch(win, *(str+ic) ) == ERR)
+		{
+			return( ERR );
+		}
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvinsstr(int y, int x, char *str)
+#else
+int	PDC_CDECL	mvinsstr(y,x,str)
+int y;
+int x;
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvinsstr() - called: y %d x %d string=\"%s\"\n",y,x,str);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (move(y,x) == ERR)
+		return( ERR );
+
+	return(winsnstr(stdscr,str,(-1)));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvinsnstr(int y, int x, char *str, int n)
+#else
+int	PDC_CDECL	mvinsnstr(y,x,str,n)
+int y;
+int x;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvinsnstr() - called: y %d x %d string=\"%s\" n %d \n",y,x,str,n);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (move(y,x) == ERR)
+		return( ERR );
+
+	return(winsnstr(stdscr,str,n));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwinsstr(WINDOW *win, int y, int x, char *str)
+#else
+int	PDC_CDECL	mvwinsstr(win,y,x,str)
+WINDOW *win;
+int y;
+int x;
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winsstr() - called: string=\"%s\"\n",str);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(win,y,x) == ERR)
+		return( ERR );
+
+	return(winsnstr(win,str,(-1)));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwinsnstr(WINDOW *win,int y, int x, char *str, int n)
+#else
+int	PDC_CDECL	mvwinsnstr(win,y,x,str,n)
+WINDOW *win;
+int y;
+int x;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwinsnstr() - called: y %d x %d string=\"%s\" n %d \n",y,x,str,n);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(win,y,x) == ERR)
+		return( ERR );
+
+	return(winsnstr(win,str,n));
+}
Index: PDCurses/pdcurses/touch.c
===================================================================
--- PDCurses/pdcurses/touch.c	(revision 1)
+++ PDCurses/pdcurses/touch.c	(working copy)
@@ -1,262 +1,262 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	touchwin
-#undef	touchline
-#undef	untouchwin
-#undef	wtouchln
-#undef	is_linetouched
-#undef	is_wintouched
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef	move
-#  undef	wmove
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_touch  = "$Id: touch.c,v 1.1 2001/01/10 08:27:32 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                         touch
-
-  Synopsis:
-  	int touchwin(WINDOW *win);
-  	int touchline(WINDOW *win, int start,int count);
-  	int untouchwin(WINDOW *win);
-  	int wtouchln(WINDOW *win, int y, int n, int changed);
-  	int is_linetouched(WINDOW *win,int line);
-  	int is_wintouched(WINDOW *win);
-
-  X/Open Description:
- 	The touchwin() and touchline() functions throw away all optimisation 
- 	information about which parts of the window have been touched, 
- 	by pretending that the entire window has been drawn on.  
- 	This is sometimes necessary when using overlapping
- 	windows, since a change to one window will affect the other window,
- 	but the records of which lines have been changed in the other
- 	window will not reflect the change.
-
- 	The untouchwin() routine marks all lines in the window as unchanged
- 	since the last call to wrefresh().
-
- 	The wtouchln() routine makes n lines in the window, starting at 
- 	line y, look as if they have (changed=1) or have not (changed=0) 
- 	been changed since the last call to wrefresh().
-
- 	The is_linetouched() routine returns TRUE if the specified line 
- 	in the specified window has been changed since the last call to 
- 	wrefresh(). If the line has not changed, FALSE is returned.
-
- 	The is_wintouched() routine returns TRUE if the specified window 
- 	has been changed since the last call to wrefresh(). If the window 
- 	has not changed, FALSE is returned.
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error except
- 	is_wintouched() and is_linetouched().
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      touchwin                              Y        Y       Y
-      touchline                             Y        -      3.0
-      untouchwin                            -        -      4.0
-      wtouchln                              Y        Y       Y
-      is_linetouched                        -        -      4.0
-      is_wintouched                         -        -      4.0
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	touchwin(WINDOW *win)
-#else
-int	PDC_CDECL	touchwin(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-	register int	i;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("touchwin() - called: Win=%x\n",win);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	for (i=0;i<win->_maxy;i++)
-	{
-		win->_firstch[i] = 0;
-		win->_lastch[i] = win->_maxx-1;
-	}
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	touchline(WINDOW *win, int start,int count)
-#else
-int	PDC_CDECL	touchline(win,start,count)
-WINDOW *win;
-int start;
-int count;
-#endif
-/***********************************************************************/
-{
-	register int i;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("touchline() - called: win=%x start %d count %d\n",win,start,count);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if  (start > win->_maxy || start + count > win->_maxy)
-		return( ERR );
-	for(i=start;i<start+count;i++)
-	   {
-		win->_firstch[i] = 0;
-		win->_lastch[i] = win->_maxx - 1;
-	   }
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	untouchwin(WINDOW *win)
-#else
-int	PDC_CDECL	untouchwin(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-	register int i;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("untouchwin() - called: win=%x",win);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	for (i=0;i<win->_maxy;i++)
-	{
-		win->_firstch[i] = _NO_CHANGE;
-		win->_lastch[i] = _NO_CHANGE;
-	}
-	return(OK);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	wtouchln(WINDOW *win, int y, int n, int changed)
-#else
-int	PDC_CDECL	wtouchln(win,y,n,changed)
-WINDOW *win;
-int y;
-int n;
-int changed;
-#endif
-/***********************************************************************/
-{
-	register int i;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wtouchln() - called: win=%x y=%d n=%d changed=%d\n",win,y,n,changed);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	if  (y > win->_maxy || y + n > win->_maxy)
-		return( ERR );
-
-	for (i=y;i<y+n;i++)
-	{
-		if ( changed ) 
-		{
-			win->_firstch[i] = 0;
-			win->_lastch[i] = win->_maxx - 1;
-		}
-		else 
-		{
-			win->_firstch[i] = _NO_CHANGE;
-			win->_lastch[i] = _NO_CHANGE;
-		}
-	}
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	is_linetouched(WINDOW *win,int line)
-#else
-int	PDC_CDECL	is_linetouched(win,line)
-WINDOW *win;
-int line;
-#endif
-/***********************************************************************/
-{
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("is_linetouched() - called: win=%x line=%d\n",win,line);
-#endif
-
-	if (win == NULL)
-		return(ERR);
-
-	if (line > win->_maxy || line < 0)
-		return(ERR);
-	if (win->_firstch[line] != _NO_CHANGE) 
-		return(TRUE);
-	return(FALSE);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	is_wintouched(WINDOW *win)
-#else
-int	PDC_CDECL	is_wintouched(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-	register int i;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("is_wintouched() - called: win=%x\n",win);
-#endif
-
-	if (win == NULL)
-		return(ERR);
-
-	for (i=0;i<win->_maxy;i++)
-		if (win->_firstch[i] != _NO_CHANGE)
-			return(TRUE);
-	return(FALSE);
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	touchwin
+#undef	touchline
+#undef	untouchwin
+#undef	wtouchln
+#undef	is_linetouched
+#undef	is_wintouched
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	move
+#  undef	wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_touch  = "$Id: touch.c,v 1.1 2001/01/10 08:27:32 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         touch
+
+  Synopsis:
+  	int touchwin(WINDOW *win);
+  	int touchline(WINDOW *win, int start,int count);
+  	int untouchwin(WINDOW *win);
+  	int wtouchln(WINDOW *win, int y, int n, int changed);
+  	int is_linetouched(WINDOW *win,int line);
+  	int is_wintouched(WINDOW *win);
+
+  X/Open Description:
+ 	The touchwin() and touchline() functions throw away all optimisation 
+ 	information about which parts of the window have been touched, 
+ 	by pretending that the entire window has been drawn on.  
+ 	This is sometimes necessary when using overlapping
+ 	windows, since a change to one window will affect the other window,
+ 	but the records of which lines have been changed in the other
+ 	window will not reflect the change.
+
+ 	The untouchwin() routine marks all lines in the window as unchanged
+ 	since the last call to wrefresh().
+
+ 	The wtouchln() routine makes n lines in the window, starting at 
+ 	line y, look as if they have (changed=1) or have not (changed=0) 
+ 	been changed since the last call to wrefresh().
+
+ 	The is_linetouched() routine returns TRUE if the specified line 
+ 	in the specified window has been changed since the last call to 
+ 	wrefresh(). If the line has not changed, FALSE is returned.
+
+ 	The is_wintouched() routine returns TRUE if the specified window 
+ 	has been changed since the last call to wrefresh(). If the window 
+ 	has not changed, FALSE is returned.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error except
+ 	is_wintouched() and is_linetouched().
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      touchwin                              Y        Y       Y
+      touchline                             Y        -      3.0
+      untouchwin                            -        -      4.0
+      wtouchln                              Y        Y       Y
+      is_linetouched                        -        -      4.0
+      is_wintouched                         -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	touchwin(WINDOW *win)
+#else
+int	PDC_CDECL	touchwin(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	register int	i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("touchwin() - called: Win=%x\n",win);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	for (i=0;i<win->_maxy;i++)
+	{
+		win->_firstch[i] = 0;
+		win->_lastch[i] = win->_maxx-1;
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	touchline(WINDOW *win, int start,int count)
+#else
+int	PDC_CDECL	touchline(win,start,count)
+WINDOW *win;
+int start;
+int count;
+#endif
+/***********************************************************************/
+{
+	register int i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("touchline() - called: win=%x start %d count %d\n",win,start,count);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if  (start > win->_maxy || start + count > win->_maxy)
+		return( ERR );
+	for(i=start;i<start+count;i++)
+	   {
+		win->_firstch[i] = 0;
+		win->_lastch[i] = win->_maxx - 1;
+	   }
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	untouchwin(WINDOW *win)
+#else
+int	PDC_CDECL	untouchwin(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	register int i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("untouchwin() - called: win=%x",win);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	for (i=0;i<win->_maxy;i++)
+	{
+		win->_firstch[i] = _NO_CHANGE;
+		win->_lastch[i] = _NO_CHANGE;
+	}
+	return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wtouchln(WINDOW *win, int y, int n, int changed)
+#else
+int	PDC_CDECL	wtouchln(win,y,n,changed)
+WINDOW *win;
+int y;
+int n;
+int changed;
+#endif
+/***********************************************************************/
+{
+	register int i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wtouchln() - called: win=%x y=%d n=%d changed=%d\n",win,y,n,changed);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if  (y > win->_maxy || y + n > win->_maxy)
+		return( ERR );
+
+	for (i=y;i<y+n;i++)
+	{
+		if ( changed ) 
+		{
+			win->_firstch[i] = 0;
+			win->_lastch[i] = win->_maxx - 1;
+		}
+		else 
+		{
+			win->_firstch[i] = _NO_CHANGE;
+			win->_lastch[i] = _NO_CHANGE;
+		}
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	is_linetouched(WINDOW *win,int line)
+#else
+int	PDC_CDECL	is_linetouched(win,line)
+WINDOW *win;
+int line;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("is_linetouched() - called: win=%x line=%d\n",win,line);
+#endif
+
+	if (win == NULL)
+		return(ERR);
+
+	if (line > win->_maxy || line < 0)
+		return(ERR);
+	if (win->_firstch[line] != _NO_CHANGE) 
+		return(TRUE);
+	return(FALSE);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	is_wintouched(WINDOW *win)
+#else
+int	PDC_CDECL	is_wintouched(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	register int i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("is_wintouched() - called: win=%x\n",win);
+#endif
+
+	if (win == NULL)
+		return(ERR);
+
+	for (i=0;i<win->_maxy;i++)
+		if (win->_firstch[i] != _NO_CHANGE)
+			return(TRUE);
+	return(FALSE);
+}
Index: PDCurses/pdcurses/clear.c
===================================================================
--- PDCurses/pdcurses/clear.c	(revision 1)
+++ PDCurses/pdcurses/clear.c	(working copy)
@@ -1,267 +1,267 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-/* undefine any macros for functions defined in this module */
-#undef	clear
-#undef	wclear
-#undef	erase
-#undef	werase
-#undef	clrtobot
-#undef	wclrtobot
-#undef	clrtoeol
-#undef	wclrtoeol
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_clear  = "$Id: clear.c,v 1.1 2001/01/10 08:26:54 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                         clear
-
-  Synopsis:
-  	int clear(void);
-  	int wclear(WINDOW *win);
-  	int erase(void);
-  	int werase(WINDOW *win);
-  	int clrtobot(void);
-  	int wclrtobot(WINDOW *win);
-  	int clrtoeol(void);
-  	int wclrtoeol(WINDOW *win);
-
-  X/Open Description:
-  	The erase() and werase() functions copy blanks to every position
-  	of the window.
-
-  	The clear() and wclear() functions are similar to erase() and
-  	werase() except they also call clearok() to ensure that the
-  	the screen is cleared on the next call to wrefresh() for that
-  	window.
-
-  	The clrtobot() and wclrtobot() functions clear the screen from
-  	the current cursor position to the end of the current line and
-  	all remaining lines in the window.
-
-  	The clrtoeol() and wclrtoeol() functions clear the screen from
-  	the current cursor position to the end of the current line only.
-
- 	NOTE: clear(), wclear(), erase(), clrtobot(), and clrtoeol()
- 	are implemented as macros
-
-  PDCurses Description:
-
-  X/Open Return Value:
- 	All functions return OK on success and ERR on error.
-
-  X/Open Errors:
- 	No errors are defined for this function.
-
-  NOTE:
- 	The behaviour of Unix curses is to clear the line with a space
- 	and attributes of A_NORMAL. PDCurses clears the line with the
- 	window's current attributes (including current colour). To get
- 	the behaviour of PDCurses, #define PDCURSES_WCLR in curses.h or
- 	add -DPDCURSES_WCLR to the compile switches.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      clear                                 Y        Y       Y
-      wclear                                Y        Y       Y
-      erase                                 Y        Y       Y
-      werase                                Y        Y       Y
-      clrtobot                              Y        Y       Y
-      wclrtobot                             Y        Y       Y
-      clrtoeol                              Y        Y       Y
-      wclrtoeol                             Y        Y       Y
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	clear(void)
-#else
-int	PDC_CDECL	clear()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("clear() - called\n");
-#endif
-
-	if  (stdscr == (WINDOW *)NULL)
-		return(ERR);
-
-	stdscr->_clear = TRUE;
-	return(erase());
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	wclear( WINDOW *win )
-#else
-int	PDC_CDECL	wclear(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wclear() - called\n");
-#endif
-
-	if  (win == (WINDOW *)NULL)
-		return( ERR );
-
-	win->_clear = TRUE;
-	return( werase( win ) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	erase(void)
-#else
-int	PDC_CDECL	erase()
-#endif
-/***********************************************************************/
-{
-	return( werase(stdscr) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	werase(WINDOW *win)
-#else
-int	PDC_CDECL	werase(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("werase() - called\n");
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	(void)wmove(win,0,0);
-	return (wclrtobot(win));
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	clrtobot(void)
-#else
-int	PDC_CDECL	clrtobot()
-#endif
-/***********************************************************************/
-{
-	return( wclrtobot(stdscr) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	wclrtobot(WINDOW *win)
-#else
-int	PDC_CDECL	wclrtobot(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-	int	savey=win->_cury;
-	int	savex=win->_curx;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wclrtobot() - called\n");
-#endif
-
-	if  (win == (WINDOW *)NULL)
-		return( ERR );
-
-/* should this involve scrolling region somehow ? */
-
-	if (win->_cury + 1 < win->_maxy)
-		{
-		win->_curx = 0;
-		win->_cury++;
-		for ( ; win->_maxy > win->_cury; win->_cury++)
-			(void)wclrtoeol(win);
-		win->_cury = savey;
-		win->_curx = savex;
-		}
-	(void)wclrtoeol(win);
-
-	PDC_sync(win);
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	clrtoeol(void)
-#else
-int	PDC_CDECL	clrtoeol()
-#endif
-/***********************************************************************/
-{
-	return( wclrtoeol(stdscr) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	wclrtoeol(WINDOW *win)
-#else
-int	PDC_CDECL	wclrtoeol(win)
-WINDOW *win;
-#endif
-/***********************************************************************/
-{
-	int	y=0;
-	int	x=0;
-	int	minx=0;
-	chtype	blank=0;
-	chtype*	ptr=NULL;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wclrtoeol() - called: Row: %d Col: %d\n",win->_cury,win->_curx);
-#endif
-
-	if (win == (WINDOW *)NULL)
-		return( ERR );
-
-	y	= win->_cury;
-	x	= win->_curx;
-
-#if defined(PDCURSES_WCLR)
-	blank	= win->_blank | win->_attrs;
-#else
-/* wrs (4/10/93) account for window background */
-	blank	= win->_bkgd;
-#endif
-
-	for (minx=x,ptr=&win->_y[y][x];minx<win->_maxx;minx++,*ptr++)
-		*ptr = blank;
-
-	win->_firstch[y] = (win->_firstch[y]==_NO_CHANGE)?x:min(x,win->_firstch[y]);
-	win->_lastch[y] = max(win->_lastch[y],win->_maxx-1);
-
-	PDC_sync(win);
-	return( OK );
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	clear
+#undef	wclear
+#undef	erase
+#undef	werase
+#undef	clrtobot
+#undef	wclrtobot
+#undef	clrtoeol
+#undef	wclrtoeol
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_clear  = "$Id: clear.c,v 1.1 2001/01/10 08:26:54 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         clear
+
+  Synopsis:
+  	int clear(void);
+  	int wclear(WINDOW *win);
+  	int erase(void);
+  	int werase(WINDOW *win);
+  	int clrtobot(void);
+  	int wclrtobot(WINDOW *win);
+  	int clrtoeol(void);
+  	int wclrtoeol(WINDOW *win);
+
+  X/Open Description:
+  	The erase() and werase() functions copy blanks to every position
+  	of the window.
+
+  	The clear() and wclear() functions are similar to erase() and
+  	werase() except they also call clearok() to ensure that the
+  	the screen is cleared on the next call to wrefresh() for that
+  	window.
+
+  	The clrtobot() and wclrtobot() functions clear the screen from
+  	the current cursor position to the end of the current line and
+  	all remaining lines in the window.
+
+  	The clrtoeol() and wclrtoeol() functions clear the screen from
+  	the current cursor position to the end of the current line only.
+
+ 	NOTE: clear(), wclear(), erase(), clrtobot(), and clrtoeol()
+ 	are implemented as macros
+
+  PDCurses Description:
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  NOTE:
+ 	The behaviour of Unix curses is to clear the line with a space
+ 	and attributes of A_NORMAL. PDCurses clears the line with the
+ 	window's current attributes (including current colour). To get
+ 	the behaviour of PDCurses, #define PDCURSES_WCLR in curses.h or
+ 	add -DPDCURSES_WCLR to the compile switches.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      clear                                 Y        Y       Y
+      wclear                                Y        Y       Y
+      erase                                 Y        Y       Y
+      werase                                Y        Y       Y
+      clrtobot                              Y        Y       Y
+      wclrtobot                             Y        Y       Y
+      clrtoeol                              Y        Y       Y
+      wclrtoeol                             Y        Y       Y
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	clear(void)
+#else
+int	PDC_CDECL	clear()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("clear() - called\n");
+#endif
+
+	if  (stdscr == (WINDOW *)NULL)
+		return(ERR);
+
+	stdscr->_clear = TRUE;
+	return(erase());
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wclear( WINDOW *win )
+#else
+int	PDC_CDECL	wclear(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wclear() - called\n");
+#endif
+
+	if  (win == (WINDOW *)NULL)
+		return( ERR );
+
+	win->_clear = TRUE;
+	return( werase( win ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	erase(void)
+#else
+int	PDC_CDECL	erase()
+#endif
+/***********************************************************************/
+{
+	return( werase(stdscr) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	werase(WINDOW *win)
+#else
+int	PDC_CDECL	werase(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("werase() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	(void)wmove(win,0,0);
+	return (wclrtobot(win));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	clrtobot(void)
+#else
+int	PDC_CDECL	clrtobot()
+#endif
+/***********************************************************************/
+{
+	return( wclrtobot(stdscr) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wclrtobot(WINDOW *win)
+#else
+int	PDC_CDECL	wclrtobot(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	int	savey=win->_cury;
+	int	savex=win->_curx;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wclrtobot() - called\n");
+#endif
+
+	if  (win == (WINDOW *)NULL)
+		return( ERR );
+
+/* should this involve scrolling region somehow ? */
+
+	if (win->_cury + 1 < win->_maxy)
+		{
+		win->_curx = 0;
+		win->_cury++;
+		for ( ; win->_maxy > win->_cury; win->_cury++)
+			(void)wclrtoeol(win);
+		win->_cury = savey;
+		win->_curx = savex;
+		}
+	(void)wclrtoeol(win);
+
+	PDC_sync(win);
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	clrtoeol(void)
+#else
+int	PDC_CDECL	clrtoeol()
+#endif
+/***********************************************************************/
+{
+	return( wclrtoeol(stdscr) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wclrtoeol(WINDOW *win)
+#else
+int	PDC_CDECL	wclrtoeol(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	int	y=0;
+	int	x=0;
+	int	minx=0;
+	chtype	blank=0;
+	chtype*	ptr=NULL;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wclrtoeol() - called: Row: %d Col: %d\n",win->_cury,win->_curx);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	y	= win->_cury;
+	x	= win->_curx;
+
+#if defined(PDCURSES_WCLR)
+	blank	= win->_blank | win->_attrs;
+#else
+/* wrs (4/10/93) account for window background */
+	blank	= win->_bkgd;
+#endif
+
+	for (minx=x,ptr=&win->_y[y][x];minx<win->_maxx;minx++,*ptr++)
+		*ptr = blank;
+
+	win->_firstch[y] = (win->_firstch[y]==_NO_CHANGE)?x:min(x,win->_firstch[y]);
+	win->_lastch[y] = max(win->_lastch[y],win->_maxx-1);
+
+	PDC_sync(win);
+	return( OK );
+}
Index: PDCurses/pdcurses/mouse.c
===================================================================
--- PDCurses/pdcurses/mouse.c	(revision 1)
+++ PDCurses/pdcurses/mouse.c	(working copy)
@@ -1,246 +1,246 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-#ifdef HAVE_STRING_H
-# include <string.h>
-#endif
-
-/* undefine any macros for functions defined in this module */
-#undef	mouse_set
-#undef	mouse_on
-#undef	mouse_off
-#undef	request_mouse_pos
-#undef	map_button
-#undef	wmouse_position
-#undef	getmouse
-#undef	getbmap
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_mouse = "$Id: mouse.c,v 1.2 2002/03/22 22:36:53 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                         mouse
-
-  Synopsis:
-
-  	int mouse_set( long );
-  	int mouse_on( long );
-  	int mouse_off( long );
-  	int request_mouse_pos( void );
-  	int map_button( unsigned long );
-  	void wmouse_position( WINDOW *, int *, int * );
-  	unsigned long getmouse( void );
-  	unsigned long getbmap( void );
-
-  PDCurses Description:
- 	ALL DESCRIPTIONS ARE GUESSES. I DON'T KNOW ANYONE WHO KNOWS
- 	EXACTLY WHAT THESE FUNCTIONS DO!
-
- 	The mouse_set(), mouse_on() and mouse_off() functions are analagous to
- 	the attrset(), attron() and attroff() functions.  These functions
- 	set the mouse button events to trap.  The button masks used in these
- 	functions are defined in curses.h and can be or'ed together. They are
- 	the group of masks starting with BUTTON1_RELEASED.
-
- 	The request_mouse_pos() function requests curses to fill in the
- 	Mouse_status structure with the current state of the mouse.
-
- 	The map_button() function enables the mouse requested mouse action
- 	to activate the Soft Label Keys if the mouse action occurs over the
- 	area of the screen where the Soft Label Keys are displayed.  The
- 	mouse actions are defined in curses.h and are the group that start
- 	with BUTTON_RELEASED.
-
- 	The wmouse_position() function determines if the current mouse
- 	position is within the window passed as an argument.  If the mouse
- 	is outside the current window, -1 is returned in the y and x arguments
- 	otherwise the y and x coordinates of the mouse (relative to the top
- 	left corner of the window) are returned in y and x.
-
- 	The getmouse() function returns the current status of the trapped
- 	mouse buttons as set by mouse_set(), mouse_on();
-
- 	The getbmap() function returns the current status of the button action
- 	used to map a mouse action to the Soft Label Keys as set by the
- 	map_button() function.
-
-  PDCurses Errors:
- 	None.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      mouse_set                             -        -      4.0
-      mouse_on                              -        -      4.0
-      mouse_off                             -        -      4.0
-      request_mouse_pos                     -        -      4.0
-      map_button                            -        -      4.0
-      wmouse_position                       -        -      4.0
-      getmouse                              -        -      4.0
-      getbmap                               -        -      4.0
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mouse_set(unsigned long mbe)
-#else
-int	PDC_CDECL	mouse_set(mbe)
-unsigned long mbe;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mouse_set() - called: event %x\n",mbe);
-#endif
-	SP->_trap_mbe = mbe;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mouse_on(unsigned long mbe)
-#else
-int	PDC_CDECL	mouse_on(mbe)
-unsigned long mbe;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mouse_on() - called: event %x\n",mbe);
-#endif
-	SP->_trap_mbe |= mbe;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	mouse_off(unsigned long mbe)
-#else
-int	PDC_CDECL	mouse_off(mbe)
-unsigned long mbe;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("mouse_off() - called: event %x\n",mbe);
-#endif
-	SP->_trap_mbe &= ~mbe;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	map_button(unsigned long button)
-#else
-int	PDC_CDECL	map_button(button)
-unsigned long button;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("map_button() - called: button %x\n",button);
-#endif
-/****************** this does nothing at the moment ***************/
-	SP->_map_mbe_to_key = button;
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_CDECL	request_mouse_pos(void)
-#else
-int	PDC_CDECL	request_mouse_pos()
-#endif
-/***********************************************************************/
-{
-extern MOUSE_STATUS Trapped_Mouse_status;
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("request_mouse_pos() - called\n");
-#endif
-	memcpy((char*)&Mouse_status,(char*)&Trapped_Mouse_status,sizeof(MOUSE_STATUS));
-	return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-void	PDC_CDECL	wmouse_position(WINDOW *win, int *y, int *x)
-#else
-void	PDC_CDECL	wmouse_position(win,y,x)
-WINDOW *win;
-int *y,*x;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("wmouse_position() - called\n");
-#endif
-/* if the current mouse position is outside the provided window, put  */
-/* -1 in x and y                                                      */
-	if (win == (WINDOW *)NULL)
-	{
-		*y = *x = (-1);
-		return;
-	}
-	if (win->_begy > MOUSE_Y_POS 
-	||  win->_begx > MOUSE_X_POS 
-	||  win->_begy+win->_maxy <= MOUSE_Y_POS
-	||  win->_begx+win->_maxx <= MOUSE_X_POS)
-	{
-		*x = *y = (-1);
-	}
-	else
-	{
-		*x = MOUSE_X_POS - win->_begx;
-		*y = MOUSE_Y_POS - win->_begy;
-	}
-	return;
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-unsigned long	PDC_CDECL	getmouse(void)
-#else
-unsigned long	PDC_CDECL	getmouse()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("getmouse() - called\n");
-#endif
-	return(SP->_trap_mbe);
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-unsigned long	PDC_CDECL	getbmap(void)
-#else
-unsigned long	PDC_CDECL	getbmap()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("getbmap() - called\n");
-#endif
-	return(SP->_map_mbe_to_key);
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef	mouse_set
+#undef	mouse_on
+#undef	mouse_off
+#undef	request_mouse_pos
+#undef	map_button
+#undef	wmouse_position
+#undef	getmouse
+#undef	getbmap
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_mouse = "$Id: mouse.c,v 1.2 2002/03/22 22:36:53 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         mouse
+
+  Synopsis:
+
+  	int mouse_set( long );
+  	int mouse_on( long );
+  	int mouse_off( long );
+  	int request_mouse_pos( void );
+  	int map_button( unsigned long );
+  	void wmouse_position( WINDOW *, int *, int * );
+  	unsigned long getmouse( void );
+  	unsigned long getbmap( void );
+
+  PDCurses Description:
+ 	ALL DESCRIPTIONS ARE GUESSES. I DON'T KNOW ANYONE WHO KNOWS
+ 	EXACTLY WHAT THESE FUNCTIONS DO!
+
+ 	The mouse_set(), mouse_on() and mouse_off() functions are analagous to
+ 	the attrset(), attron() and attroff() functions.  These functions
+ 	set the mouse button events to trap.  The button masks used in these
+ 	functions are defined in curses.h and can be or'ed together. They are
+ 	the group of masks starting with BUTTON1_RELEASED.
+
+ 	The request_mouse_pos() function requests curses to fill in the
+ 	Mouse_status structure with the current state of the mouse.
+
+ 	The map_button() function enables the mouse requested mouse action
+ 	to activate the Soft Label Keys if the mouse action occurs over the
+ 	area of the screen where the Soft Label Keys are displayed.  The
+ 	mouse actions are defined in curses.h and are the group that start
+ 	with BUTTON_RELEASED.
+
+ 	The wmouse_position() function determines if the current mouse
+ 	position is within the window passed as an argument.  If the mouse
+ 	is outside the current window, -1 is returned in the y and x arguments
+ 	otherwise the y and x coordinates of the mouse (relative to the top
+ 	left corner of the window) are returned in y and x.
+
+ 	The getmouse() function returns the current status of the trapped
+ 	mouse buttons as set by mouse_set(), mouse_on();
+
+ 	The getbmap() function returns the current status of the button action
+ 	used to map a mouse action to the Soft Label Keys as set by the
+ 	map_button() function.
+
+  PDCurses Errors:
+ 	None.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      mouse_set                             -        -      4.0
+      mouse_on                              -        -      4.0
+      mouse_off                             -        -      4.0
+      request_mouse_pos                     -        -      4.0
+      map_button                            -        -      4.0
+      wmouse_position                       -        -      4.0
+      getmouse                              -        -      4.0
+      getbmap                               -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mouse_set(unsigned long mbe)
+#else
+int	PDC_CDECL	mouse_set(mbe)
+unsigned long mbe;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mouse_set() - called: event %x\n",mbe);
+#endif
+	PDC_SP->_trap_mbe = mbe;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mouse_on(unsigned long mbe)
+#else
+int	PDC_CDECL	mouse_on(mbe)
+unsigned long mbe;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mouse_on() - called: event %x\n",mbe);
+#endif
+	PDC_SP->_trap_mbe |= mbe;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mouse_off(unsigned long mbe)
+#else
+int	PDC_CDECL	mouse_off(mbe)
+unsigned long mbe;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mouse_off() - called: event %x\n",mbe);
+#endif
+	PDC_SP->_trap_mbe &= ~mbe;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	map_button(unsigned long button)
+#else
+int	PDC_CDECL	map_button(button)
+unsigned long button;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("map_button() - called: button %x\n",button);
+#endif
+/****************** this does nothing at the moment ***************/
+	PDC_SP->_map_mbe_to_key = button;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	request_mouse_pos(void)
+#else
+int	PDC_CDECL	request_mouse_pos()
+#endif
+/***********************************************************************/
+{
+extern MOUSE_STATUS Trapped_Mouse_status;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("request_mouse_pos() - called\n");
+#endif
+	memcpy((char*)&Mouse_status,(char*)&Trapped_Mouse_status,sizeof(MOUSE_STATUS));
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	wmouse_position(WINDOW *win, int *y, int *x)
+#else
+void	PDC_CDECL	wmouse_position(win,y,x)
+WINDOW *win;
+int *y,*x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wmouse_position() - called\n");
+#endif
+/* if the current mouse position is outside the provided window, put  */
+/* -1 in x and y                                                      */
+	if (win == (WINDOW *)NULL)
+	{
+		*y = *x = (-1);
+		return;
+	}
+	if (win->_begy > MOUSE_Y_POS 
+	||  win->_begx > MOUSE_X_POS 
+	||  win->_begy+win->_maxy <= MOUSE_Y_POS
+	||  win->_begx+win->_maxx <= MOUSE_X_POS)
+	{
+		*x = *y = (-1);
+	}
+	else
+	{
+		*x = MOUSE_X_POS - win->_begx;
+		*y = MOUSE_Y_POS - win->_begy;
+	}
+	return;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+unsigned long	PDC_CDECL	getmouse(void)
+#else
+unsigned long	PDC_CDECL	getmouse()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("getmouse() - called\n");
+#endif
+	return(PDC_SP->_trap_mbe);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+unsigned long	PDC_CDECL	getbmap(void)
+#else
+unsigned long	PDC_CDECL	getbmap()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("getbmap() - called\n");
+#endif
+	return(PDC_SP->_map_mbe_to_key);
+}
Index: PDCurses/pdcurses/addchstr.c
===================================================================
--- PDCurses/pdcurses/addchstr.c	(revision 1)
+++ PDCurses/pdcurses/addchstr.c	(working copy)
@@ -1,393 +1,393 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define  CURSES_LIBRARY 1
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <curses.h>
-
-#ifdef HAVE_STRING_H
-# include <string.h>
-#endif
-
-/* undefine any macros for functions defined in this module */
-#undef   addchstr
-#undef   addchnstr
-#undef   waddchstr
-#undef   waddchnstr
-#undef   mvaddchstr
-#undef   mvaddchnstr
-#undef   mvwaddchstr
-#undef   mvwaddchnstr
-
-/* undefine any macros for functions called by this module if in debug mode */
-#ifdef PDCDEBUG
-#  undef move
-#  undef wmove
-#endif
-
-#ifdef PDCDEBUG
-char *rcsid_addchstr  = "$Id: addchstr.c,v 1.3 2002/12/16 09:41:34 mark Exp $";
-#endif
-
-/*man-start*********************************************************************
-
-  Name:                                                        addchstr
-
-  Synopsis:
-   int addchstr(chtype *ch);
-   int addchnstr(chtype *ch, int n);
-   int waddchstr(WINDOW *win, chtype *ch);
-   int waddchnstr(WINDOW *win, chtype *ch, int n);
-   int mvaddchstr(int y, int x, chtype *ch);
-   int mvaddchnstr(int y, int x, chtype *ch, int n);
-   int mvwaddchstr(WINDOW *, int y, int x, chtype *ch);
-   int mvwaddchnstr(WINDOW *, int y, int x, chtype *ch, int n);
-
-  X/Open Description:
-   These routines write a chtype directly into the window structure
-   starting at the current position.
-   The four routines with n as the last argument copy at most n
-   elements, but no more than will fit on the line.
-   If n=-1 then the whole string is copied, to the maximum number
-   that will fit on the line.
-
-   The cursor position is not advanced. These routines do not check for
-   newline or other special characters, no does any line wrapping occur.
-
-   NOTE: addchstr(), mvaddchstr(), mvwaddchstr() addchnstr(), 
-      mvaddchnstr(), and mvwaddchnstr() are implemented as macros.
-
-  X/Open Return Value:
-   All functions return OK on success and ERR on error.
-
-  X/Open Errors:
-   No errors are defined for this function.
-
-  Portability                             X/Open    BSD    SYS V
-                                          Dec '88
-      addchstr                              -        -      4.0
-      waddchstr                             -        -      4.0
-      mvaddchstr                            -        -      4.0
-      mvwaddchstr                           -        -      4.0
-      addchnstr                             -        -      4.0
-      waddchnstr                            -        -      4.0
-      mvaddchnstr                           -        -      4.0
-      mvwaddchnstr                          -        -      4.0
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   addchstr(chtype *ch)
-#else
-int   PDC_CDECL   addchstr(ch)
-chtype *ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("addchstr() - called\n");
-#endif
-
-   return( addchnstr( ch, -1) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   addchnstr(chtype *ch, int n)
-#else
-int   PDC_CDECL   addchnstr(ch,n)
-chtype *ch;
-int n;
-#endif
-/***********************************************************************/
-{
-   int y,x,num,maxx;
-   chtype *ptr;
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("addchnstr() - called\n");
-#endif
-
-   if (stdscr == (WINDOW *)NULL)
-      return( ERR );
-
-   if (n == 0
-   ||  n < (-1))
-      return( ERR );
-
-   x = stdscr->_curx;
-   y = stdscr->_cury;
-   ptr = &(stdscr->_y[y][x]);
-
-
-   if (n == (-1))
-   {
-      for (num = stdscr->_maxx - x; *ch && num--; num++)
-      {
-         *ptr++ = *ch++;
-      }
-      maxx = num;
-   }
-   else
-   {
-      num = min(stdscr->_maxx - x,n);
-      memcpy((char *)ptr, (char *)ch, (int)(num * sizeof(chtype)));
-      maxx = x+num-1;
-   }
-
-   if (stdscr->_firstch[y] == _NO_CHANGE)
-   {
-      stdscr->_firstch[y] = x;
-      stdscr->_lastch[y] = maxx;
-   }
-   else
-   {
-      if (x <  stdscr->_firstch[y])
-      {
-         stdscr->_firstch[y] = x;
-      }
-      if (maxx >  stdscr->_lastch[y])
-      {
-         stdscr->_lastch[y] = maxx;
-      }
-   }
-   return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   waddchstr(WINDOW *win, chtype *ch)
-#else
-int   PDC_CDECL   waddchstr(win,ch)
-WINDOW *win;
-chtype *ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("waddchstr() - called: win=%x\n",win);
-#endif
-
-   if (win == (WINDOW *)NULL)
-      return( ERR );
-
-   return( waddchnstr( win, ch, -1) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   waddchnstr(WINDOW *win, chtype *ch, int n)
-#else
-int   PDC_CDECL   waddchnstr(win,ch,n)
-WINDOW *win;
-chtype *ch;
-int n;
-#endif
-/***********************************************************************/
-{
-   register int i,y,x,num,maxx,minx;
-   int first=1;
-   chtype *ptr,*mptr;
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("waddchnstr() - called: win=%x n=%d\n",win,n);
-#endif
-
-   if (win == (WINDOW *)NULL)
-      return( ERR );
-
-   if (n == 0
-   ||  n < (-1))
-      return( ERR );
-
-   x = win->_curx;
-   y = win->_cury;
-   ptr = mptr = &(win->_y[y][x]);
-
-#if 0
-   if (n == (-1))
-      {
-      for (num = win->_maxx - x; *ch && num--; num++)
-         *ptr++ = *ch++;
-      maxx = num;
-      }
-   else
-      {
-      num = min(win->_maxx - x,n);
-      maxx = x+num-1;
-      memcpy((char *)ptr, (char *)ch, (int)(num * sizeof(chtype)));
-      }
-
-   if (win->_firstch[y] == _NO_CHANGE)
-      {
-      win->_firstch[y] = x;
-      win->_lastch[y] = maxx;
-      }
-   else
-      {
-      if (x <  win->_firstch[y])
-         {
-         win->_firstch[y] = x;
-         }
-      if (maxx >  win->_lastch[y])
-         {
-         win->_lastch[y] = maxx;
-         }
-      }
-
-#else
-
-   if (n == (-1))
-      num = win->_maxx - x;
-   else
-      num = min(win->_maxx - x,n);
-
-   minx = win->_firstch[y];
-   maxx = win->_lastch[y];
-   for (i=x; num && *ch; num--, i++)
-   {
-      if (i < win->_firstch[y]
-      ||  win->_firstch[y] == _NO_CHANGE)
-      {
-         if (*ptr != *ch && first)
-         {
-            minx = i;
-            first = 0;
-         }
-         }
-         if (i > win->_lastch[y])
-         {
-            if (*ptr != *ch)
-               maxx = i;
-         }
-
-#ifdef PDCDEBUG
-      if (trace_on)
-      {
-         PDC_debug("y %d i %d minx %d maxx %d *ptr %x *ch %x firstch: %d lastch: %d\n",
-                   y,i,minx,maxx,
-                   *ptr,*ch,
-                   win->_firstch[y],win->_lastch[y]
-                   );
-      }
-#endif
-
-      *ptr++ = *ch++;
-   }
-
-   win->_firstch[y] = minx;
-   win->_lastch[y] = maxx;
-#endif
-
-   return( OK );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   mvaddchstr(int y, int x, chtype *ch)
-#else
-int   PDC_CDECL   mvaddchstr(y,x,ch)
-int y;
-int x;
-chtype *ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("mvaddchstr() - called: y %d x %d\n",y,x);
-#endif
-
-   if (stdscr == (WINDOW *)NULL)
-      return( ERR );
-
-   if (wmove(stdscr,y,x) == ERR)
-      return( ERR );
-
-   return( addchnstr( ch, -1) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   mvaddchnstr(int y, int x, chtype *ch, int n)
-#else
-int   PDC_CDECL   mvaddchnstr(y,x,ch,n)
-int y;
-int x;
-chtype *ch;
-int n;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("mvaddchnstr() - called: y %d x %d n %d\n",y,x,n);
-#endif
-
-   if (stdscr == (WINDOW *)NULL)
-      return( ERR );
-
-   if (wmove(stdscr,y,x) == ERR)
-      return( ERR );
-
-   return( addchnstr( ch, n) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   mvwaddchstr(WINDOW *win, int y, int x, chtype *ch)
-#else
-int   PDC_CDECL   mvwaddchstr(win,y,x,ch)
-WINDOW *win;
-int y;
-int x;
-chtype *ch;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("waddchstr() - called:\n");
-#endif
-
-   if (win == (WINDOW *)NULL)
-      return( ERR );
-
-   if (wmove(win,y,x) == ERR)
-      return( ERR );
-
-   return( waddchnstr( win, ch, -1) );
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_CDECL   mvwaddchnstr(WINDOW *win,int y, int x, chtype *ch, int n)
-#else
-int   PDC_CDECL   mvwaddchnstr(win,y,x,ch,n)
-WINDOW *win;
-int y;
-int x;
-chtype *ch;
-int n;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("mvwaddchnstr() - called: y %d x %d n %d \n",y,x,n);
-#endif
-
-   if (win == (WINDOW *)NULL)
-      return( ERR );
-
-   if (wmove(win,y,x) == ERR)
-      return( ERR );
-
-   return( waddchnstr( win, ch, n) );
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define  CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef   addchstr
+#undef   addchnstr
+#undef   waddchstr
+#undef   waddchnstr
+#undef   mvaddchstr
+#undef   mvaddchnstr
+#undef   mvwaddchstr
+#undef   mvwaddchnstr
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef move
+#  undef wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_addchstr  = "$Id: addchstr.c,v 1.3 2002/12/16 09:41:34 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        addchstr
+
+  Synopsis:
+   int addchstr(chtype *ch);
+   int addchnstr(chtype *ch, int n);
+   int waddchstr(WINDOW *win, chtype *ch);
+   int waddchnstr(WINDOW *win, chtype *ch, int n);
+   int mvaddchstr(int y, int x, chtype *ch);
+   int mvaddchnstr(int y, int x, chtype *ch, int n);
+   int mvwaddchstr(WINDOW *, int y, int x, chtype *ch);
+   int mvwaddchnstr(WINDOW *, int y, int x, chtype *ch, int n);
+
+  X/Open Description:
+   These routines write a chtype directly into the window structure
+   starting at the current position.
+   The four routines with n as the last argument copy at most n
+   elements, but no more than will fit on the line.
+   If n=-1 then the whole string is copied, to the maximum number
+   that will fit on the line.
+
+   The cursor position is not advanced. These routines do not check for
+   newline or other special characters, no does any line wrapping occur.
+
+   NOTE: addchstr(), mvaddchstr(), mvwaddchstr() addchnstr(), 
+      mvaddchnstr(), and mvwaddchnstr() are implemented as macros.
+
+  X/Open Return Value:
+   All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+   No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      addchstr                              -        -      4.0
+      waddchstr                             -        -      4.0
+      mvaddchstr                            -        -      4.0
+      mvwaddchstr                           -        -      4.0
+      addchnstr                             -        -      4.0
+      waddchnstr                            -        -      4.0
+      mvaddchnstr                           -        -      4.0
+      mvwaddchnstr                          -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   addchstr(chtype *ch)
+#else
+int   PDC_CDECL   addchstr(ch)
+chtype *ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("addchstr() - called\n");
+#endif
+
+   return( addchnstr( ch, -1) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   addchnstr(chtype *ch, int n)
+#else
+int   PDC_CDECL   addchnstr(ch,n)
+chtype *ch;
+int n;
+#endif
+/***********************************************************************/
+{
+   int y,x,num,maxx;
+   chtype *ptr;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("addchnstr() - called\n");
+#endif
+
+   if (stdscr == (WINDOW *)NULL)
+      return( ERR );
+
+   if (n == 0
+   ||  n < (-1))
+      return( ERR );
+
+   x = stdscr->_curx;
+   y = stdscr->_cury;
+   ptr = &(stdscr->_y[y][x]);
+
+
+   if (n == (-1))
+   {
+      for (num = stdscr->_maxx - x; *ch && num--; num++)
+      {
+         *ptr++ = *ch++;
+      }
+      maxx = num;
+   }
+   else
+   {
+      num = min(stdscr->_maxx - x,n);
+      memcpy((char *)ptr, (char *)ch, (int)(num * sizeof(chtype)));
+      maxx = x+num-1;
+   }
+
+   if (stdscr->_firstch[y] == _NO_CHANGE)
+   {
+      stdscr->_firstch[y] = x;
+      stdscr->_lastch[y] = maxx;
+   }
+   else
+   {
+      if (x <  stdscr->_firstch[y])
+      {
+         stdscr->_firstch[y] = x;
+      }
+      if (maxx >  stdscr->_lastch[y])
+      {
+         stdscr->_lastch[y] = maxx;
+      }
+   }
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   waddchstr(WINDOW *win, chtype *ch)
+#else
+int   PDC_CDECL   waddchstr(win,ch)
+WINDOW *win;
+chtype *ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("waddchstr() - called: win=%x\n",win);
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+   return( waddchnstr( win, ch, -1) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   waddchnstr(WINDOW *win, chtype *ch, int n)
+#else
+int   PDC_CDECL   waddchnstr(win,ch,n)
+WINDOW *win;
+chtype *ch;
+int n;
+#endif
+/***********************************************************************/
+{
+   register int i,y,x,num,maxx,minx;
+   int first=1;
+   chtype *ptr,*mptr;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("waddchnstr() - called: win=%x n=%d\n",win,n);
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+   if (n == 0
+   ||  n < (-1))
+      return( ERR );
+
+   x = win->_curx;
+   y = win->_cury;
+   ptr = mptr = &(win->_y[y][x]);
+
+#if 0
+   if (n == (-1))
+      {
+      for (num = win->_maxx - x; *ch && num--; num++)
+         *ptr++ = *ch++;
+      maxx = num;
+      }
+   else
+      {
+      num = min(win->_maxx - x,n);
+      maxx = x+num-1;
+      memcpy((char *)ptr, (char *)ch, (int)(num * sizeof(chtype)));
+      }
+
+   if (win->_firstch[y] == _NO_CHANGE)
+      {
+      win->_firstch[y] = x;
+      win->_lastch[y] = maxx;
+      }
+   else
+      {
+      if (x <  win->_firstch[y])
+         {
+         win->_firstch[y] = x;
+         }
+      if (maxx >  win->_lastch[y])
+         {
+         win->_lastch[y] = maxx;
+         }
+      }
+
+#else
+
+   if (n == (-1))
+      num = win->_maxx - x;
+   else
+      num = min(win->_maxx - x,n);
+
+   minx = win->_firstch[y];
+   maxx = win->_lastch[y];
+   for (i=x; num && *ch; num--, i++)
+   {
+      if (i < win->_firstch[y]
+      ||  win->_firstch[y] == _NO_CHANGE)
+      {
+         if (*ptr != *ch && first)
+         {
+            minx = i;
+            first = 0;
+         }
+         }
+         if (i > win->_lastch[y])
+         {
+            if (*ptr != *ch)
+               maxx = i;
+         }
+
+#ifdef PDCDEBUG
+      if (trace_on)
+      {
+         PDC_debug("y %d i %d minx %d maxx %d *ptr %x *ch %x firstch: %d lastch: %d\n",
+                   y,i,minx,maxx,
+                   *ptr,*ch,
+                   win->_firstch[y],win->_lastch[y]
+                   );
+      }
+#endif
+
+      *ptr++ = *ch++;
+   }
+
+   win->_firstch[y] = minx;
+   win->_lastch[y] = maxx;
+#endif
+
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   mvaddchstr(int y, int x, chtype *ch)
+#else
+int   PDC_CDECL   mvaddchstr(y,x,ch)
+int y;
+int x;
+chtype *ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("mvaddchstr() - called: y %d x %d\n",y,x);
+#endif
+
+   if (stdscr == (WINDOW *)NULL)
+      return( ERR );
+
+   if (wmove(stdscr,y,x) == ERR)
+      return( ERR );
+
+   return( addchnstr( ch, -1) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   mvaddchnstr(int y, int x, chtype *ch, int n)
+#else
+int   PDC_CDECL   mvaddchnstr(y,x,ch,n)
+int y;
+int x;
+chtype *ch;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("mvaddchnstr() - called: y %d x %d n %d\n",y,x,n);
+#endif
+
+   if (stdscr == (WINDOW *)NULL)
+      return( ERR );
+
+   if (wmove(stdscr,y,x) == ERR)
+      return( ERR );
+
+   return( addchnstr( ch, n) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   mvwaddchstr(WINDOW *win, int y, int x, chtype *ch)
+#else
+int   PDC_CDECL   mvwaddchstr(win,y,x,ch)
+WINDOW *win;
+int y;
+int x;
+chtype *ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("waddchstr() - called:\n");
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+   if (wmove(win,y,x) == ERR)
+      return( ERR );
+
+   return( waddchnstr( win, ch, -1) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   mvwaddchnstr(WINDOW *win,int y, int x, chtype *ch, int n)
+#else
+int   PDC_CDECL   mvwaddchnstr(win,y,x,ch,n)
+WINDOW *win;
+int y;
+int x;
+chtype *ch;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("mvwaddchnstr() - called: y %d x %d n %d \n",y,x,n);
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+   if (wmove(win,y,x) == ERR)
+      return( ERR );
+
+   return( waddchnstr( win, ch, n) );
+}
Index: PDCurses/curses.h
===================================================================
--- PDCurses/curses.h	(revision 1)
+++ PDCurses/curses.h	(working copy)
@@ -980,7 +980,7 @@
 __declspec(dllimport)	int	COLS;		/* terminal width		*/
 __declspec(dllimport)	WINDOW*	stdscr;		/* the default screen window	*/
 __declspec(dllimport)	WINDOW*	curscr;		/* the current screen image	*/
-__declspec(dllimport)	SCREEN	*SP;	/* curses variables		*/
+__declspec(dllimport)	SCREEN	*PDC_SP;	/* curses variables		*/
 __declspec(dllimport)	int	use_emalloc;	/* set to true to use your own malloc,etc */
 __declspec(dllimport)	MOUSE_STATUS Mouse_status;
 __declspec(dllimport)	int COLORS;
@@ -991,7 +991,7 @@
 __declspec(dllexport) extern	int	COLS;		/* terminal width		*/
 __declspec(dllexport) extern	WINDOW*	stdscr;		/* the default screen window	*/
 __declspec(dllexport) extern	WINDOW*	curscr;		/* the current screen image	*/
-__declspec(dllexport) extern	SCREEN	*SP;	/* curses variables		*/
+__declspec(dllexport) extern	SCREEN	*PDC_SP;	/* curses variables		*/
 __declspec(dllexport) extern	int	use_emalloc;	/* set to true to use your own malloc,etc */
 __declspec(dllexport) extern	MOUSE_STATUS Mouse_status;
 __declspec(dllexport) extern	int COLORS;
@@ -1001,7 +1001,7 @@
 extern	int	COLS;		/* terminal width		*/
 extern	WINDOW*	stdscr;		/* the default screen window	*/
 extern	WINDOW*	curscr;		/* the current screen image	*/
-extern	SCREEN	*SP;	/* curses variables		*/
+extern	SCREEN	*PDC_SP;	/* curses variables		*/
 extern	int	use_emalloc;	/* set to true to use your own malloc,etc */
 extern	MOUSE_STATUS Mouse_status;
 extern	int COLORS,COLOR_PAIRS;
@@ -1990,7 +1990,7 @@
 #define getnstr(str,num)        wgetnstr( stdscr, str, num )
 #define getsyx(y,x)             { if( curscr->_leaveit) (y)=(x)=-1; else getyx(curscr,(y),(x)); }
 #define getyx(w,y,x)            ( y = (w)->_cury, x = (w)->_curx )
-#define has_colors()            ((SP->mono) ? FALSE : TRUE)
+#define has_colors()            ((PDC_SP->mono) ? FALSE : TRUE)
 #define idcok(w,flag)           OK
 #define idlok(w,flag)           OK
 #define inch()                  (stdscr->_y[stdscr->_cury][stdscr->_curx])
@@ -2002,8 +2002,8 @@
 #define insnstr(s,n)            winsnstr(stdscr,s,n)
 #define insstr(s)               winsnstr(stdscr,s,(-1))
 #define instr(str)              winnstr(stdscr,(str),stdscr->_maxx)
-#define isendwin()              ((SP->alive) ? FALSE : TRUE)
-#define is_termresized()        (SP->resized)
+#define isendwin()              ((PDC_SP->alive) ? FALSE : TRUE)
+#define is_termresized()        (PDC_SP->resized)
 #define keypad(w,flag)          (w->_use_keypad  = flag, OK)
 #define leaveok(w,flag)         (w->_leaveit = flag, OK)
 #define move(y,x)               wmove( stdscr, y, x )
@@ -2041,8 +2041,8 @@
 #define mvwinsnstr(w,y,x,s,n)   (wmove( w, y, x )==ERR?ERR:winsnstr(w,s,n))
 #define mvwinsstr(w,y,x,s)      (wmove( w, y, x )==ERR?ERR:winsnstr(w,s,(-1)))
 #define napms(ms)               delay_output(ms)
-#define nl()                    (SP->autocr = TRUE)
-#define nonl()                  (SP->autocr = FALSE)
+#define nl()                    (PDC_SP->autocr = TRUE)
+#define nonl()                  (PDC_SP->autocr = FALSE)
 #define redrawwin(w)            wredrawln((w),0,(w)->_maxy)
 #define refresh()               wrefresh( stdscr )
 #define resetterm()             reset_shell_mode()
@@ -2063,7 +2063,7 @@
 #endif
 #define ungetch(ch)             PDC_ungetch(ch)
 #define untouchwin(w)           wtouchln((w),0,((w)->_maxy),FALSE)
-#define waddch(w, c)            PDC_chadd( w, (chtype)c, (bool)!(SP->raw_out), TRUE )
+#define waddch(w, c)            PDC_chadd( w, (chtype)c, (bool)!(PDC_SP->raw_out), TRUE )
 #define waddchstr(w, c)         (waddchnstr( w, c, -1 ))
 #define werase(w)               (wmove((w),0,0), wclrtobot(w))
 #define wclear(w)               ((w)->_clear = TRUE , werase(w))
@@ -2077,12 +2077,12 @@
 
 #if !defined(UNIX) && !defined(XCURSES)
 /* set delaytenths = 0 added - William McBrine */
-# define nocbreak()             (SP->cbreak = FALSE, SP->delaytenths = 0) 
-# define cbreak()               (SP->cbreak = TRUE)
-# define nocrmode()             (SP->cbreak = FALSE)
-# define crmode()               (SP->cbreak = TRUE)
-# define noecho()               (SP->echo = FALSE,OK)
-# define echo()                 (SP->echo = TRUE,OK)
+# define nocbreak()             (PDC_SP->cbreak = FALSE, PDC_SP->delaytenths = 0) 
+# define cbreak()               (PDC_SP->cbreak = TRUE)
+# define nocrmode()             (PDC_SP->cbreak = FALSE)
+# define crmode()               (PDC_SP->cbreak = TRUE)
+# define noecho()               (PDC_SP->echo = FALSE,OK)
+# define echo()                 (PDC_SP->echo = TRUE,OK)
 # define nodelay(w,flag)        (w->_nodelay = flag)
 #endif
 
@@ -2092,8 +2092,8 @@
 # define insrawch( c )          winsrawch( stdscr, c )
 # define waddrawch(w, c)        PDC_chadd( w, (chtype)c, FALSE, TRUE )
 # define winsrawch(w, c)        PDC_chins( w, (chtype)c, FALSE )
-# define PDC_save_key_modifiers(flag) (SP->save_key_modifiers = flag)
-# define PDC_return_key_modifiers(flag) (SP->return_key_modifiers = flag)
+# define PDC_save_key_modifiers(flag) (PDC_SP->save_key_modifiers = flag)
+# define PDC_return_key_modifiers(flag) (PDC_SP->return_key_modifiers = flag)
 
 /*
  *      FYI: Need to document these functions...
Index: PDCurses/win32/pdcsetsc.c
===================================================================
--- PDCurses/win32/pdcsetsc.c	(revision 1)
+++ PDCurses/win32/pdcsetsc.c	(working copy)
@@ -1,271 +1,271 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#define	INCLUDE_WINDOWS_H
-#include <curses.h>
-
-#ifdef PDCDEBUG
-char *rcsid_PDCsetsc  = "$Id: pdcsetsc.c,v 1.1 2001/01/10 08:30:53 mark Exp $";
-#endif
-
-extern HANDLE hConOut;
-
-/*man-start*********************************************************************
-
-  PDC_set_80x25()	- force a known screen state: 80x25 text mode.
-
-  PDCurses Description:
- 	This is a private PDCurses function.
-
- 	Forces the appropriate 80x25 alpha mode given the display adapter.
-
- 	Since we currently do not support changing the virtual console size,
- 	this routine is a NOP under Flexos.
-
-  PDCurses Return Value:
- 	This function returns OK upon success otherwise ERR is returned.
-
-  PDCurses Errors:
- 	No errors are defined for this routine.
-
-  Portability:
- 	PDCurses	int	PDC_set_80x25( void );
-
-**man-end**********************************************************************/
-
-int	PDC_set_80x25(void)
-{
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_set_80x25() - called\n");
-#endif
-
-	return(OK);
-}
-
-/*man-start*********************************************************************
-
-  PDC_set_cursor_mode()	- Set the cursor start and stop scan lines.
-
-  PDCurses Description:
- 	Sets the cursor type to begin in scan line startrow and end in
- 	scan line endrow.  Both values should be 0-31.
-
-  PDCurses Return Value:
- 	This function returns OK on success and ERR on error.
-
-  PDCurses Errors:
- 	No errors are defined for this function.
-
-  Portability:
- 	PDCurses	int PDC_set_cursor_mode( int startrow, int endrow );
-
-**man-end**********************************************************************/
-
-int	PDC_set_cursor_mode( int startrow, int endrow )
-{
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_set_cursor_mode() - called: startrow %d endrow %d\n",startrow,endrow);
-#endif
-
-	return(OK);
-}
-
-/*man-start*********************************************************************
-
-  PDC_set_font()	- sets the current font size
-
-  PDCurses Description:
- 	This is a private PDCurses function.
-
- 	This routine sets the current font size, if the adapter allows
- 	such a change.
-
-  PDCurses Return Value:
- 	This function returns OK upon success otherwise ERR is returned.
-
-  PDCurses Errors:
- 	It is an error to attempt to change the font size on a "bogus"
- 	adapter.  The reason for this is that we have a known video
- 	adapter identity problem.  e.g. Two adapters report the same
- 	identifying characteristics.
-
- 	It is also an error to attempt to change the size of the Flexos
- 	console (as there is currently no support for that).
-
-  Portability:
- 	PDCurses	int	PDC_set_font( int size );
-
-**man-end**********************************************************************/
-
-int	PDC_set_font(int size)
-{
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_set_font() - called\n");
-#endif
-
-	return(OK);
-}
-
-/*man-start*********************************************************************
-
-  PDC_set_rows()	- sets the physical number of rows on screen
-
-  PDCurses Description:
- 	This is a private PDCurses function.
-
- 	This routine attempts to set the number of rows on the physical
- 	screen to the passed value.
-
-  PDCurses Return Value:
- 	This function returns OK upon success otherwise ERR is returned.
-
-  PDCurses Errors:
- 	It is an error to attempt to change the screen size on a "bogus"
- 	adapter.  The reason for this is that we have a known video
- 	adapter identity problem.  e.g. Two adapters report the same
- 	identifying characteristics.
-
- 	It is also an error to attempt to change the size of the Flexos
- 	console (as there is currently no support for that).
-
-  Portability:
- 	PDCurses	int	PDC_set_rows( int rows );
-
-**man-end**********************************************************************/
-
-int	PDC_set_rows(int rows)
-{
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_set_rows() - called\n");
-#endif
-
-	return(0);
-}
-
-/*man-start*********************************************************************
-
-  PDC_set_scrn_mode()	- Set BIOS Video Mode
-
-  PDCurses Description:
- 	Sets the BIOS Video Mode Number ONLY if it is different from
- 	the current video mode.  This routine is for DOS systems only.
-
-  PDCurses Return Value:
- 	This function returns OK on success and ERR on error.
-
-  PDCurses Errors:
- 	No errors are defined for this function.
-
-  Portability:
- 	PDCurses	int PDC_set_scrn_mode( int new_mode );
-
-**man-end**********************************************************************/
-
-int	PDC_set_scrn_mode(int new_mode)
-{
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_set_scrn_mode() - called\n");
-#endif
-
-	return(OK); /* this is N/A */
-}
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int	PDC_curs_set(int visibility)
-#else
-int	PDC_curs_set(visibility)
-int visibility;
-#endif
-/***********************************************************************/
-{
- CONSOLE_CURSOR_INFO cci;
- int ret_vis=0;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_curs_set() - called: visibility=%d\n",visibility);
-#endif
-
-	ret_vis = SP->visibility;
-
-	if (GetConsoleCursorInfo(hConOut,&cci) == FALSE)
-		return ERR;
-
-	switch(visibility)
-	{
-		case 0:                 /* invisible */
-			cci.bVisible = FALSE;
-			cci.dwSize = 1;
-			break;
-		case 2:                 /* highly visible */
-			cci.bVisible = TRUE;
-			cci.dwSize = 95;
-			break;
-		default:                /* normal visibility */
-			cci.bVisible = TRUE;
-			cci.dwSize = 25;
-			break;
-	}
-
-	if (SetConsoleCursorInfo(hConOut,&cci) == FALSE)
-		return ERR;
-
-	SP->visibility = visibility;
-	return(ret_vis);
-}
-
-/*man-start*********************************************************************
-
-  PDC_set_title()	- Set window title
-
-  PDCurses Description:
- 	Sets the title of the window in which the curses program is running.
- 	This function may not do anything on some platforms.
-
-  PDCurses Return Value:
- 	N/A
-
-  PDCurses Errors:
- 	No errors are defined for this function.
-
-  Portability:
- 	PDCurses	void PDC_set_title( char *title );
-
-**man-end**********************************************************************/
-/***********************************************************************/
-#ifdef HAVE_PROTO
-void	PDC_set_title(char *title)
-#else
-void	PDC_set_title(title)
-char *title;
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_set_title() - called:<%s>\n",title);
-#endif
-
-	SetConsoleTitle(title);
-	return;
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#define	INCLUDE_WINDOWS_H
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCsetsc  = "$Id: pdcsetsc.c,v 1.1 2001/01/10 08:30:53 mark Exp $";
+#endif
+
+extern HANDLE hConOut;
+
+/*man-start*********************************************************************
+
+  PDC_set_80x25()	- force a known screen state: 80x25 text mode.
+
+  PDCurses Description:
+ 	This is a private PDCurses function.
+
+ 	Forces the appropriate 80x25 alpha mode given the display adapter.
+
+ 	Since we currently do not support changing the virtual console size,
+ 	this routine is a NOP under Flexos.
+
+  PDCurses Return Value:
+ 	This function returns OK upon success otherwise ERR is returned.
+
+  PDCurses Errors:
+ 	No errors are defined for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_set_80x25( void );
+
+**man-end**********************************************************************/
+
+int	PDC_set_80x25(void)
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_80x25() - called\n");
+#endif
+
+	return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_cursor_mode()	- Set the cursor start and stop scan lines.
+
+  PDCurses Description:
+ 	Sets the cursor type to begin in scan line startrow and end in
+ 	scan line endrow.  Both values should be 0-31.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_set_cursor_mode( int startrow, int endrow );
+
+**man-end**********************************************************************/
+
+int	PDC_set_cursor_mode( int startrow, int endrow )
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_cursor_mode() - called: startrow %d endrow %d\n",startrow,endrow);
+#endif
+
+	return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_font()	- sets the current font size
+
+  PDCurses Description:
+ 	This is a private PDCurses function.
+
+ 	This routine sets the current font size, if the adapter allows
+ 	such a change.
+
+  PDCurses Return Value:
+ 	This function returns OK upon success otherwise ERR is returned.
+
+  PDCurses Errors:
+ 	It is an error to attempt to change the font size on a "bogus"
+ 	adapter.  The reason for this is that we have a known video
+ 	adapter identity problem.  e.g. Two adapters report the same
+ 	identifying characteristics.
+
+ 	It is also an error to attempt to change the size of the Flexos
+ 	console (as there is currently no support for that).
+
+  Portability:
+ 	PDCurses	int	PDC_set_font( int size );
+
+**man-end**********************************************************************/
+
+int	PDC_set_font(int size)
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_font() - called\n");
+#endif
+
+	return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_rows()	- sets the physical number of rows on screen
+
+  PDCurses Description:
+ 	This is a private PDCurses function.
+
+ 	This routine attempts to set the number of rows on the physical
+ 	screen to the passed value.
+
+  PDCurses Return Value:
+ 	This function returns OK upon success otherwise ERR is returned.
+
+  PDCurses Errors:
+ 	It is an error to attempt to change the screen size on a "bogus"
+ 	adapter.  The reason for this is that we have a known video
+ 	adapter identity problem.  e.g. Two adapters report the same
+ 	identifying characteristics.
+
+ 	It is also an error to attempt to change the size of the Flexos
+ 	console (as there is currently no support for that).
+
+  Portability:
+ 	PDCurses	int	PDC_set_rows( int rows );
+
+**man-end**********************************************************************/
+
+int	PDC_set_rows(int rows)
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_rows() - called\n");
+#endif
+
+	return(0);
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_scrn_mode()	- Set BIOS Video Mode
+
+  PDCurses Description:
+ 	Sets the BIOS Video Mode Number ONLY if it is different from
+ 	the current video mode.  This routine is for DOS systems only.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_set_scrn_mode( int new_mode );
+
+**man-end**********************************************************************/
+
+int	PDC_set_scrn_mode(int new_mode)
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_scrn_mode() - called\n");
+#endif
+
+	return(OK); /* this is N/A */
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_curs_set(int visibility)
+#else
+int	PDC_curs_set(visibility)
+int visibility;
+#endif
+/***********************************************************************/
+{
+ CONSOLE_CURSOR_INFO cci;
+ int ret_vis=0;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_curs_set() - called: visibility=%d\n",visibility);
+#endif
+
+	ret_vis = PDC_SP->visibility;
+
+	if (GetConsoleCursorInfo(hConOut,&cci) == FALSE)
+		return ERR;
+
+	switch(visibility)
+	{
+		case 0:                 /* invisible */
+			cci.bVisible = FALSE;
+			cci.dwSize = 1;
+			break;
+		case 2:                 /* highly visible */
+			cci.bVisible = TRUE;
+			cci.dwSize = 95;
+			break;
+		default:                /* normal visibility */
+			cci.bVisible = TRUE;
+			cci.dwSize = 25;
+			break;
+	}
+
+	if (SetConsoleCursorInfo(hConOut,&cci) == FALSE)
+		return ERR;
+
+	PDC_SP->visibility = visibility;
+	return(ret_vis);
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_title()	- Set window title
+
+  PDCurses Description:
+ 	Sets the title of the window in which the curses program is running.
+ 	This function may not do anything on some platforms.
+
+  PDCurses Return Value:
+ 	N/A
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	void PDC_set_title( char *title );
+
+**man-end**********************************************************************/
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_set_title(char *title)
+#else
+void	PDC_set_title(title)
+char *title;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_title() - called:<%s>\n",title);
+#endif
+
+	SetConsoleTitle(title);
+	return;
+}
Index: PDCurses/win32/pdcclip.c
===================================================================
--- PDCurses/win32/pdcclip.c	(revision 1)
+++ PDCurses/win32/pdcclip.c	(working copy)
@@ -1,200 +1,200 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	INCLUDE_WINDOWS_H
-#define	CURSES_LIBRARY	1
-#include <curses.h>
-
-#ifdef PDCDEBUG
-char *rcsid_PDCclip  = "$Id: pdcclip.c,v 1.3 2002/11/27 11:17:49 mark Exp $";
-#endif
-
-
-/*man-start*********************************************************************
-
-  PDC_getclipboard()	- Gets the contents of the clipboard
-
-  PDCurses Description:
- 	This is a PDCurses only routine.
-
- 	Gets the textual contents of the system's clipboard. This
- 	function returns the contents of the clipboard in the contents
- 	argument. It is the responsibilitiy of the caller to free the
- 	memory returned with the PDC_freeclipboard() call.  The length of the
- 	clipboard contents is returned in the length argument.
-
-  PDCurses Return Value:
- 	indicator of success/failure of call.
- 	PDC_CLIP_SUCCESS	the call was successful
- 	PDC_CLIP_ACCESS_ERROR	an error occured while accessing the
- 		clipboard
- 	PDC_CLIP_MEMORY_ERROR	unable to allocate sufficient memory for 
- 		the clipboard contents
- 	PDC_CLIP_EMPTY	the clipboard contains no text
-
-  Portability:
- 	PDCurses	int PDC_getclipboard( char **contents, long *length );
-
-**man-end**********************************************************************/
-
-int	PDC_CDECL	PDC_getclipboard(char **contents, long *length)
-{
- HANDLE handle;
- long len=0;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_getclipboard() - called\n");
-#endif
-
- if (OpenClipboard(NULL) == 0)
- {
-    return PDC_CLIP_ACCESS_ERROR;
- }
- handle = GetClipboardData( CF_TEXT );
- if (handle == NULL)
- {
-    CloseClipboard();
-    return PDC_CLIP_EMPTY;
- }
-
- len = strlen((char *)handle);
- *contents = (char *)GlobalAlloc(GMEM_FIXED,len+1);
- if (!*contents)
- {
-    CloseClipboard();
-    return PDC_CLIP_MEMORY_ERROR;
- }
- strcpy((char *)*contents,(char *)handle);
- *length = len;
- CloseClipboard();
-
-	return( PDC_CLIP_SUCCESS );
-}
-
-
-/*man-start*********************************************************************
-
-  PDC_setclipboard()	- Sets the contents of the clipboard
-
-  PDCurses Description:
- 	This is a PDCurses only routine.
-
- 	Copies the supplied text into the system's clipboard, emptying
- 	the clipboard prior to the copy.
-
-  PDCurses Return Value:
- 	indicator of success/failure of call.
- 	PDC_CLIP_SUCCESS	the call was successful
- 	PDC_CLIP_ACCESS_ERROR	an error occured while accessing the
- 		clipboard
-
-  Portability:
- 	PDCurses	int PDC_getclipboard( char *contents, long length );
-
-**man-end**********************************************************************/
-
-int	PDC_CDECL	PDC_setclipboard(char *contents, long length)
-{
- HGLOBAL ptr1;
- LPTSTR ptr2;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_setclipboard() - called\n");
-#endif
-
-
- if (OpenClipboard(NULL) == 0)
- {
-    return PDC_CLIP_ACCESS_ERROR;
- }
- ptr1 = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE, (length+1)*sizeof(TCHAR) );
- if (!ptr1)
- {
-    return PDC_CLIP_MEMORY_ERROR;
- }
-
- ptr2 = GlobalLock(ptr1);
- memcpy((char *)ptr2, (char *)contents, length+1 );
- GlobalUnlock(ptr1);
- EmptyClipboard();
- if (SetClipboardData(CF_TEXT, ptr1) == NULL)
- {
-    GlobalFree(ptr1);
-    return PDC_CLIP_ACCESS_ERROR;
- }
- CloseClipboard();
- GlobalFree(ptr1);
- return PDC_CLIP_SUCCESS;
-}
-
-/*man-start*********************************************************************
-
-  PDC_freeclipboard()	- Frees the memory associated with the contents of the clipboard
-
-  PDCurses Description:
- 	This is a PDCurses only routine.
-
- 	Frees the memory allocated by PDC_getclipboard().
-
-  PDCurses Return Value:
- 	Always returns PDC_CLIP_SUCCESS
-
-  Portability:
- 	PDCurses	int PDC_freeclipboard( char *contents );
-
-**man-end**********************************************************************/
-
-int	PDC_CDECL	PDC_freeclipboard(char *contents)
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_freeclipboard() - called\n");
-#endif
-
- GlobalFree(contents);
- return PDC_CLIP_SUCCESS;
-}
-
-/*man-start*********************************************************************
-
-  PDC_clearclipboard()	- Clears the contents of the clipboard
-
-  PDCurses Description:
- 	This is a PDCurses only routine.
-
- 	Clears the internal clipboard.
-
-  PDCurses Return Value:
- 	Always returns PDC_CLIP_SUCCESS
-
-  Portability:
- 	PDCurses	int PDC_clearclipboard( void );
-
-**man-end**********************************************************************/
-
-int	PDC_CDECL	PDC_clearclipboard( void )
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_clearclipboard() - called\n");
-#endif
-
- EmptyClipboard();
-
- return PDC_CLIP_SUCCESS;
-}
-
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	INCLUDE_WINDOWS_H
+#define	CURSES_LIBRARY	1
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCclip  = "$Id: pdcclip.c,v 1.3 2002/11/27 11:17:49 mark Exp $";
+#endif
+
+
+/*man-start*********************************************************************
+
+  PDC_getclipboard()	- Gets the contents of the clipboard
+
+  PDCurses Description:
+ 	This is a PDCurses only routine.
+
+ 	Gets the textual contents of the system's clipboard. This
+ 	function returns the contents of the clipboard in the contents
+ 	argument. It is the responsibilitiy of the caller to free the
+ 	memory returned with the PDC_freeclipboard() call.  The length of the
+ 	clipboard contents is returned in the length argument.
+
+  PDCurses Return Value:
+ 	indicator of success/failure of call.
+ 	PDC_CLIP_SUCCESS	the call was successful
+ 	PDC_CLIP_ACCESS_ERROR	an error occured while accessing the
+ 		clipboard
+ 	PDC_CLIP_MEMORY_ERROR	unable to allocate sufficient memory for 
+ 		the clipboard contents
+ 	PDC_CLIP_EMPTY	the clipboard contains no text
+
+  Portability:
+ 	PDCurses	int PDC_getclipboard( char **contents, long *length );
+
+**man-end**********************************************************************/
+
+int	PDC_CDECL	PDC_getclipboard(char **contents, long *length)
+{
+ HANDLE handle;
+ long len=0;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_getclipboard() - called\n");
+#endif
+
+ if (OpenClipboard(NULL) == 0)
+ {
+    return PDC_CLIP_ACCESS_ERROR;
+ }
+ handle = GetClipboardData( CF_TEXT );
+ if (handle == NULL)
+ {
+    CloseClipboard();
+    return PDC_CLIP_EMPTY;
+ }
+
+ len = strlen((char *)handle);
+ *contents = (char *)GlobalAlloc(GMEM_FIXED,len+1);
+ if (!*contents)
+ {
+    CloseClipboard();
+    return PDC_CLIP_MEMORY_ERROR;
+ }
+ strcpy((char *)*contents,(char *)handle);
+ *length = len;
+ CloseClipboard();
+
+	return( PDC_CLIP_SUCCESS );
+}
+
+
+/*man-start*********************************************************************
+
+  PDC_setclipboard()	- Sets the contents of the clipboard
+
+  PDCurses Description:
+ 	This is a PDCurses only routine.
+
+ 	Copies the supplied text into the system's clipboard, emptying
+ 	the clipboard prior to the copy.
+
+  PDCurses Return Value:
+ 	indicator of success/failure of call.
+ 	PDC_CLIP_SUCCESS	the call was successful
+ 	PDC_CLIP_ACCESS_ERROR	an error occured while accessing the
+ 		clipboard
+
+  Portability:
+ 	PDCurses	int PDC_getclipboard( char *contents, long length );
+
+**man-end**********************************************************************/
+
+int	PDC_CDECL	PDC_setclipboard(char *contents, long length)
+{
+ HGLOBAL ptr1;
+ LPTSTR ptr2;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_setclipboard() - called\n");
+#endif
+
+
+ if (OpenClipboard(NULL) == 0)
+ {
+    return PDC_CLIP_ACCESS_ERROR;
+ }
+ ptr1 = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE, (length+1)*sizeof(TCHAR) );
+ if (!ptr1)
+ {
+    return PDC_CLIP_MEMORY_ERROR;
+ }
+
+ ptr2 = GlobalLock(ptr1);
+ memcpy((char *)ptr2, (char *)contents, length+1 );
+ GlobalUnlock(ptr1);
+ EmptyClipboard();
+ if (SetClipboardData(CF_TEXT, ptr1) == NULL)
+ {
+    GlobalFree(ptr1);
+    return PDC_CLIP_ACCESS_ERROR;
+ }
+ CloseClipboard();
+ GlobalFree(ptr1);
+ return PDC_CLIP_SUCCESS;
+}
+
+/*man-start*********************************************************************
+
+  PDC_freeclipboard()	- Frees the memory associated with the contents of the clipboard
+
+  PDCurses Description:
+ 	This is a PDCurses only routine.
+
+ 	Frees the memory allocated by PDC_getclipboard().
+
+  PDCurses Return Value:
+ 	Always returns PDC_CLIP_SUCCESS
+
+  Portability:
+ 	PDCurses	int PDC_freeclipboard( char *contents );
+
+**man-end**********************************************************************/
+
+int	PDC_CDECL	PDC_freeclipboard(char *contents)
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_freeclipboard() - called\n");
+#endif
+
+ GlobalFree(contents);
+ return PDC_CLIP_SUCCESS;
+}
+
+/*man-start*********************************************************************
+
+  PDC_clearclipboard()	- Clears the contents of the clipboard
+
+  PDCurses Description:
+ 	This is a PDCurses only routine.
+
+ 	Clears the internal clipboard.
+
+  PDCurses Return Value:
+ 	Always returns PDC_CLIP_SUCCESS
+
+  Portability:
+ 	PDCurses	int PDC_clearclipboard( void );
+
+**man-end**********************************************************************/
+
+int	PDC_CDECL	PDC_clearclipboard( void )
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_clearclipboard() - called\n");
+#endif
+
+ EmptyClipboard();
+
+ return PDC_CLIP_SUCCESS;
+}
+
Index: PDCurses/win32/pdcprint.c
===================================================================
--- PDCurses/win32/pdcprint.c	(revision 1)
+++ PDCurses/win32/pdcprint.c	(working copy)
@@ -1,60 +1,60 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#include <curses.h>
-
-#ifdef PDCDEBUG
-char *rcsid_PDCprint  = "$Id: pdcprint.c,v 1.1 2001/01/10 08:30:50 mark Exp $";
-#endif
-
-
-/*man-start*********************************************************************
-
-  PDC_print()	- Provides primitive access to the BIOS printer functions
-
-  PDCurses Description:
- 	This is a private PDCurses routine.
-
- 	Implements write/init/read printer services at the BIOS level.
-
- 	This provides the basic support that PDCurses needs to dump the
- 	contents of windows or pads to the printer attached to the BIOS
- 	printer port.
-
-  PDCurses Return Value:
- 	See the BIOS INT 0x17 specifications.
-
-  PDCurses Errors:
- 	See the BIOS INT 0x17 specifications.
-
-  Portability:
- 	PDCurses	int PDC_print( int cmd, int byte, int port );
-
-**man-end**********************************************************************/
-
-int	PDC_print(int cmd, int byte, int port)
-{
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_print() - called\n");
-#endif
-
-	return( OK );
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCprint  = "$Id: pdcprint.c,v 1.1 2001/01/10 08:30:50 mark Exp $";
+#endif
+
+
+/*man-start*********************************************************************
+
+  PDC_print()	- Provides primitive access to the BIOS printer functions
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Implements write/init/read printer services at the BIOS level.
+
+ 	This provides the basic support that PDCurses needs to dump the
+ 	contents of windows or pads to the printer attached to the BIOS
+ 	printer port.
+
+  PDCurses Return Value:
+ 	See the BIOS INT 0x17 specifications.
+
+  PDCurses Errors:
+ 	See the BIOS INT 0x17 specifications.
+
+  Portability:
+ 	PDCurses	int PDC_print( int cmd, int byte, int port );
+
+**man-end**********************************************************************/
+
+int	PDC_print(int cmd, int byte, int port)
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_print() - called\n");
+#endif
+
+	return( OK );
+}
Index: PDCurses/win32/pdcdisp.c
===================================================================
--- PDCurses/win32/pdcdisp.c	(revision 1)
+++ PDCurses/win32/pdcdisp.c	(working copy)
@@ -1,584 +1,584 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#include <string.h>
-#define  CURSES_LIBRARY 1
-#define  INCLUDE_WINDOWS_H
-#include <curses.h>
-
-#ifdef HAVE_MEMORY_H
-# include <memory.h>
-#endif
-
-extern HANDLE hConOut;
-
-#ifdef PDCDEBUG
-char *rcsid_PDCdisp  = "$Id: pdcdisp.c,v 1.1 2001/01/10 08:30:47 mark Exp $";
-#endif
-
-static CHAR_INFO ci[512];
-/*man-start*********************************************************************
-
-  PDC_clr_update()   - Updates the screen with a full redraw.
-
-  PDCurses Description:
-   Updates the screen by clearing it and then redraw it in its
-   entirety. If SP->refrbrk is TRUE, and there is pending
-   input characters, the update will be prematurely terminated.
-
-  PDCurses Return Value:
-   This routine returns ERR if it is unable to accomplish it's task.
-   This return value is ONLY under FLEXOS.
-
-   The return value OK is returned if there were no errors.
-
-  PDCurses Errors:
-   No errors are defined for this function.
-
-  Portability:
-   PDCurses int PDC_clr_update( WINDOW* s );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-int   PDC_clr_update(WINDOW *s)
-/***********************************************************************/
-{
-   extern unsigned char atrtab[MAX_ATRTAB];
-
-   register int   i=0,j=0;
-   register chtype *srcp;
-   WINDOW *w = NULL;
-   bool rc=FALSE;
-   COORD bufSize, bufPos;
-   SMALL_RECT sr;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_clr_update() - called\n");
-#endif
-
-   w = curscr;
-   if (w == (WINDOW *)NULL)
-      return( ERR );
-#if 0
-   if (SP->full_redraw)
-      PDC_clr_scrn(s); /* clear physical screen */
-#endif
-
-   s->_clear = FALSE;
-   bufPos.X = bufPos.Y = 0;
-   bufSize.X = COLS;
-   bufSize.Y = 1;
-   sr.Left = 0;
-   sr.Right = COLS - 1;
-   for (i = 0; i < LINES; i++)   /* update physical screen */
-   {
-      if (s != w)
-         memcpy(w->_y[i], s->_y[i], COLS * sizeof(chtype));
-
-      srcp = s->_y[i];
-
-      sr.Top = i;
-      sr.Bottom = i;
-
-      for (j = 0; j < COLS; j++)
-      {
-         ci[j].Char.AsciiChar = *(srcp+j) & A_CHARTEXT;
-         ci[j].Attributes = (chtype_attr(*(srcp+j)) & 0xFF00) >> 8 ;
-#ifdef HIDE_ATTR
-         ci[j].Attributes =  FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
-#endif
-      }
-      WriteConsoleOutput(hConOut, ci, bufSize, bufPos, &sr);
-
-      if (SP->refrbrk && (SP->cbreak || SP->raw_inp)) 
-      {
-         rc = PDC_breakout();
-         if (rc)
-            break;
-      }
-   }
-   return( OK );
-}
-
-/*man-start*********************************************************************
-
-  PDC_cursor_on() - Turns on the hardware cursor.
-
-  PDCurses Description:
-   Turns on the hardware curses, it does nothing if it is already on.
-
-  PDCurses Return Value:
-   Returns OK upon success, ERR upon failure.
-
-  Portability:
-   PDCurses int PDC_cursor_on( void );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-int   PDC_cursor_on(void)
-/***********************************************************************/
-{
-CONSOLE_CURSOR_INFO cci;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_cursor_on() - called\n");
-#endif
-
-   if (!SP->visible_cursor)
-   {
-      SP->visible_cursor = TRUE;
-      GetConsoleCursorInfo(hConOut,&cci);
-      cci.bVisible = TRUE;
-      SetConsoleCursorInfo(hConOut,&cci);
-   }
-   return( OK );
-}
-
-/*man-start*********************************************************************
-
-  PDC_cursor_off()   - Turns off the hardware cursor.
-
-  PDCurses Description:
-   Turns off the hardware curses, it does nothing if it is already off.
-
-  PDCurses Return Value:
-   Returns OK upon success, ERR upon failure.
-
-  PDCurses Errors:
-   ERR will be returned (in the case of FLEXOS) if the hardware cursor
-   can not be disabled.
-
-  Portability:
-   PDCurses int PDC_cursor_off( void );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-int   PDC_cursor_off(void)
-/***********************************************************************/
-{
-CONSOLE_CURSOR_INFO cci;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_cursor_off() - called\n");
-#endif
-   
-   if (SP->visible_cursor)
-   {
-      SP->visible_cursor = FALSE;
-      GetConsoleCursorInfo(hConOut,&cci);
-      cci.bVisible = FALSE;
-      SetConsoleCursorInfo(hConOut,&cci);
-   }
-
-   return( OK );
-}
-
-/*man-start*********************************************************************
-
-  PDC_fix_cursor()   - Fix the cursor start and stop scan lines (if necessary)
-
-  PDCurses Description:
-   This is a private PDCurses routine.
-
-   This routine will fix the cursor shape for certain video adapters.
-   Normally, the values used are correct, but some adapters choke.
-   The most noticable choke is on a monochrome adapter.  The "correct"
-   scan lines will result in the cursor being set in the middle of the
-   character cell, rather than at the bottom.
-
-   The passed flag indicates whether the cursor is visible or not.
-
-   This only applies to the DOS platform.
-
-  PDCurses Return Value:
-   This function returns OK on success and ERR on error.
-
-  PDCurses Errors:
-   No errors are defined for this function.
-
-  Portability:
-   PDCurses int PDC_fix_cursor( int flag );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-int   PDC_fix_cursor(int flag)
-/***********************************************************************/
-{
-   return(OK);
-}
-
-/*man-start*********************************************************************
-
-  PDC_gotoxy() - position hardware cursor at (x, y)
-
-  PDCurses Description:
-   This is a private PDCurses routine.
-
-   Moves the physical cursor to the desired address on the
-   screen. We don't optimize here -- on a PC, it takes more time
-   to optimize than to do things directly.
-
-  PDCurses Return Value:
-   This function returns OK on success and ERR on error.
-
-  PDCurses Errors:
-   No errors are defined for this function.
-
-  Portability:
-   PDCurses int PDC_gotoxy( int row, int col );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-int   PDC_gotoxy(int row, int col)
-/***********************************************************************/
-{
-   COORD coord;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_gotoxy() - called: row %d col %d\n",row,col);
-#endif
-
-   if ((SP->cursrow == row) && (SP->curscol == col))
-   return( OK );
-
-   coord.X = col;
-   coord.Y = row;
-
-   SetConsoleCursorPosition(hConOut, coord);
-   return(OK);
-}
-
-/*man-start*********************************************************************
-
-  PDC_putc()   - Output a character in the current attribute.
-
-  PDCurses Description:
-   This is a private PDCurses routine.
-
-   Outputs character 'chr' to screen in tty fashion. If a colour
-   mode is active, the character is written with colour 'colour'.
-
-  PDCurses Return Value:
-   This function returns OK on success and ERR on error.
-
-  PDCurses Errors:
-   No errors are defined for this function.
-
-  Portability:
-   PDCurses int PDC_putc( chtype character, chtype color );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-int   PDC_putc( chtype character, chtype color )
-/***********************************************************************/
-{
-   int curRow, curCol;
-   WORD buffer[2];
-   COORD coord;
-   DWORD written;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_putc() - called:char=%c attrib=0x%x color=0x%x\n",character & A_CHARTEXT,character & A_ATTRIBUTES,color);
-#endif
-
-   buffer[0] = color;
-   PDC_get_cursor_pos (&curRow, &curCol);
-
-   coord.X = curCol;
-   coord.Y = curRow;
-//   WriteConsoleOutputAttribute(hConOut, &buffer, 1, coord, &written);
-
-   buffer[0] = character;
-   WriteConsoleOutputCharacter(hConOut, (char*)&buffer[0], 1, coord, &written);
-       
-   return (OK);
-}
-
-/*man-start*********************************************************************
-
-  PDC_putctty()   - Output a character and attribute in TTY fashion.
-
-  PDCurses Description:
-   This is a private PDCurses routine.
-
-   Outputs character 'chr' to screen in tty fashion. If a colour
-   mode is active, the character is written with colour 'colour'.
-
-   This function moves the physical cursor after writing so the
-   screen will scroll if necessary.
-
-  PDCurses Return Value:
-   This function returns OK on success and ERR on error.
-
-  PDCurses Errors:
-   No errors are defined for this function.
-
-  Portability:
-   PDCurses int PDC_putctty( chtype character, chtype color );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-int   PDC_putctty( chtype character, chtype color )
-/***********************************************************************/
-{
-   int curRow=0, curCol=0;
-   WORD buffer;
-   COORD coord;
-   DWORD written;
-
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_putctty() - called\n");
-#endif
-
-   buffer = color; 
-   PDC_get_cursor_pos (&curRow, &curCol);
-   coord.X = curCol;
-   coord.Y = curRow;
-//   WriteConsoleOutputAttribute(hConOut, &buffer, 1, coord, &written);
-       
-   buffer = character; 
-   WriteConsoleOutputCharacter(hConOut, (char*)&buffer, 1, coord, &written);
-       
-   return (OK);
-}
-
-/*man-start*********************************************************************
-
-  PDC_scroll() - low level screen scroll
-
-  PDCurses Description:
-   Scrolls a window in the current page up or down. Urow, lcol,
-   lrow, rcol are the window coordinates. Lines is the number of
-   lines to scroll. If 0, clears the window, if < 0 scrolls down,
-   if > 0 scrolls up.  Blanks areas that are left, and sets
-   character attributes to attr. If in a colour graphics mode,
-   fills them with the colour 'attr' instead.
-
-  PDCurses Return Value:
-   The PDC_scroll() function returns OK on success otherwise ERR is returned.
-
-  PDCurses Errors:
-   An error will only be returned on the Flexos platform if s_copy()
-   fails.
-
-  Portability:
-   PDCurses int PDC_scroll( int urow, int lcol, int rcol,
-                 int nlines, chtype attr );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-int   PDC_scroll(int urow, int lcol, int lrow, int rcol, int nlines, chtype attr)
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_scroll() - called: urow %d lcol %d lrow %d rcol %d nlines %d\n",urow,lcol,lrow,rcol,nlines);
-#endif
-
-   return( OK );
-}
-
-/*man-start*********************************************************************
-
-  PDC_transform_line()  - display a physical line of the screen
-
-  PDCurses Description:
-   This is a private PDCurses function.
-
-   Updates the given physical line to look like the corresponding
-   line in _curscr.
-
-  PDCurses Return Value:
-   This routine returns TRUE if a premature refresh end
-   is allowed, and there is an input character pending.  Otherwise,
-   FALSE is returned.
-
-  PDCurses Errors:
-   No errors are defined for this routine.
-
-  Portability:
-   PDCurses bool  PDC_transform_line( int lineno );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-bool  PDC_transform_line(register int lineno)
-/***********************************************************************/
-{
-   extern unsigned   char atrtab[MAX_ATRTAB];
-
-   register int j=0;
-   register chtype *srcp;
-   int   x=0;
-   int   endx=0;
-   int   len=0;
-   bool rc=FALSE;
-   COORD bufSize, bufPos;
-   SMALL_RECT sr;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_transform_line() - called: lineno=%d\n",lineno);
-#endif
-
-   if (curscr == (WINDOW *)NULL)
-      return( FALSE );
-
-   x = curscr->_firstch[lineno];
-   endx = curscr->_lastch[lineno];
-   srcp = curscr->_y[lineno] + x;
-   len = endx-x+1;
-
-   bufPos.X = bufPos.Y = 0;
-
-   bufSize.X = len;
-   bufSize.Y = 1;
-
-   sr.Top = lineno;
-   sr.Bottom = lineno;
-   sr.Left = x;
-   sr.Right = endx;
-
-   for (j = 0; j < len; j++)
-   {
-      ci[j].Char.AsciiChar = *(srcp+j) & A_CHARTEXT;
-      ci[j].Attributes = (chtype_attr(*(srcp+j)) & 0xFF00) >> 8 ;
-#ifdef HIDE_ATTR
-      ci[j].Attributes =  FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
-#endif
-   }
-
-   WriteConsoleOutput(hConOut, ci, bufSize, bufPos, &sr);
-
-   curscr->_firstch[lineno] = _NO_CHANGE;
-   curscr->_lastch[lineno] = _NO_CHANGE;
-   
-   if (SP->refrbrk && (SP->cbreak || SP->raw_inp)) 
-   {
-      rc = PDC_breakout();
-      if (rc)
-         return(TRUE);
-   }
-   return(FALSE);
-}
-
-/*man-start*********************************************************************
-
-  PDC_doupdate()  - display updated data in one call (Win32 only)
-
-  PDCurses Description:
-   This is a private PDCurses function.
-
-   Updates the given physical screen to look like _curscr.
-
-  PDCurses Return Value:
-   This routine returns nothing.
-
-  PDCurses Errors:
-   No errors are defined for this routine.
-
-  Portability:
-   PDCurses void  PDC_doupdate( void );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-void PDC_doupdate(void)
-/***********************************************************************/
-{
-   extern unsigned   char atrtab[MAX_ATRTAB];
-
-   register int i=0,j=0,k=0;
-   int   starty=_NO_CHANGE,startx=_NO_CHANGE;
-   int size=0;
-   int   endy=_NO_CHANGE,endx=_NO_CHANGE;
-   register chtype *srcp;
-   CHAR_INFO *ptr=NULL;
-   COORD bufSize, bufPos;
-   SMALL_RECT sr;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_doupdate() - called:\n");
-#endif
-
-   if (curscr == (WINDOW *)NULL)
-      return;
-
-   for (i = 0; i < LINES; i++ )
-   {
-      if (curscr->_firstch[i] != _NO_CHANGE)
-      {
-         if (starty == _NO_CHANGE)
-            starty = i;
-         endy = i;
-         if (startx == _NO_CHANGE
-         &&  curscr->_firstch[i] != _NO_CHANGE)
-            startx = curscr->_firstch[i];
-         if (curscr->_firstch[i] < startx)
-            startx = curscr->_firstch[i];
-         if (curscr->_lastch[i] > endx)
-            endx = curscr->_lastch[i];
-      }
-   }
-   if (starty == _NO_CHANGE) /* nothing to do... */
-      return;
-
-   size = ((endy - starty) + 1) * ((endx - startx) + 1);
-   ptr = (CHAR_INFO*)malloc(size*sizeof(CHAR_INFO));
-   if (ptr == NULL)
-      return;
-
-   bufPos.X = bufPos.Y = 0;
-   bufSize.X = endx - startx + 1;
-   bufSize.Y = endy - starty + 1;
-
-   sr.Top = starty;
-   sr.Bottom = endy;
-   sr.Left = startx;
-   sr.Right = endx;
-
-   k = 0;
-   for (i = starty; i <= endy; i++ )
-   {
-      srcp = curscr->_y[i];
-      for (j = startx; j <= endx; j++)
-      {
-         ptr[k].Char.AsciiChar = *(srcp+j) & A_CHARTEXT;
-         ptr[k].Attributes = (chtype_attr(*(srcp+j)) & 0xFF00) >> 8 ;
-#ifdef HIDE_ATTR
-         ptr[k].Attributes =  FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
-#endif
-         k++;
-      }
-      curscr->_firstch[i] = _NO_CHANGE;
-      curscr->_lastch[i] = _NO_CHANGE;
-   }
-
-   WriteConsoleOutput(hConOut, ptr, bufSize, bufPos, &sr);
-   free(ptr);
-   return;
-}
-
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#include <string.h>
+#define  CURSES_LIBRARY 1
+#define  INCLUDE_WINDOWS_H
+#include <curses.h>
+
+#ifdef HAVE_MEMORY_H
+# include <memory.h>
+#endif
+
+extern HANDLE hConOut;
+
+#ifdef PDCDEBUG
+char *rcsid_PDCdisp  = "$Id: pdcdisp.c,v 1.1 2001/01/10 08:30:47 mark Exp $";
+#endif
+
+static CHAR_INFO ci[512];
+/*man-start*********************************************************************
+
+  PDC_clr_update()   - Updates the screen with a full redraw.
+
+  PDCurses Description:
+   Updates the screen by clearing it and then redraw it in its
+   entirety. If PDC_SP->refrbrk is TRUE, and there is pending
+   input characters, the update will be prematurely terminated.
+
+  PDCurses Return Value:
+   This routine returns ERR if it is unable to accomplish it's task.
+   This return value is ONLY under FLEXOS.
+
+   The return value OK is returned if there were no errors.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_clr_update( WINDOW* s );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int   PDC_clr_update(WINDOW *s)
+/***********************************************************************/
+{
+   extern unsigned char atrtab[MAX_ATRTAB];
+
+   register int   i=0,j=0;
+   register chtype *srcp;
+   WINDOW *w = NULL;
+   bool rc=FALSE;
+   COORD bufSize, bufPos;
+   SMALL_RECT sr;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_clr_update() - called\n");
+#endif
+
+   w = curscr;
+   if (w == (WINDOW *)NULL)
+      return( ERR );
+#if 0
+   if (PDC_SP->full_redraw)
+      PDC_clr_scrn(s); /* clear physical screen */
+#endif
+
+   s->_clear = FALSE;
+   bufPos.X = bufPos.Y = 0;
+   bufSize.X = COLS;
+   bufSize.Y = 1;
+   sr.Left = 0;
+   sr.Right = COLS - 1;
+   for (i = 0; i < LINES; i++)   /* update physical screen */
+   {
+      if (s != w)
+         memcpy(w->_y[i], s->_y[i], COLS * sizeof(chtype));
+
+      srcp = s->_y[i];
+
+      sr.Top = i;
+      sr.Bottom = i;
+
+      for (j = 0; j < COLS; j++)
+      {
+         ci[j].Char.AsciiChar = *(srcp+j) & A_CHARTEXT;
+         ci[j].Attributes = (chtype_attr(*(srcp+j)) & 0xFF00) >> 8 ;
+#ifdef HIDE_ATTR
+         ci[j].Attributes =  FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
+#endif
+      }
+      WriteConsoleOutput(hConOut, ci, bufSize, bufPos, &sr);
+
+      if (PDC_SP->refrbrk && (PDC_SP->cbreak || PDC_SP->raw_inp)) 
+      {
+         rc = PDC_breakout();
+         if (rc)
+            break;
+      }
+   }
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_cursor_on() - Turns on the hardware cursor.
+
+  PDCurses Description:
+   Turns on the hardware curses, it does nothing if it is already on.
+
+  PDCurses Return Value:
+   Returns OK upon success, ERR upon failure.
+
+  Portability:
+   PDCurses int PDC_cursor_on( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int   PDC_cursor_on(void)
+/***********************************************************************/
+{
+CONSOLE_CURSOR_INFO cci;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_cursor_on() - called\n");
+#endif
+
+   if (!PDC_SP->visible_cursor)
+   {
+      PDC_SP->visible_cursor = TRUE;
+      GetConsoleCursorInfo(hConOut,&cci);
+      cci.bVisible = TRUE;
+      SetConsoleCursorInfo(hConOut,&cci);
+   }
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_cursor_off()   - Turns off the hardware cursor.
+
+  PDCurses Description:
+   Turns off the hardware curses, it does nothing if it is already off.
+
+  PDCurses Return Value:
+   Returns OK upon success, ERR upon failure.
+
+  PDCurses Errors:
+   ERR will be returned (in the case of FLEXOS) if the hardware cursor
+   can not be disabled.
+
+  Portability:
+   PDCurses int PDC_cursor_off( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int   PDC_cursor_off(void)
+/***********************************************************************/
+{
+CONSOLE_CURSOR_INFO cci;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_cursor_off() - called\n");
+#endif
+   
+   if (PDC_SP->visible_cursor)
+   {
+      PDC_SP->visible_cursor = FALSE;
+      GetConsoleCursorInfo(hConOut,&cci);
+      cci.bVisible = FALSE;
+      SetConsoleCursorInfo(hConOut,&cci);
+   }
+
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_fix_cursor()   - Fix the cursor start and stop scan lines (if necessary)
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   This routine will fix the cursor shape for certain video adapters.
+   Normally, the values used are correct, but some adapters choke.
+   The most noticable choke is on a monochrome adapter.  The "correct"
+   scan lines will result in the cursor being set in the middle of the
+   character cell, rather than at the bottom.
+
+   The passed flag indicates whether the cursor is visible or not.
+
+   This only applies to the DOS platform.
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_fix_cursor( int flag );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int   PDC_fix_cursor(int flag)
+/***********************************************************************/
+{
+   return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_gotoxy() - position hardware cursor at (x, y)
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Moves the physical cursor to the desired address on the
+   screen. We don't optimize here -- on a PC, it takes more time
+   to optimize than to do things directly.
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_gotoxy( int row, int col );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int   PDC_gotoxy(int row, int col)
+/***********************************************************************/
+{
+   COORD coord;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_gotoxy() - called: row %d col %d\n",row,col);
+#endif
+
+   if ((PDC_SP->cursrow == row) && (PDC_SP->curscol == col))
+   return( OK );
+
+   coord.X = col;
+   coord.Y = row;
+
+   SetConsoleCursorPosition(hConOut, coord);
+   return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_putc()   - Output a character in the current attribute.
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Outputs character 'chr' to screen in tty fashion. If a colour
+   mode is active, the character is written with colour 'colour'.
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_putc( chtype character, chtype color );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int   PDC_putc( chtype character, chtype color )
+/***********************************************************************/
+{
+   int curRow, curCol;
+   WORD buffer[2];
+   COORD coord;
+   DWORD written;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_putc() - called:char=%c attrib=0x%x color=0x%x\n",character & A_CHARTEXT,character & A_ATTRIBUTES,color);
+#endif
+
+   buffer[0] = color;
+   PDC_get_cursor_pos (&curRow, &curCol);
+
+   coord.X = curCol;
+   coord.Y = curRow;
+//   WriteConsoleOutputAttribute(hConOut, &buffer, 1, coord, &written);
+
+   buffer[0] = character;
+   WriteConsoleOutputCharacter(hConOut, (char*)&buffer[0], 1, coord, &written);
+       
+   return (OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_putctty()   - Output a character and attribute in TTY fashion.
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Outputs character 'chr' to screen in tty fashion. If a colour
+   mode is active, the character is written with colour 'colour'.
+
+   This function moves the physical cursor after writing so the
+   screen will scroll if necessary.
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_putctty( chtype character, chtype color );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int   PDC_putctty( chtype character, chtype color )
+/***********************************************************************/
+{
+   int curRow=0, curCol=0;
+   WORD buffer;
+   COORD coord;
+   DWORD written;
+
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_putctty() - called\n");
+#endif
+
+   buffer = color; 
+   PDC_get_cursor_pos (&curRow, &curCol);
+   coord.X = curCol;
+   coord.Y = curRow;
+//   WriteConsoleOutputAttribute(hConOut, &buffer, 1, coord, &written);
+       
+   buffer = character; 
+   WriteConsoleOutputCharacter(hConOut, (char*)&buffer, 1, coord, &written);
+       
+   return (OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_scroll() - low level screen scroll
+
+  PDCurses Description:
+   Scrolls a window in the current page up or down. Urow, lcol,
+   lrow, rcol are the window coordinates. Lines is the number of
+   lines to scroll. If 0, clears the window, if < 0 scrolls down,
+   if > 0 scrolls up.  Blanks areas that are left, and sets
+   character attributes to attr. If in a colour graphics mode,
+   fills them with the colour 'attr' instead.
+
+  PDCurses Return Value:
+   The PDC_scroll() function returns OK on success otherwise ERR is returned.
+
+  PDCurses Errors:
+   An error will only be returned on the Flexos platform if s_copy()
+   fails.
+
+  Portability:
+   PDCurses int PDC_scroll( int urow, int lcol, int rcol,
+                 int nlines, chtype attr );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int   PDC_scroll(int urow, int lcol, int lrow, int rcol, int nlines, chtype attr)
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_scroll() - called: urow %d lcol %d lrow %d rcol %d nlines %d\n",urow,lcol,lrow,rcol,nlines);
+#endif
+
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_transform_line()  - display a physical line of the screen
+
+  PDCurses Description:
+   This is a private PDCurses function.
+
+   Updates the given physical line to look like the corresponding
+   line in _curscr.
+
+  PDCurses Return Value:
+   This routine returns TRUE if a premature refresh end
+   is allowed, and there is an input character pending.  Otherwise,
+   FALSE is returned.
+
+  PDCurses Errors:
+   No errors are defined for this routine.
+
+  Portability:
+   PDCurses bool  PDC_transform_line( int lineno );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+bool  PDC_transform_line(register int lineno)
+/***********************************************************************/
+{
+   extern unsigned   char atrtab[MAX_ATRTAB];
+
+   register int j=0;
+   register chtype *srcp;
+   int   x=0;
+   int   endx=0;
+   int   len=0;
+   bool rc=FALSE;
+   COORD bufSize, bufPos;
+   SMALL_RECT sr;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_transform_line() - called: lineno=%d\n",lineno);
+#endif
+
+   if (curscr == (WINDOW *)NULL)
+      return( FALSE );
+
+   x = curscr->_firstch[lineno];
+   endx = curscr->_lastch[lineno];
+   srcp = curscr->_y[lineno] + x;
+   len = endx-x+1;
+
+   bufPos.X = bufPos.Y = 0;
+
+   bufSize.X = len;
+   bufSize.Y = 1;
+
+   sr.Top = lineno;
+   sr.Bottom = lineno;
+   sr.Left = x;
+   sr.Right = endx;
+
+   for (j = 0; j < len; j++)
+   {
+      ci[j].Char.AsciiChar = *(srcp+j) & A_CHARTEXT;
+      ci[j].Attributes = (chtype_attr(*(srcp+j)) & 0xFF00) >> 8 ;
+#ifdef HIDE_ATTR
+      ci[j].Attributes =  FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
+#endif
+   }
+
+   WriteConsoleOutput(hConOut, ci, bufSize, bufPos, &sr);
+
+   curscr->_firstch[lineno] = _NO_CHANGE;
+   curscr->_lastch[lineno] = _NO_CHANGE;
+   
+   if (PDC_SP->refrbrk && (PDC_SP->cbreak || PDC_SP->raw_inp)) 
+   {
+      rc = PDC_breakout();
+      if (rc)
+         return(TRUE);
+   }
+   return(FALSE);
+}
+
+/*man-start*********************************************************************
+
+  PDC_doupdate()  - display updated data in one call (Win32 only)
+
+  PDCurses Description:
+   This is a private PDCurses function.
+
+   Updates the given physical screen to look like _curscr.
+
+  PDCurses Return Value:
+   This routine returns nothing.
+
+  PDCurses Errors:
+   No errors are defined for this routine.
+
+  Portability:
+   PDCurses void  PDC_doupdate( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+void PDC_doupdate(void)
+/***********************************************************************/
+{
+   extern unsigned   char atrtab[MAX_ATRTAB];
+
+   register int i=0,j=0,k=0;
+   int   starty=_NO_CHANGE,startx=_NO_CHANGE;
+   int size=0;
+   int   endy=_NO_CHANGE,endx=_NO_CHANGE;
+   register chtype *srcp;
+   CHAR_INFO *ptr=NULL;
+   COORD bufSize, bufPos;
+   SMALL_RECT sr;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_doupdate() - called:\n");
+#endif
+
+   if (curscr == (WINDOW *)NULL)
+      return;
+
+   for (i = 0; i < LINES; i++ )
+   {
+      if (curscr->_firstch[i] != _NO_CHANGE)
+      {
+         if (starty == _NO_CHANGE)
+            starty = i;
+         endy = i;
+         if (startx == _NO_CHANGE
+         &&  curscr->_firstch[i] != _NO_CHANGE)
+            startx = curscr->_firstch[i];
+         if (curscr->_firstch[i] < startx)
+            startx = curscr->_firstch[i];
+         if (curscr->_lastch[i] > endx)
+            endx = curscr->_lastch[i];
+      }
+   }
+   if (starty == _NO_CHANGE) /* nothing to do... */
+      return;
+
+   size = ((endy - starty) + 1) * ((endx - startx) + 1);
+   ptr = (CHAR_INFO*)malloc(size*sizeof(CHAR_INFO));
+   if (ptr == NULL)
+      return;
+
+   bufPos.X = bufPos.Y = 0;
+   bufSize.X = endx - startx + 1;
+   bufSize.Y = endy - starty + 1;
+
+   sr.Top = starty;
+   sr.Bottom = endy;
+   sr.Left = startx;
+   sr.Right = endx;
+
+   k = 0;
+   for (i = starty; i <= endy; i++ )
+   {
+      srcp = curscr->_y[i];
+      for (j = startx; j <= endx; j++)
+      {
+         ptr[k].Char.AsciiChar = *(srcp+j) & A_CHARTEXT;
+         ptr[k].Attributes = (chtype_attr(*(srcp+j)) & 0xFF00) >> 8 ;
+#ifdef HIDE_ATTR
+         ptr[k].Attributes =  FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
+#endif
+         k++;
+      }
+      curscr->_firstch[i] = _NO_CHANGE;
+      curscr->_lastch[i] = _NO_CHANGE;
+   }
+
+   WriteConsoleOutput(hConOut, ptr, bufSize, bufPos, &sr);
+   free(ptr);
+   return;
+}
+
Index: PDCurses/win32/pdckbd.c
===================================================================
--- PDCurses/win32/pdckbd.c	(revision 1)
+++ PDCurses/win32/pdckbd.c	(working copy)
@@ -1,1411 +1,1411 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-
-#define  CURSES_LIBRARY 1
-#define  INCLUDE_WINDOWS_H
-#include <curses.h>
-
-#include <stdio.h>
-
-#ifdef PDCDEBUG
-char *rcsid_PDCkbd  = "$Id: pdckbd.c,v 1.9 2002/12/16 09:40:36 mark Exp $";
-#endif
-
-#define KEY_STATE TRUE
-
-/*
- * MingW32 header files are missing the following in some versions
- * of the compiler
- */
-#ifndef DOUBLE_CLICK
-# define DOUBLE_CLICK 0x0002
-#endif
-
-#ifndef FROM_LEFT_1ST_BUTTON_PRESSED
-# define FROM_LEFT_1ST_BUTTON_PRESSED 0x0001
-#endif
-
-#ifndef FROM_LEFT_2ND_BUTTON_PRESSED
-# define FROM_LEFT_2ND_BUTTON_PRESSED 0x0004
-#endif
-
-#ifndef RIGHTMOST_BUTTON_PRESSED
-# define RIGHTMOST_BUTTON_PRESSED 0x0002
-#endif
-/*
- * These variables are used to store information about the next 
- * Input Event.
- */
-INPUT_RECORD save_ip;
-static unsigned long pdc_key_modifiers=0L;
-
-extern HANDLE hConIn;
-
-#if defined(PDC_THREAD_BUILD)
-extern HANDLE hPipeRead;
-extern HANDLE hPipeWrite;
-extern HANDLE hSemKeyCount;
-#else
-static int keyCount = 0;
-#endif
-
-static void win32_getch(void);
-static int win32_kbhit(int);
-
-/*******************************************************************************
-*  Table for key code translation of function keys in keypad mode
-*  These values are for strict IBM keyboard compatibles only
-*******************************************************************************/
-
-typedef struct 
-{
-   int normal;
-   int shift;
-   int control;
-   int alt;
-   int extended;
-} KPTAB;
-
-static KPTAB kptab[] =
-{
-   {0,          0,          0,           0,          0           }, /* 0 */
-   {0,          0,          0,           0,          0           }, /* 1 */
-   {0,          0,          0,           0,          0           }, /* 2 */
-   {0,          0,          0,           0,          0           }, /* 3 */
-   {0,          0,          0,           0,          0           }, /* 4 */
-   {0,          0,          0,           0,          0           }, /* 5 */
-   {0,          0,          0,           0,          0           }, /* 6 */
-   {0,          0,          0,           0,          0           }, /* 7 */
-   {0x08,       0x08,       0x7F,        ALT_BKSP,   0           }, /* 8 */
-   {0x09,       KEY_BTAB,   CTL_TAB,     ALT_TAB,    999         }, /* 9 */
-   {0,          0,          0,           0,          0           }, /* 10 */
-   {0,          0,          0,           0,          0           }, /* 11 */
-   {KEY_B2,     0x35,       CTL_PAD5,    ALT_PAD5,   0           }, /* 12 */
-   {0x0D,       0x0D,       CTL_ENTER,   ALT_ENTER,  1           }, /* 13 */
-   {0,          0,          0,           0,          0           }, /* 14 */
-   {0,          0,          0,           0,          0           }, /* 15 */
-   {0,          0,          0,           0,          0           }, /* 16 */
-   {0,          0,          0,           0,          0           }, /* 17 */
-   {0,          0,          0,           0,          0           }, /* 18 */
-   {0,          0,          0,           0,          0           }, /* 19 */
-   {0,          0,          0,           0,          0           }, /* 20 */
-   {0,          0,          0,           0,          0           }, /* 21 */
-   {0,          0,          0,           0,          0           }, /* 22 */
-   {0,          0,          0,           0,          0           }, /* 23 */
-   {0,          0,          0,           0,          0           }, /* 24 */
-   {0,          0,          0,           0,          0           }, /* 25 */
-   {0,          0,          0,           0,          0           }, /* 26 */
-   {0x1B,       0x1B,       0x1B,        ALT_ESC,    0           }, /* 27 */
-   {0,          0,          0,           0,          0           }, /* 28 */
-   {0,          0,          0,           0,          0           }, /* 29 */
-   {0,          0,          0,           0,          0           }, /* 30 */
-   {0,          0,          0,           0,          0           }, /* 31 */
-   {0x20,       0x20,       0x20,        0x20,       0           }, /* 32 */
-   {KEY_A3,     0x39,       CTL_PAD9,    ALT_PAD9,   3           }, /* 33 */
-   {KEY_C3,     0x33,       CTL_PAD3,    ALT_PAD3,   4           }, /* 34 */
-   {KEY_C1,     0x31,       CTL_PAD1,    ALT_PAD1,   5           }, /* 35 */
-   {KEY_A1,     0x37,       CTL_PAD7,    ALT_PAD7,   6           }, /* 36 */
-   {KEY_B1,     0x34,       CTL_PAD4,    ALT_PAD4,   7           }, /* 37 */
-   {KEY_A2,     0x38,       CTL_PAD8,    ALT_PAD8,   8           }, /* 38 */
-   {KEY_B3,     0x36,       CTL_PAD6,    ALT_PAD6,   9           }, /* 39 */
-   {KEY_C2,     0x32,       CTL_PAD2,    ALT_PAD2,   10          }, /* 40 */
-   {0,          0,          0,           0,          0           }, /* 41 */
-   {0,          0,          0,           0,          0           }, /* 42 */
-   {0,          0,          0,           0,          0           }, /* 43 */
-   {0,          0,          0,           0,          0           }, /* 44 */
-   {PAD0,       0x30,       CTL_PAD0,    ALT_PAD0,   11          }, /* 45 */
-   {PADSTOP,    0x2E,       CTL_PADSTOP, ALT_PADSTOP,12          }, /* 46 */
-   {0,          0,          0,           0,          0           }, /* 47 */
-   {0x30,       0x29,       0,           ALT_0,      0           }, /* 48 */
-   {0x31,       0x21,       0,           ALT_1,      0           }, /* 49 */
-   {0x32,       0x40,       0,           ALT_2,      0           }, /* 50 */
-   {0x33,       0x23,       0,           ALT_3,      0           }, /* 51 */
-   {0x34,       0x24,       0,           ALT_4,      0           }, /* 52 */
-   {0x35,       0x25,       0,           ALT_5,      0           }, /* 53 */
-   {0x36,       0x5E,       0,           ALT_6,      0           }, /* 54 */
-   {0x37,       0x26,       0,           ALT_7,      0           }, /* 55 */
-   {0x38,       0x2A,       0,           ALT_8,      0           }, /* 56 */
-   {0x39,       0x28,       0,           ALT_9,      0           }, /* 57 */
-   {0,          0,          0,           0,          0           }, /* 58 */
-   {0,          0,          0,           0,          0           }, /* 59 */
-   {0,          0,          0,           0,          0           }, /* 60 */
-   {0,          0,          0,           0,          0           }, /* 61 */
-   {0,          0,          0,           0,          0           }, /* 62 */
-   {0,          0,          0,           0,          0           }, /* 63 */
-   {0,          0,          0,           0,          0           }, /* 64 */
-   {0x61,       0x41,       0x01,        ALT_A,      0           }, /* 65 */
-   {0x62,       0x42,       0x02,        ALT_B,      0           }, /* 66 */
-   {0x63,       0x43,       0x03,        ALT_C,      0           }, /* 67 */
-   {0x64,       0x44,       0x04,        ALT_D,      0           }, /* 68 */
-   {0x65,       0x45,       0x05,        ALT_E,      0           }, /* 69 */
-   {0x66,       0x46,       0x06,        ALT_F,      0           }, /* 70 */
-   {0x67,       0x47,       0x07,        ALT_G,      0           }, /* 71 */
-   {0x68,       0x48,       0x08,        ALT_H,      0           }, /* 72 */
-   {0x69,       0x49,       0x09,        ALT_I,      0           }, /* 73 */
-   {0x6A,       0x4A,       0x0A,        ALT_J,      0           }, /* 74 */
-   {0x6B,       0x4B,       0x0B,        ALT_K,      0           }, /* 75 */
-   {0x6C,       0x4C,       0x0C,        ALT_L,      0           }, /* 76 */
-   {0x6D,       0x4D,       0x0D,        ALT_M,      0           }, /* 77 */
-   {0x6E,       0x4E,       0x0E,        ALT_N,      0           }, /* 78 */
-   {0x6F,       0x4F,       0x0F,        ALT_O,      0           }, /* 79 */
-   {0x70,       0x50,       0x10,        ALT_P,      0           }, /* 80 */
-   {0x71,       0x51,       0x11,        ALT_Q,      0           }, /* 81 */
-   {0x72,       0x52,       0x12,        ALT_R,      0           }, /* 82 */
-   {0x73,       0x53,       0x13,        ALT_S,      0           }, /* 83 */
-   {0x74,       0x54,       0x14,        ALT_T,      0           }, /* 84 */
-   {0x75,       0x55,       0x15,        ALT_U,      0           }, /* 85 */
-   {0x76,       0x56,       0x16,        ALT_V,      0           }, /* 86 */
-   {0x77,       0x57,       0x17,        ALT_W,      0           }, /* 87 */
-   {0x78,       0x58,       0x18,        ALT_X,      0           }, /* 88 */
-   {0x79,       0x59,       0x19,        ALT_Y,      0           }, /* 89 */
-   {0x7A,       0x5A,       0x1A,        ALT_Z,      0           }, /* 90 */
-   {0,          0,          0,           0,          0           }, /* 91 */
-   {0,          0,          0,           0,          0           }, /* 92 */
-   {0,          0,          0,           0,          0           }, /* 93 */
-   {0,          0,          0,           0,          0           }, /* 94 */
-   {0,          0,          0,           0,          0           }, /* 95 */
-   {0x30,       0,          CTL_PAD0,    ALT_PAD0,   0           }, /* 96 */
-   {0x31,       0,          CTL_PAD1,    ALT_PAD1,   0           }, /* 97 */
-   {0x32,       0,          CTL_PAD2,    ALT_PAD2,   0           }, /* 98 */
-   {0x33,       0,          CTL_PAD3,    ALT_PAD3,   0           }, /* 99 */
-   {0x34,       0,          CTL_PAD4,    ALT_PAD4,   0           }, /* 100 */
-   {0x35,       0,          CTL_PAD5,    ALT_PAD5,   0           }, /* 101 */
-   {0x36,       0,          CTL_PAD6,    ALT_PAD6,   0           }, /* 102 */
-   {0x37,       0,          CTL_PAD7,    ALT_PAD7,   0           }, /* 103 */
-   {0x38,       0,          CTL_PAD8,    ALT_PAD8,   0           }, /* 104 */
-   {0x39,       0,          CTL_PAD9,    ALT_PAD9,   0           }, /* 105 */
-   {PADSTAR,    SHF_PADSTAR,CTL_PADSTAR, ALT_PADSTAR,999         }, /* 106 */
-   {PADPLUS,    SHF_PADPLUS,CTL_PADPLUS, ALT_PADPLUS,999         }, /* 107 */
-   {0,          0,          0,           0,          0           }, /* 108 */
-   {PADMINUS,   SHF_PADMINUS,CTL_PADMINUS,ALT_PADMINUS,999       }, /* 109 */
-   {0x2E,       0,          CTL_PADSTOP, ALT_PADSTOP,0           }, /* 110 */
-   {PADSLASH,   SHF_PADSLASH,CTL_PADSLASH,ALT_PADSLASH,2         }, /* 111 */
-   {KEY_F(1),   KEY_F(13),  KEY_F(25),   KEY_F(37),  0           }, /* 112 */
-   {KEY_F(2),   KEY_F(14),  KEY_F(26),   KEY_F(38),  0           }, /* 113 */
-   {KEY_F(3),   KEY_F(15),  KEY_F(27),   KEY_F(39),  0           }, /* 114 */
-   {KEY_F(4),   KEY_F(16),  KEY_F(28),   KEY_F(40),  0           }, /* 115 */
-   {KEY_F(5),   KEY_F(17),  KEY_F(29),   KEY_F(41),  0           }, /* 116 */
-   {KEY_F(6),   KEY_F(18),  KEY_F(30),   KEY_F(42),  0           }, /* 117 */
-   {KEY_F(7),   KEY_F(19),  KEY_F(31),   KEY_F(43),  0           }, /* 118 */
-   {KEY_F(8),   KEY_F(20),  KEY_F(32),   KEY_F(44),  0           }, /* 119 */
-   {KEY_F(9),   KEY_F(21),  KEY_F(33),   KEY_F(45),  0           }, /* 120 */
-   {KEY_F(10),  KEY_F(22),  KEY_F(34),   KEY_F(46),  0           }, /* 121 */
-   {KEY_F(11),  KEY_F(23),  KEY_F(35),   KEY_F(47),  0           }, /* 122 */
-   {KEY_F(12),  KEY_F(24),  KEY_F(36),   KEY_F(48),  0           }, /* 123 */
-   {0,          0,          0,           0,          0           }, /* 124 */
-   {0,          0,          0,           0,          0           }, /* 125 */
-   {0,          0,          0,           0,          0           }, /* 126 */
-   {0,          0,          0,           0,          0           }, /* 127 */
-   {0,          0,          0,           0,          0           }, /* 128 */
-   {0,          0,          0,           0,          0           }, /* 129 */
-   {0,          0,          0,           0,          0           }, /* 130 */
-   {0,          0,          0,           0,          0           }, /* 131 */
-   {0,          0,          0,           0,          0           }, /* 132 */
-   {0,          0,          0,           0,          0           }, /* 133 */
-   {0,          0,          0,           0,          0           }, /* 134 */
-   {0,          0,          0,           0,          0           }, /* 135 */
-   {0,          0,          0,           0,          0           }, /* 136 */
-   {0,          0,          0,           0,          0           }, /* 137 */
-   {0,          0,          0,           0,          0           }, /* 138 */
-   {0,          0,          0,           0,          0           }, /* 139 */
-   {0,          0,          0,           0,          0           }, /* 140 */
-   {0,          0,          0,           0,          0           }, /* 141 */
-   {0,          0,          0,           0,          0           }, /* 142 */
-   {0,          0,          0,           0,          0           }, /* 143 */
-   {0,          0,          0,           0,          0           }, /* 144 */
-   {0,          0,          0,           0,          0           }, /* 145 */
-   {0,          0,          0,           0,          0           }, /* 146 */
-   {0,          0,          0,           0,          0           }, /* 147 */
-   {0,          0,          0,           0,          0           }, /* 148 */
-   {0,          0,          0,           0,          0           }, /* 149 */
-   {0,          0,          0,           0,          0           }, /* 150 */
-   {0,          0,          0,           0,          0           }, /* 151 */
-   {0,          0,          0,           0,          0           }, /* 152 */
-   {0,          0,          0,           0,          0           }, /* 153 */
-   {0,          0,          0,           0,          0           }, /* 154 */
-   {0,          0,          0,           0,          0           }, /* 155 */
-   {0,          0,          0,           0,          0           }, /* 156 */
-   {0,          0,          0,           0,          0           }, /* 157 */
-   {0,          0,          0,           0,          0           }, /* 158 */
-   {0,          0,          0,           0,          0           }, /* 159 */
-   {0,          0,          0,           0,          0           }, /* 160 */
-   {0,          0,          0,           0,          0           }, /* 161 */
-   {0,          0,          0,           0,          0           }, /* 162 */
-   {0,          0,          0,           0,          0           }, /* 163 */
-   {0,          0,          0,           0,          0           }, /* 164 */
-   {0,          0,          0,           0,          0           }, /* 165 */
-   {0,          0,          0,           0,          0           }, /* 166 */
-   {0,          0,          0,           0,          0           }, /* 167 */
-   {0,          0,          0,           0,          0           }, /* 168 */
-   {0,          0,          0,           0,          0           }, /* 169 */
-   {0,          0,          0,           0,          0           }, /* 170 */
-   {0,          0,          0,           0,          0           }, /* 171 */
-   {0,          0,          0,           0,          0           }, /* 172 */
-   {0,          0,          0,           0,          0           }, /* 173 */
-   {0,          0,          0,           0,          0           }, /* 174 */
-   {0,          0,          0,           0,          0           }, /* 175 */
-   {0,          0,          0,           0,          0           }, /* 176 */
-   {0,          0,          0,           0,          0           }, /* 177 */
-   {0,          0,          0,           0,          0           }, /* 178 */
-   {0,          0,          0,           0,          0           }, /* 179 */
-   {0,          0,          0,           0,          0           }, /* 180 */
-   {0,          0,          0,           0,          0           }, /* 181 */
-   {0,          0,          0,           0,          0           }, /* 182 */
-   {0,          0,          0,           0,          0           }, /* 183 */
-   {0,          0,          0,           0,          0           }, /* 184 */
-   {0,          0,          0,           0,          0           }, /* 185 */
-   {0x3B,       0x3A,       0x3B,        ALT_SEMICOLON,0,        }, /* 186 */
-   {0x3D,       0x2B,       0x3D,        ALT_EQUAL,  0           }, /* 187 */
-   {0x2C,       0x3C,       0x2C,        ALT_COMMA,  0           }, /* 188 */
-   {0x2D,       0x5F,       0x2D,        0x2D,       0           }, /* 189 */
-   {0x2E,       0x3E,       0x2E,        ALT_STOP,   0           }, /* 190 */
-   {0x2F,       0x3F,       0x2F,        ALT_FSLASH, 13          }, /* 191 */
-   {0x60,       0x7E,       0x60,        ALT_BQUOTE, 0           }, /* 192 */
-   {0,          0,          0,           0,          0           }, /* 193 */
-   {0,          0,          0,           0,          0           }, /* 194 */
-   {0,          0,          0,           0,          0           }, /* 195 */
-   {0,          0,          0,           0,          0           }, /* 196 */
-   {0,          0,          0,           0,          0           }, /* 197 */
-   {0,          0,          0,           0,          0           }, /* 198 */
-   {0,          0,          0,           0,          0           }, /* 199 */
-   {0,          0,          0,           0,          0           }, /* 200 */
-   {0,          0,          0,           0,          0           }, /* 201 */
-   {0,          0,          0,           0,          0           }, /* 202 */
-   {0,          0,          0,           0,          0           }, /* 203 */
-   {0,          0,          0,           0,          0           }, /* 204 */
-   {0,          0,          0,           0,          0           }, /* 205 */
-   {0,          0,          0,           0,          0           }, /* 206 */
-   {0,          0,          0,           0,          0           }, /* 207 */
-   {0,          0,          0,           0,          0           }, /* 208 */
-   {0,          0,          0,           0,          0           }, /* 209 */
-   {0,          0,          0,           0,          0           }, /* 210 */
-   {0,          0,          0,           0,          0           }, /* 211 */
-   {0,          0,          0,           0,          0           }, /* 212 */
-   {0,          0,          0,           0,          0           }, /* 213 */
-   {0,          0,          0,           0,          0           }, /* 214 */
-   {0,          0,          0,           0,          0           }, /* 215 */
-   {0,          0,          0,           0,          0           }, /* 216 */
-   {0,          0,          0,           0,          0           }, /* 217 */
-   {0,          0,          0,           0,          0           }, /* 218 */
-   {0x5B,       0x7B,       0x1B,        ALT_LBRACKET,0          }, /* 219 */
-   {0x5C,       0x7C,       0x1C,        ALT_BSLASH, 0           }, /* 220 */
-   {0x5D,       0x7D,       0x1D,        ALT_RBRACKET,0          }, /* 221 */
-   {0,          0,          0x27,        ALT_FQUOTE, 0           }, /* 222 */
-   {0,          0,          0,           0,          0           }, /* 223 */
-   {0,          0,          0,           0,          0           }, /* 224 */
-   {0,          0,          0,           0,          0           }  /* 225 */
-};
-
-static KPTAB ext_kptab[] =
-{
-   {0,          0,          0,           0,          }, /* MUST BE EMPTY */
-   {PADENTER,   SHF_PADENTER,   CTL_PADENTER,ALT_PADENTER}, /* 13 */
-   {PADSLASH,   SHF_PADSLASH,   CTL_PADSLASH,ALT_PADSLASH}, /* 111 */
-   {KEY_PPAGE,  KEY_SPREVIOUS,  CTL_PGUP,    ALT_PGUP    }, /* 33 */
-   {KEY_NPAGE,  KEY_SNEXT,      CTL_PGDN,    ALT_PGDN    }, /* 34 */
-   {KEY_END,    KEY_SEND,       CTL_END,     ALT_END     }, /* 35 */
-   {KEY_HOME,   KEY_SHOME,      CTL_HOME,    ALT_HOME    }, /* 36 */
-   {KEY_LEFT,   KEY_SLEFT,      CTL_LEFT,    ALT_LEFT    }, /* 37 */
-   {KEY_UP,     KEY_SUP,        CTL_UP,      ALT_UP      }, /* 38 */
-   {KEY_RIGHT,  KEY_SRIGHT,     CTL_RIGHT,   ALT_RIGHT   }, /* 39 */
-   {KEY_DOWN,   KEY_SDOWN,      CTL_DOWN,    ALT_DOWN    }, /* 40 */
-   {KEY_IC,     KEY_SIC,        CTL_INS,     ALT_INS     }, /* 45 */
-   {KEY_DC,     KEY_SDC,        CTL_DEL,     ALT_DEL     }, /* 46 */
-   {PADSLASH,   SHF_PADSLASH,   CTL_PADSLASH,ALT_PADSLASH}, /* 191 */
-};
- /* End of kptab[]       */
-
-MOUSE_STATUS Trapped_Mouse_status;
-
-/*man-start*********************************************************************
-
-  PDC_breakout()  - check for type-ahead
-
-  X/Open Description:
-   The curses package does the "line-breakout optimisation" by
-   looking for type-ahead periodically while updating the screen.
-   If input is found, the current update will be postponed until
-   refresh() or doupdate() are called again.  This allows faster
-   response to commands typed in advance.  Normally, the input FILE
-   pointer passed to newterm(), or stdin in the case when initscr()
-   was called, will be used to do this type-ahead checking.  This routine
-   will do the actual check for PDcurses to see if input is pending.
-
-  PDCurses Description:
-   This routine does what the PDcurses typeahead routine used to do.  But
-   to make that routine consistent with its System V counterpart, all it
-   does now is set whether or not typeahead checking is performed.
-
-  X/Open Return Value:
-   The PDC_breakout() routine returns TRUE if keyboard input is pending
-   otherwise FALSE is returned.
-
-  Portability:
-   PDCurses bool PD_breakout( void );
-
-**man-end**********************************************************************/
-
-bool PDC_breakout( void )
-{
-   extern   int   c_pindex;         /* putter index */
-   extern   int   c_gindex;         /* getter index */
-   extern   int   c_ungind;         /* wungetch() push index */
-   bool rc;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_breakout() - called\n");
-#endif
-
-   if (c_ungind)
-      rc = TRUE;       /* ungotten char */
-   else if (c_pindex > c_gindex)
-      rc = TRUE;       /* buffered char */
-   else if (SP->raw_inp)
-      rc= (bool)PDC_check_bios_key();  /* raw mode test */
-   else
-      rc = (bool)PDC_check_bios_key(); /* normal mode test */
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_breakout() - returned: %d c_ungind %d c_pindex %d c_gindex %d\n",rc,c_ungind,c_pindex,c_gindex);
-#endif
-   return(rc);
-}
-
-/*man-start*********************************************************************
-
-  PDC_get_input_fd() - Get file descriptor used for PDCurses input
-
-  PDCurses Description:
-   This is a private PDCurses routine.
-
-   This routine will return the file descriptor that PDCurses reads
-   its input from. It can be used for WaitForMulitpleObjects()
-
-  PDCurses Return Value:
-   Returns a HANDLE.
-
-  PDCurses Errors:
-   No errors are defined for this function.
-
-  Portability:
-   PDCurses int   PDC_get_input_fd( void );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-unsigned long PDC_get_input_fd(void)
-#else
-unsigned long PDC_get_input_fd()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_get_input_fd() - called\n");
-#endif
-
-#if defined(PDC_THREAD_BUILD)
-   return (unsigned long)hSemKeyCount;
-#else
-   return 0L;
-#endif
-}
-
-/*man-start*********************************************************************
-
-  PDC_check_bios_key()  - Check BIOS key data area for input
-
-  PDCurses Description:
-   This is a private PDCurses routine.
-
-   This routine will check the BIOS for any indication that
-   keystrokes are pending.
-
-  PDCurses Return Value:
-   Returns 1 if a keyboard character is available, 0 otherwise.
-
-  PDCurses Errors:
-   No errors are defined for this function.
-
-  Portability:
-   PDCurses bool  PDC_check_bios_key( void );
-
-**man-end**********************************************************************/
-
-bool PDC_check_bios_key(void)
-{
-   return(win32_kbhit(0));
-}         
-
-/*man-start*********************************************************************
-
-  PDC_get_bios_key() - Returns the next key available from the BIOS.
-
-  PDCurses Description:
-   This is a private PDCurses routine.
-
-   Returns the next key code struck at the keyboard. If the low 8
-   bits are 0, the upper bits contain the extended character
-   code. If bit 0-7 are non-zero, the upper bits = 0.
-
-  PDCurses Return Value:
-   This function returns OK on success and ERR on error.
-
-  PDCurses Errors:
-   No errors are defined for this function.
-
-  Portability:
-   PDCurses int PDC_get_bios_key( void );
-
-**man-end**********************************************************************/
-
-int   PDC_get_bios_key(void)
-{
-   MOUSE_STATUS Temp_Mouse_status;
-   static int last_button_no=0;
-   static MOUSE_STATUS Actual_Mouse_status;
-   int button_no=0;
-   bool trap_mouse=FALSE;
-   int idx=0,key=0;
-   bool enhanced=FALSE;
-   unsigned long local_key_modifiers=0L;
-   int ignore_key;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_get_bios_key() - called\n");
-#endif
-
-   while(1)
-   {
-      win32_getch();
-   
-      switch(save_ip.EventType)
-      {
-         case KEY_EVENT:
-#if 0
-         {
-            char buf[KL_NAMELENGTH];
-            GetKeyboardLayoutName( buf );
-            fprintf(stderr,"AsciiChar: %d Unicode: %d KeyCode: %d ScanCode: %d State: %x Name: %s\n",
-                    save_ip.Event.KeyEvent.uChar.AsciiChar,
-                    save_ip.Event.KeyEvent.uChar.UnicodeChar,
-                    save_ip.Event.KeyEvent.wVirtualKeyCode,
-                    save_ip.Event.KeyEvent.wVirtualScanCode,
-                    save_ip.Event.KeyEvent.dwControlKeyState,
-                    buf
-                    );
-         }
-#endif
-
-            local_key_modifiers = pdc_key_modifiers = 0L;
-            ignore_key = 0;
-            switch(save_ip.Event.KeyEvent.wVirtualKeyCode)
-            {
-               case 16: /* shift */
-                  if ( SP->return_key_modifiers ) return KEY_SHIFT_R;
-                  ignore_key = 1;
-                  break;
-               case 17: /* control */
-                  if (save_ip.Event.KeyEvent.dwControlKeyState & LEFT_CTRL_PRESSED)
-                  {
-                     if ( SP->return_key_modifiers ) return KEY_CONTROL_L;
-                  }
-                  else
-                  {
-                     if ( SP->return_key_modifiers ) return KEY_CONTROL_R;
-                  }
-                  ignore_key = 1;
-                  break;
-               case 18: /* alt */
-                  if (save_ip.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED)
-                  {
-                     if ( SP->return_key_modifiers ) return KEY_ALT_L;
-                  }
-                  else
-                  {
-                     if ( SP->return_key_modifiers ) return KEY_ALT_R;
-                  }
-                  ignore_key = 1;
-                  break;
-               default:
-                  break;
-            }
-            if ( ignore_key )
-               break;
-            /*
-             * Must calculate the key modifiers so that Alt keys work!
-             */
-            if (save_ip.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED
-            ||  save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_ALT_PRESSED)
-               local_key_modifiers |= PDC_KEY_MODIFIER_ALT;
-            if (save_ip.Event.KeyEvent.dwControlKeyState & SHIFT_PRESSED)
-               local_key_modifiers |= PDC_KEY_MODIFIER_SHIFT;
-            if (save_ip.Event.KeyEvent.dwControlKeyState & LEFT_CTRL_PRESSED
-            ||  save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_CTRL_PRESSED)
-               local_key_modifiers |= PDC_KEY_MODIFIER_CONTROL;
-            if (save_ip.Event.KeyEvent.dwControlKeyState & NUMLOCK_ON)
-               local_key_modifiers |= PDC_KEY_MODIFIER_NUMLOCK;
-            /*
-             * Save the key modifiers if required
-             */
-            if (SP->save_key_modifiers)
-            {
-               pdc_key_modifiers = local_key_modifiers;
-            }
-            /*
-             * If the Unicode character is not zero; its a displayable character.
-             * Check for Ctrl-Alt sequences; they are diatric characters
-             */
-            if ( save_ip.Event.KeyEvent.uChar.UnicodeChar != 0 )
-            {
-               idx = save_ip.Event.KeyEvent.wVirtualKeyCode;
-               if ( local_key_modifiers & PDC_KEY_MODIFIER_CONTROL
-               &&   local_key_modifiers & PDC_KEY_MODIFIER_ALT )
-                  return (int)save_ip.Event.KeyEvent.uChar.UnicodeChar;
-               if ( local_key_modifiers & PDC_KEY_MODIFIER_CONTROL )
-                  return kptab[idx].control;
-               if ( local_key_modifiers & PDC_KEY_MODIFIER_ALT )
-                  return kptab[idx].alt;
-               return (int)save_ip.Event.KeyEvent.uChar.UnicodeChar;
-            }
-
-            if (save_ip.Event.KeyEvent.uChar.AsciiChar == 0
-            ||  save_ip.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED
-            ||  save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_ALT_PRESSED
-            ||  save_ip.Event.KeyEvent.dwControlKeyState & ENHANCED_KEY)
-            {
-               if (save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_ALT_PRESSED
-               &&  save_ip.Event.KeyEvent.uChar.AsciiChar != 0)
-/*                  return((int)(unsigned char)save_ip.Event.KeyEvent.uChar.AsciiChar); */
-                  return((int)save_ip.Event.KeyEvent.uChar.UnicodeChar);
-               if (save_ip.Event.KeyEvent.dwControlKeyState & ENHANCED_KEY)
-               {
-                  enhanced = TRUE;
-                  idx = kptab[save_ip.Event.KeyEvent.wVirtualKeyCode].extended;
-               }
-               else
-               {
-                  enhanced = FALSE;
-                  idx = save_ip.Event.KeyEvent.wVirtualKeyCode;
-               }
-               if (save_ip.Event.KeyEvent.dwControlKeyState & SHIFT_PRESSED)
-                  return((enhanced)?ext_kptab[idx].shift:kptab[idx].shift);
-               if (save_ip.Event.KeyEvent.dwControlKeyState & LEFT_CTRL_PRESSED
-               ||  save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_CTRL_PRESSED)
-                  return((enhanced)?ext_kptab[idx].control:kptab[idx].control);
-               if (save_ip.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED
-               ||  save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_ALT_PRESSED)
-                  return((enhanced)?ext_kptab[idx].alt:kptab[idx].alt);
-               return((enhanced)?ext_kptab[idx].normal:kptab[idx].normal);
-            }
-            else
-            {
-               if (kptab[save_ip.Event.KeyEvent.wVirtualKeyCode].extended == 999)
-               {
-                  idx = save_ip.Event.KeyEvent.wVirtualKeyCode;
-                  if (save_ip.Event.KeyEvent.dwControlKeyState & SHIFT_PRESSED)
-                     return(kptab[idx].shift);
-                  if (save_ip.Event.KeyEvent.dwControlKeyState & LEFT_CTRL_PRESSED
-                  ||  save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_CTRL_PRESSED)
-                     return(kptab[idx].control);
-                  if (save_ip.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED
-                  ||  save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_ALT_PRESSED)
-                     return(kptab[idx].alt);
-                  return(kptab[idx].normal);
-               }
-               else
-               {
-                  idx = save_ip.Event.KeyEvent.wVirtualKeyCode;
-                  if (save_ip.Event.KeyEvent.dwControlKeyState & SHIFT_PRESSED
-                  && kptab[idx].shift)
-                     return(kptab[idx].shift);
-                  if ((save_ip.Event.KeyEvent.dwControlKeyState & LEFT_CTRL_PRESSED
-                  ||   save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_CTRL_PRESSED)
-                  &&  kptab[idx].control)
-                     return(kptab[idx].control);
-                  if ((save_ip.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED
-                  ||   save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_ALT_PRESSED)
-                  &&  kptab[idx].alt)
-                     return(kptab[idx].alt);
-/*                  return((int)(unsigned char)save_ip.Event.KeyEvent.uChar.AsciiChar); */
-                  return((int)save_ip.Event.KeyEvent.uChar.UnicodeChar);
-               }
-            }
-            break;
-         case MOUSE_EVENT:
-            memset((char*)&Temp_Mouse_status,0,sizeof(MOUSE_STATUS));
-            /* 
-             * button press, release or double click ...
-             */
-            if (save_ip.Event.MouseEvent.dwEventFlags == 0 
-            ||  save_ip.Event.MouseEvent.dwEventFlags == DOUBLE_CLICK)
-            {
-               /*
-                * Check for Left-most button - always button 1
-                */
-               if (save_ip.Event.MouseEvent.dwButtonState & FROM_LEFT_1ST_BUTTON_PRESSED
-               && !(ACTUAL_BUTTON_STATUS(1) & BUTTON_RELEASED))
-               {
-                  button_no = 1;
-                  TEMP_BUTTON_STATUS(button_no) = (save_ip.Event.MouseEvent.dwEventFlags)?BUTTON_DOUBLE_CLICKED:BUTTON_PRESSED;
-                  if (TEMP_BUTTON_STATUS(button_no) == BUTTON_PRESSED
-                  && (SP->_trap_mbe) & BUTTON1_PRESSED)
-                     trap_mouse = TRUE;
-                  if (TEMP_BUTTON_STATUS(button_no) == BUTTON_DOUBLE_CLICKED
-                  && (SP->_trap_mbe) & BUTTON1_DOUBLE_CLICKED)
-                     trap_mouse = TRUE;
-                  break;
-               }
-               /*
-                * Check for Right-most button - always button 3
-                */
-               if (save_ip.Event.MouseEvent.dwButtonState & RIGHTMOST_BUTTON_PRESSED
-               && !(ACTUAL_BUTTON_STATUS(3) & BUTTON_RELEASED))
-               {
-                  button_no = 3;
-                  TEMP_BUTTON_STATUS(button_no) = (save_ip.Event.MouseEvent.dwEventFlags)?BUTTON_DOUBLE_CLICKED:BUTTON_PRESSED;
-                  if (TEMP_BUTTON_STATUS(button_no) == BUTTON_PRESSED
-                  && (SP->_trap_mbe) & BUTTON3_PRESSED)
-                     trap_mouse = TRUE;
-                  if (TEMP_BUTTON_STATUS(button_no) == BUTTON_DOUBLE_CLICKED
-                  && (SP->_trap_mbe) & BUTTON3_DOUBLE_CLICKED)
-                     trap_mouse = TRUE;
-                  break;
-               }
-               /*
-                * To get here we have a button release event or another button press
-                * while a current button is pressed. The latter, we throw away. 
-                * We have to use the information from the previous mouse event to 
-                * determine which button was released.
-                */
-               if (last_button_no == 1
-               && (ACTUAL_BUTTON_STATUS(1) & BUTTON_PRESSED
-                   || ACTUAL_BUTTON_STATUS(1) & BUTTON_DOUBLE_CLICKED
-                   || ACTUAL_MOUSE_MOVED)
-               && !(save_ip.Event.MouseEvent.dwButtonState & FROM_LEFT_1ST_BUTTON_PRESSED))
-               {
-                  button_no = 1;
-                  TEMP_BUTTON_STATUS(button_no) = BUTTON_RELEASED;
-                  if ((SP->_trap_mbe) & BUTTON1_RELEASED)
-                     trap_mouse = TRUE;
-                  break;
-               }
-               /*
-                * Check for Right-most button - always button 3
-                */
-               if (last_button_no == 3
-               && (ACTUAL_BUTTON_STATUS(3) & BUTTON_PRESSED
-                  || ACTUAL_BUTTON_STATUS(3) & BUTTON_DOUBLE_CLICKED
-                   || ACTUAL_MOUSE_MOVED)
-               && !(save_ip.Event.MouseEvent.dwButtonState & RIGHTMOST_BUTTON_PRESSED))
-               {
-                  button_no = 3;
-                  TEMP_BUTTON_STATUS(button_no) = BUTTON_RELEASED;
-                  if ((SP->_trap_mbe) & BUTTON3_RELEASED)
-                     trap_mouse = TRUE;
-                  break;
-               }
-               if (SP->num_mouse_buttons == 3)
-               {
-                  /*
-                   * Check for Middle button - button 2 only for 3 button mice
-                   */
-                  if (save_ip.Event.MouseEvent.dwButtonState & FROM_LEFT_2ND_BUTTON_PRESSED
-                  && !(ACTUAL_BUTTON_STATUS(2) & BUTTON_RELEASED))
-                  {
-                     button_no = 2;
-                     TEMP_BUTTON_STATUS(button_no) = (save_ip.Event.MouseEvent.dwEventFlags)?BUTTON_DOUBLE_CLICKED:BUTTON_PRESSED;
-                     if (TEMP_BUTTON_STATUS(button_no) == BUTTON_PRESSED
-                     && (SP->_trap_mbe) & BUTTON3_PRESSED)
-                        trap_mouse = TRUE;
-                     if (TEMP_BUTTON_STATUS(button_no) == BUTTON_DOUBLE_CLICKED
-                     && (SP->_trap_mbe) & BUTTON3_DOUBLE_CLICKED)
-                        trap_mouse = TRUE;
-                     break;
-                  }
-                  if (last_button_no == 2
-                  && (ACTUAL_BUTTON_STATUS(2) & BUTTON_PRESSED
-                     || ACTUAL_BUTTON_STATUS(2) & BUTTON_DOUBLE_CLICKED
-                     || ACTUAL_MOUSE_MOVED)
-                  && !(save_ip.Event.MouseEvent.dwButtonState & FROM_LEFT_2ND_BUTTON_PRESSED))
-                  {
-                     button_no = 2;
-                     TEMP_BUTTON_STATUS(button_no) = BUTTON_RELEASED;
-                     if ((SP->_trap_mbe) & BUTTON2_RELEASED)
-                        trap_mouse = TRUE;
-                     break;
-                    }
-               }
-               /*
-                * If we get here, then we don't know how to handle the event, so
-                * dispose of it
-                */
-               break;
-            }
-            else /* button motion event */
-            {
-               Temp_Mouse_status.changes |= 8;
-               button_no = last_button_no;
-               if (button_no == 1
-               &&  (SP->_trap_mbe) & BUTTON1_MOVED)
-                  trap_mouse = TRUE;
-               if (button_no == 2
-               &&  (SP->_trap_mbe) & BUTTON2_MOVED)
-                  trap_mouse = TRUE;
-               if (button_no == 3
-               &&  (SP->_trap_mbe) & BUTTON3_MOVED)
-                  trap_mouse = TRUE;
-               break;
-            }
-            break;
-         case WINDOW_BUFFER_SIZE_EVENT:
-            return(-1);
-            break;
-         default:
-            break;
-      }
-      if (button_no != 0)
-      {
-         TEMP_MOUSE_X_POS = save_ip.Event.MouseEvent.dwMousePosition.X;
-         TEMP_MOUSE_Y_POS = save_ip.Event.MouseEvent.dwMousePosition.Y;
-         /*
-          * First thing is to check if the mouse has been clicked
-          * on a slk area. If the return value is > 0 (indicating the
-          * label number, return with the KEY_F(key) value.
-          * Only call this if we have set trap_mouse to TRUE above.
-          */
-         if (trap_mouse
-         && (key = PDC_mouse_in_slk(TEMP_MOUSE_Y_POS,TEMP_MOUSE_X_POS)))
-            return(KEY_F(key));
-  
-         Temp_Mouse_status.changes |= (1 << (button_no-1));
-         if (save_ip.Event.MouseEvent.dwControlKeyState & SHIFT_PRESSED)
-            TEMP_BUTTON_STATUS(button_no) |= BUTTON_SHIFT;
-         if (save_ip.Event.MouseEvent.dwControlKeyState & LEFT_CTRL_PRESSED)
-            TEMP_BUTTON_STATUS(button_no) |= BUTTON_CONTROL;
-         if (save_ip.Event.MouseEvent.dwControlKeyState & RIGHT_CTRL_PRESSED)
-            TEMP_BUTTON_STATUS(button_no) |= BUTTON_CONTROL;
-         if (save_ip.Event.MouseEvent.dwControlKeyState & RIGHT_ALT_PRESSED)
-            TEMP_BUTTON_STATUS(button_no) |= BUTTON_ALT;
-         if (save_ip.Event.MouseEvent.dwControlKeyState & LEFT_ALT_PRESSED)
-            TEMP_BUTTON_STATUS(button_no) |= BUTTON_ALT;
-         last_button_no = button_no;
-         /*
-          * We now have the current mouse status information for the last
-          * Mouse event.  We need to save this in Actual_Mouse_status so
-          * we can use that when comparing against the next mouse event.
-          * We also need to determine if we need to set Trapped_Mouse_status
-          * based on the settings in SP->_trap_mbe.
-          */
-         memcpy((char*)&Actual_Mouse_status,(char*)&Temp_Mouse_status,sizeof(MOUSE_STATUS));
-         if (trap_mouse)
-            break;
-      }
-   }
-   /*
-    * To get here we have a mouse event that has been trapped by the
-    * user. Save it in the Trapped_Mouse_status structure.
-    */
-   memcpy((char*)&Trapped_Mouse_status,(char*)&Temp_Mouse_status,sizeof(MOUSE_STATUS));
-   return(KEY_MOUSE);
-}
-
-/*man-start*********************************************************************
-
-  PDC_get_ctrl_break()  - return OS control break state
-
-  PDCurses Description:
-   This is a private PDCurses routine.
-
-   Returns the current OS Control Break Check state.
-
-  PDCurses Return Value:
-   DOS:
-      This function returns TRUE if the Control Break
-      Check is enabled otherwise FALSE is returned.
-
-   FLEXOS:
-      This function returns TRUE on if the Keyboard Mode
-      allows a break to bre reported otherwise FALSE is returned.
-
-  PDCurses Errors:
-   No errors are defined for this function.
-
-  Portability:
-   PDCurses bool  PDC_get_ctrl_break( void );
-
-**man-end**********************************************************************/
-
-bool  PDC_get_ctrl_break(void)
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_get_ctrl_break() - called\n");
-#endif
-   return FALSE;
-}
-
-/*man-start*********************************************************************
-
-  PDC_rawgetch()  - Returns the next uninterpreted character (if available).
-
-  PDCurses Description:
-   Gets a character without any interpretation at all and returns
-   it. If keypad mode is active for the designated window,
-   function key translation will be performed.  Otherwise,
-   function keys are ignored.  If nodelay mode is active in the
-   window, then PDC_rawgetch() returns -1 if no character is
-   available.
-
-   WARNING:  It is unknown whether the FUNCTION key translation
-        is performed at this level. --Frotz 911130 BUG
-
-  PDCurses Return Value:
-   This function returns OK on success and ERR on error.
-
-  PDCurses Errors:
-   No errors are defined for this function.
-
-  Portability:
-   PDCurses int   PDC_rawgetch( void );
-
-**man-end**********************************************************************/
-
-int   PDC_rawgetch(void)
-{
-   extern   WINDOW*  _getch_win_;
-
-   int   c=0;
-   int   oldc=0;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_rawgetch() - called\n");
-#endif
-
-   if (_getch_win_ == (WINDOW *)NULL)   /* @@ */
-      return( -1 );
-
-   if (_getch_win_->_nodelay && !PDC_breakout()) /* @@ */
-      return( -1 );
-
-   while (1)      /* loop to get valid char */
-   {
-      c = PDC_get_bios_key();
-      oldc = c;
-      /*
-       * Return the key if it is not a special key.
-       */
-      if (c != KEY_MOUSE
-      && (c = PDC_validchar(c)) >= 0)
-      {     /* get & check next char */
-         return( c );
-      }
-      if (_getch_win_->_use_keypad)
-         return( oldc );
-   }
-   return( -1 );
-}
-
-/*man-start*********************************************************************
-
-  PDC_set_ctrl_break()  - Enables/Disables the host OS BREAK key check.
-
-  PDCurses Description:
-   This is a private PDCurses routine.
-
-   Enables/Disables the host OS BREAK key check. If the supplied setting
-   is TRUE, this enables CTRL/C and CTRL/BREAK to abort the process.
-   If FALSE, CTRL/C and CTRL/BREAK are ignored.
-
-  PDCurses Return Value:
-   This function returns OK on success and ERR on error.
-
-  PDCurses Errors:
-   No errors are defined for this function.
-
-  Portability:
-   PDCurses int PDC_set_ctrl_break( bool setting );
-
-**man-end**********************************************************************/
-
-int   PDC_set_ctrl_break(bool setting)
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_set_ctrl_break() - called\n");
-#endif
-
-   return(OK);
-}
-
-/*man-start*********************************************************************
-
-  PDC_sysgetch()  - Return a character using default system routines.
-
-  PDCurses Description:
-   This is a private PDCurses function.
-
-   Gets a character without normal ^S, ^Q, ^P and ^C interpretation
-   and returns it.  If keypad mode is active for the designated
-   window, function key translation will be performed. Otherwise,
-   function keys are ignored. If nodelay mode is active in the
-   window, then sysgetch() returns -1 if no character is
-   available.
-
-  PDCurses Return Value:
-   This function returns OK upon success otherwise ERR is returned.
-
-  PDCurses Errors:
-   No errors are defined for this routine.
-
-  Portability:
-   PDCurses int   PDC_sysgetch( void );
-
-**man-end**********************************************************************/
-
-int   PDC_sysgetch(void)
-{
-   extern   WINDOW*  _getch_win_;
-
-   int c=0;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_sysgetch() - called\n");
-#endif
-
-   if (_getch_win_ == (WINDOW *)NULL)  /* @@ */
-      return (-1);
-
-   if (_getch_win_->_nodelay && !PDC_breakout())
-      return (-1);
-
-   while (1)
-   {
-      c = PDC_get_bios_key();
-      /*
-       * Return the key if it is not a special key.
-       */
-      if ((unsigned int)c < 256)
-         return(c);
-      if ((c = PDC_validchar(c)) >= 0)
-      {
-         return (c);      /* get & check next char */
-      }
-   }
-   return( -1 );
-}
-
-
-/*man-start*********************************************************************
-
-  PDC_validchar() - validate/translate passed character
-  
-  PDCurses Description:
-   This is a private PDCurses function.
-  
-   Checks that 'c' is a valid character, and if so returns it,
-   with function key translation applied if 'w' has keypad mode
-   set.  If char is invalid, returns -1.
-  
-  PDCurses Return Value:
-   This function returns -1 if the passed character is invalid, or
-   the WINDOW* 'w' is NULL, or 'w's keypad is not active.
-  
-   This function returns 0 under Flexos if the passed character
-   is 0x0300.  (-:Forget why.  --Frotz 911130:-)
-  
-   Otherwise, this function returns the PDCurses equivalent of the
-   passed character.  See the function key and key macros in
-   <curses.h>
-  
-  PDCurses Errors:
-   There are no errors defined for this routine.
-  
-  Portability:
-   PDCurses int   PDC_validchar( int c );
-
-**man-end**********************************************************************/
-
-int   PDC_validchar(int c)
-{
-   extern   WINDOW*  _getch_win_;
-   int ch=c;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_validchar() - called\n");
-#endif
-
-   if (_getch_win_ == (WINDOW *)NULL)
-      ch = (-1);   /* bad window pointer     */
-   else if ((unsigned int)c < 256) 
-      ch = c;      /* normal character */
-   else if (!(_getch_win_->_use_keypad)) 
-      ch = (-1);   /* skip if keys if !keypad mode */
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_validchar() - returned: %x\n",ch);
-#endif
-   return(ch);
-}
-
-/***********************************************************************/
-static int GetInterestingEvent( INPUT_RECORD *ip )
-/***********************************************************************/
-{
-   int numKeys = 0;
-   static int save_press;
-#ifdef PDCDEBUG
-#if defined(PDC_THREAD_BUILD)
-#  define PDC_DEBUG_THREADING1 "-->"
-#  define PDC_DEBUG_THREADING2 "THREADING"
-# else
-#  define PDC_DEBUG_THREADING1 ""
-#  define PDC_DEBUG_THREADING2 ""
-# endif
-   char *ptr="";
-   if (trace_on) PDC_debug("%sGetInterestingEvent(%s) - called\n",PDC_DEBUG_THREADING1,PDC_DEBUG_THREADING2);
-#endif
-
-   switch(ip->EventType)
-   {
-      case KEY_EVENT:
-         if (ip->Event.KeyEvent.wVirtualKeyCode == 20
-          ||  ip->Event.KeyEvent.wVirtualKeyCode == 144
-          ||  ip->Event.KeyEvent.wVirtualKeyCode == 145)
-         {
-#ifdef PDCDEBUG
-            ptr = "KEY MODIFIERS";
-#endif
-            break;  /* throw away some modifiers */
-         }
-         if (ip->Event.KeyEvent.bKeyDown == FALSE)
-         {
-            /* key up */
-            if ((ip->Event.KeyEvent.wVirtualKeyCode == 16
-            ||  ip->Event.KeyEvent.wVirtualKeyCode == 17
-            ||  ip->Event.KeyEvent.wVirtualKeyCode == 18)
-            &&  ip->Event.KeyEvent.wVirtualKeyCode == save_press
-            &&  SP->return_key_modifiers)
-#ifdef PDCDEBUG
-               ptr = "KEYUP WANTED";
-#else
-               ;
-#endif
-            else
-            {
-#ifdef PDCDEBUG
-               ptr = "KEYUP IGNORED";
-#endif
-               break;                    /* throw away KeyUp events */
-            }
-         }
-         else
-         {
-            if ((ip->Event.KeyEvent.wVirtualKeyCode == 16
-            ||  ip->Event.KeyEvent.wVirtualKeyCode == 17
-            ||  ip->Event.KeyEvent.wVirtualKeyCode == 18)
-            &&  SP->return_key_modifiers)
-            {
-               save_press = ip->Event.KeyEvent.wVirtualKeyCode;
-#ifdef PDCDEBUG
-               ptr = "KEYDOWN SAVED";
-#endif
-               break; /* throw away key press */
-            }
-         }
-         save_press = 0;
-         if (ip->Event.KeyEvent.uChar.AsciiChar == 0 &&
-             (MapVirtualKey(ip->Event.KeyEvent.wVirtualKeyCode,2) & 0x80000000))
-         {
-#ifdef PDCDEBUG
-            ptr = "DIACRITIC IGNORED";
-#endif
-            break;              /* Diacritic characters, ignore them */
-         }
-#ifdef PDCDEBUG
-         ptr = "KEY WANTED";
-#endif
-         numKeys = ip->Event.KeyEvent.wRepeatCount;
-         break;
-      case MOUSE_EVENT:
-         /*
-          * If we aren't trapping mouse events, then the "keyboard" hasn't
-          * been hit. Fix from stepheng@clearspeed.com
-          */
-         if (!SP->_trap_mbe)
-         {
-#ifdef PDCDEBUG
-            ptr = "MOUSE - NOT TRAPPED";
-#endif
-            break;
-         }
-         if (ip->Event.MouseEvent.dwEventFlags == MS_MOUSE_MOVED
-         &&  ip->Event.MouseEvent.dwButtonState == 0)
-         {
-#ifdef PDCDEBUG
-            ptr = "MOUSE MOVE IGNORED";
-#endif
-            break;               /* throw away plain MOUSE_MOVE events */
-         }
-#ifdef PDCDEBUG
-         ptr = "MOUSE MOVE WANTED";
-#endif
-         numKeys = 1;
-         break;
-      case WINDOW_BUFFER_SIZE_EVENT:
-  /*
-         PDC_resize_screen( PDC_get_rows(), PDC_get_columns() );
-  */
-         SP->resized = TRUE;
-#ifdef PDCDEBUG
-         ptr = "BUFFER SIZE";
-#endif
-         numKeys = 0; /* was 1 */
-         break;
-      default:
-#ifdef PDCDEBUG
-         ptr = "UNKNOWN";
-#endif
-         numKeys = 0;
-         break;
-   }
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("%sGetInterestingEvent(%s) - returning: numKeys %d type %d: %s\n",PDC_DEBUG_THREADING1,PDC_DEBUG_THREADING2,numKeys,ip->EventType,ptr);
-#endif
-   return numKeys;
-}
-
-#if defined(PDC_THREAD_BUILD)
-/***********************************************************************/
-static int win32_kbhit(int timeout)
-/***********************************************************************/
-{
-   DWORD read=0,avail=0,unread=0;
-   INPUT_RECORD ip;
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("win32_kbhit(THREADING) - called: timeout %d\n", timeout);
-#endif
-
-
-#if 0
-   if ( timeout == INFINITE )
-   {
-      ReadFile( hPipeRead, &save_ip, sizeof(INPUT_RECORD), &read, NULL );
-      return TRUE;
-   }
-   else
-   {
-      if ( WaitForSingleObject( hSemKeyCount, timeout ) != WAIT_OBJECT_0 )
-      {
-         return FALSE;
-      }
-      if ( PeekNamedPipe( hPipeRead, &ip, sizeof(INPUT_RECORD), &read, &avail, &unread ) )
-      {
-#ifdef PDCDEBUG
-         if (trace_on) PDC_debug("win32_kbhit(THREADING) - maybe key on pipe. read %d avail %d unread %d\n",read,avail,unread);
-#endif
-         if ( read == sizeof(INPUT_RECORD) )
-            return TRUE;
-      }
-   }
-#else
-   if ( WaitForSingleObject( hSemKeyCount, timeout ) != WAIT_OBJECT_0 )
-   {
-      return FALSE;
-   }
-   if ( timeout == INFINITE )
-   {
-      ReadFile( hPipeRead, &save_ip, sizeof(INPUT_RECORD), &read, NULL );
-      return TRUE;
-   }
-   else
-   {
-      if ( PeekNamedPipe( hPipeRead, &ip, sizeof(INPUT_RECORD), &read, &avail, &unread ) )
-      {
-#ifdef PDCDEBUG
-         if (trace_on) PDC_debug("win32_kbhit(THREADING) - maybe key on pipe. read %d avail %d unread %d\n",read,avail,unread);
-#endif
-         if ( read == sizeof(INPUT_RECORD) )
-            return TRUE;
-      }
-   }
-#endif
-   return FALSE;
-}
-
-
-/***********************************************************************/
-static void win32_getch(void)
-/***********************************************************************/
-{
-   while (win32_kbhit(INFINITE) == FALSE)
-      ;
-
-   return;
-}
-#else
-
-/***********************************************************************/
-static int win32_kbhit(int timeout)
-/***********************************************************************/
-{
-   INPUT_RECORD ip;
-   DWORD read, avail;
-   int rc=FALSE;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("win32_kbhit() - called: timeout %d keyCount %d\n", timeout, keyCount);
-#endif
-  
-   if (keyCount > 0)
-      return TRUE;
-  
-   if (WaitForSingleObject(hConIn, timeout) != WAIT_OBJECT_0)
-   {
-      return FALSE;
-   }
-  
-   PeekConsoleInput(hConIn, &ip, 1, &read);
-   if (read == 0)
-      return(FALSE);
-   ReadConsoleInput(hConIn, &ip, 1, &read);
-
-   keyCount = GetInterestingEvent( &ip );
-   if ( keyCount )
-   {
-      /*
-       * To get here a recognised event has occurred; save it and return TRUE
-       */
-      memcpy( (char*)&save_ip, (char*)&ip, sizeof(INPUT_RECORD) );
-      rc = TRUE;
-   }
-   return(rc);
-}
-
-/***********************************************************************/
-static void win32_getch(void)
-/***********************************************************************/
-{
-   while (win32_kbhit(INFINITE) == FALSE)
-      ;
-
-   keyCount --;
-
-   return;
-}
-#endif
-
-/*man-start*********************************************************************
-
-  PDC_get_key_modifiers()  - Returns the keyboard modifier(s) at time of last getch()
-
-  PDCurses Description:
-   This is a private PDCurses routine.
-
-   Returns the keyboard modifiers effective at the time of the last getch()
-   call only if PDC_save_key_modifiers(TRUE) has been called before the
-   getch();
-   Use the macros; PDC_KEY_MODIFIER_* to determine which modifier(s)
-   were set.
-
-  PDCurses Return Value:
-   This function returns the modifiers.
-
-  PDCurses Errors:
-   No errors are defined for this function.
-
-  Portability:
-   PDCurses int PDC_get_key_modifiers( void );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-unsigned long  PDC_get_key_modifiers(void)
-#else
-unsigned long  PDC_get_key_modifiers()
-#endif
-/***********************************************************************/
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_get_key_modifiers() - called\n");
-#endif
-   return(pdc_key_modifiers);
-}
-
-
-#if defined(PDC_THREAD_BUILD)
-/***********************************************************************/
-LONG InputThread( LPVOID lpThreadData )
-/***********************************************************************/
-{
-   INPUT_RECORD ip;
-   DWORD read;
-   LONG prev;
-   int num_keys,i;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("-->InputThread() - called\n");
-#endif
-   /*
-    * Create a semaphore on which the parent thread will wait...
-    */
-   hSemKeyCount = CreateSemaphore( NULL, 0, 1024, NULL );
-   if ( hSemKeyCount != NULL )
-   {
-      for ( ; ; )
-      {
-         ReadConsoleInput(hConIn, &ip, 1, &read);
-         /*
-          * Now that this thread has woken up we need to check if the
-          * key/mouse event is relevant to us. If so, write it to the
-          * anonymous pipe.
-          */
-#ifdef PDCDEBUG
-         if (trace_on) PDC_debug("-->InputThread() - read %d character(s)\n",read);
-#endif
-         num_keys = GetInterestingEvent( &ip );
-#ifdef PDCDEBUG
-         if (trace_on) PDC_debug("-->InputThread() - got %d interesting keys\n",num_keys);
-#endif
-         for ( i = 0; i < num_keys; i++ )
-         {
-            /*
-             * For each key written to the pipe, increment the semaphore...
-             */
-            if ( ReleaseSemaphore( hSemKeyCount, 1, &prev ) )
-            {
-#ifdef PDCDEBUG
-               if (trace_on) PDC_debug("-->InputThread() - writing to pipe; sem incremented from %d\n",prev);
-#endif
-               if ( !WriteFile( hPipeWrite, &ip, sizeof(INPUT_RECORD), &read, NULL ) )
-               {
-                  /*
-                   * An error occured, we assume it is because the pipe broke;
-                   * therefore the parent thread is shutting down; so will we.
-                   */
-                  break;
-               }
-            }
-         }
-      }
-   }
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("-->InputThread() - finished\n");
-#endif
-   return 0;
-}
-#endif
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+
+#define  CURSES_LIBRARY 1
+#define  INCLUDE_WINDOWS_H
+#include <curses.h>
+
+#include <stdio.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCkbd  = "$Id: pdckbd.c,v 1.9 2002/12/16 09:40:36 mark Exp $";
+#endif
+
+#define KEY_STATE TRUE
+
+/*
+ * MingW32 header files are missing the following in some versions
+ * of the compiler
+ */
+#ifndef DOUBLE_CLICK
+# define DOUBLE_CLICK 0x0002
+#endif
+
+#ifndef FROM_LEFT_1ST_BUTTON_PRESSED
+# define FROM_LEFT_1ST_BUTTON_PRESSED 0x0001
+#endif
+
+#ifndef FROM_LEFT_2ND_BUTTON_PRESSED
+# define FROM_LEFT_2ND_BUTTON_PRESSED 0x0004
+#endif
+
+#ifndef RIGHTMOST_BUTTON_PRESSED
+# define RIGHTMOST_BUTTON_PRESSED 0x0002
+#endif
+/*
+ * These variables are used to store information about the next 
+ * Input Event.
+ */
+INPUT_RECORD save_ip;
+static unsigned long pdc_key_modifiers=0L;
+
+extern HANDLE hConIn;
+
+#if defined(PDC_THREAD_BUILD)
+extern HANDLE hPipeRead;
+extern HANDLE hPipeWrite;
+extern HANDLE hSemKeyCount;
+#else
+static int keyCount = 0;
+#endif
+
+static void win32_getch(void);
+static int win32_kbhit(int);
+
+/*******************************************************************************
+*  Table for key code translation of function keys in keypad mode
+*  These values are for strict IBM keyboard compatibles only
+*******************************************************************************/
+
+typedef struct 
+{
+   int normal;
+   int shift;
+   int control;
+   int alt;
+   int extended;
+} KPTAB;
+
+static KPTAB kptab[] =
+{
+   {0,          0,          0,           0,          0           }, /* 0 */
+   {0,          0,          0,           0,          0           }, /* 1 */
+   {0,          0,          0,           0,          0           }, /* 2 */
+   {0,          0,          0,           0,          0           }, /* 3 */
+   {0,          0,          0,           0,          0           }, /* 4 */
+   {0,          0,          0,           0,          0           }, /* 5 */
+   {0,          0,          0,           0,          0           }, /* 6 */
+   {0,          0,          0,           0,          0           }, /* 7 */
+   {0x08,       0x08,       0x7F,        ALT_BKSP,   0           }, /* 8 */
+   {0x09,       KEY_BTAB,   CTL_TAB,     ALT_TAB,    999         }, /* 9 */
+   {0,          0,          0,           0,          0           }, /* 10 */
+   {0,          0,          0,           0,          0           }, /* 11 */
+   {KEY_B2,     0x35,       CTL_PAD5,    ALT_PAD5,   0           }, /* 12 */
+   {0x0D,       0x0D,       CTL_ENTER,   ALT_ENTER,  1           }, /* 13 */
+   {0,          0,          0,           0,          0           }, /* 14 */
+   {0,          0,          0,           0,          0           }, /* 15 */
+   {0,          0,          0,           0,          0           }, /* 16 */
+   {0,          0,          0,           0,          0           }, /* 17 */
+   {0,          0,          0,           0,          0           }, /* 18 */
+   {0,          0,          0,           0,          0           }, /* 19 */
+   {0,          0,          0,           0,          0           }, /* 20 */
+   {0,          0,          0,           0,          0           }, /* 21 */
+   {0,          0,          0,           0,          0           }, /* 22 */
+   {0,          0,          0,           0,          0           }, /* 23 */
+   {0,          0,          0,           0,          0           }, /* 24 */
+   {0,          0,          0,           0,          0           }, /* 25 */
+   {0,          0,          0,           0,          0           }, /* 26 */
+   {0x1B,       0x1B,       0x1B,        ALT_ESC,    0           }, /* 27 */
+   {0,          0,          0,           0,          0           }, /* 28 */
+   {0,          0,          0,           0,          0           }, /* 29 */
+   {0,          0,          0,           0,          0           }, /* 30 */
+   {0,          0,          0,           0,          0           }, /* 31 */
+   {0x20,       0x20,       0x20,        0x20,       0           }, /* 32 */
+   {KEY_A3,     0x39,       CTL_PAD9,    ALT_PAD9,   3           }, /* 33 */
+   {KEY_C3,     0x33,       CTL_PAD3,    ALT_PAD3,   4           }, /* 34 */
+   {KEY_C1,     0x31,       CTL_PAD1,    ALT_PAD1,   5           }, /* 35 */
+   {KEY_A1,     0x37,       CTL_PAD7,    ALT_PAD7,   6           }, /* 36 */
+   {KEY_B1,     0x34,       CTL_PAD4,    ALT_PAD4,   7           }, /* 37 */
+   {KEY_A2,     0x38,       CTL_PAD8,    ALT_PAD8,   8           }, /* 38 */
+   {KEY_B3,     0x36,       CTL_PAD6,    ALT_PAD6,   9           }, /* 39 */
+   {KEY_C2,     0x32,       CTL_PAD2,    ALT_PAD2,   10          }, /* 40 */
+   {0,          0,          0,           0,          0           }, /* 41 */
+   {0,          0,          0,           0,          0           }, /* 42 */
+   {0,          0,          0,           0,          0           }, /* 43 */
+   {0,          0,          0,           0,          0           }, /* 44 */
+   {PAD0,       0x30,       CTL_PAD0,    ALT_PAD0,   11          }, /* 45 */
+   {PADSTOP,    0x2E,       CTL_PADSTOP, ALT_PADSTOP,12          }, /* 46 */
+   {0,          0,          0,           0,          0           }, /* 47 */
+   {0x30,       0x29,       0,           ALT_0,      0           }, /* 48 */
+   {0x31,       0x21,       0,           ALT_1,      0           }, /* 49 */
+   {0x32,       0x40,       0,           ALT_2,      0           }, /* 50 */
+   {0x33,       0x23,       0,           ALT_3,      0           }, /* 51 */
+   {0x34,       0x24,       0,           ALT_4,      0           }, /* 52 */
+   {0x35,       0x25,       0,           ALT_5,      0           }, /* 53 */
+   {0x36,       0x5E,       0,           ALT_6,      0           }, /* 54 */
+   {0x37,       0x26,       0,           ALT_7,      0           }, /* 55 */
+   {0x38,       0x2A,       0,           ALT_8,      0           }, /* 56 */
+   {0x39,       0x28,       0,           ALT_9,      0           }, /* 57 */
+   {0,          0,          0,           0,          0           }, /* 58 */
+   {0,          0,          0,           0,          0           }, /* 59 */
+   {0,          0,          0,           0,          0           }, /* 60 */
+   {0,          0,          0,           0,          0           }, /* 61 */
+   {0,          0,          0,           0,          0           }, /* 62 */
+   {0,          0,          0,           0,          0           }, /* 63 */
+   {0,          0,          0,           0,          0           }, /* 64 */
+   {0x61,       0x41,       0x01,        ALT_A,      0           }, /* 65 */
+   {0x62,       0x42,       0x02,        ALT_B,      0           }, /* 66 */
+   {0x63,       0x43,       0x03,        ALT_C,      0           }, /* 67 */
+   {0x64,       0x44,       0x04,        ALT_D,      0           }, /* 68 */
+   {0x65,       0x45,       0x05,        ALT_E,      0           }, /* 69 */
+   {0x66,       0x46,       0x06,        ALT_F,      0           }, /* 70 */
+   {0x67,       0x47,       0x07,        ALT_G,      0           }, /* 71 */
+   {0x68,       0x48,       0x08,        ALT_H,      0           }, /* 72 */
+   {0x69,       0x49,       0x09,        ALT_I,      0           }, /* 73 */
+   {0x6A,       0x4A,       0x0A,        ALT_J,      0           }, /* 74 */
+   {0x6B,       0x4B,       0x0B,        ALT_K,      0           }, /* 75 */
+   {0x6C,       0x4C,       0x0C,        ALT_L,      0           }, /* 76 */
+   {0x6D,       0x4D,       0x0D,        ALT_M,      0           }, /* 77 */
+   {0x6E,       0x4E,       0x0E,        ALT_N,      0           }, /* 78 */
+   {0x6F,       0x4F,       0x0F,        ALT_O,      0           }, /* 79 */
+   {0x70,       0x50,       0x10,        ALT_P,      0           }, /* 80 */
+   {0x71,       0x51,       0x11,        ALT_Q,      0           }, /* 81 */
+   {0x72,       0x52,       0x12,        ALT_R,      0           }, /* 82 */
+   {0x73,       0x53,       0x13,        ALT_S,      0           }, /* 83 */
+   {0x74,       0x54,       0x14,        ALT_T,      0           }, /* 84 */
+   {0x75,       0x55,       0x15,        ALT_U,      0           }, /* 85 */
+   {0x76,       0x56,       0x16,        ALT_V,      0           }, /* 86 */
+   {0x77,       0x57,       0x17,        ALT_W,      0           }, /* 87 */
+   {0x78,       0x58,       0x18,        ALT_X,      0           }, /* 88 */
+   {0x79,       0x59,       0x19,        ALT_Y,      0           }, /* 89 */
+   {0x7A,       0x5A,       0x1A,        ALT_Z,      0           }, /* 90 */
+   {0,          0,          0,           0,          0           }, /* 91 */
+   {0,          0,          0,           0,          0           }, /* 92 */
+   {0,          0,          0,           0,          0           }, /* 93 */
+   {0,          0,          0,           0,          0           }, /* 94 */
+   {0,          0,          0,           0,          0           }, /* 95 */
+   {0x30,       0,          CTL_PAD0,    ALT_PAD0,   0           }, /* 96 */
+   {0x31,       0,          CTL_PAD1,    ALT_PAD1,   0           }, /* 97 */
+   {0x32,       0,          CTL_PAD2,    ALT_PAD2,   0           }, /* 98 */
+   {0x33,       0,          CTL_PAD3,    ALT_PAD3,   0           }, /* 99 */
+   {0x34,       0,          CTL_PAD4,    ALT_PAD4,   0           }, /* 100 */
+   {0x35,       0,          CTL_PAD5,    ALT_PAD5,   0           }, /* 101 */
+   {0x36,       0,          CTL_PAD6,    ALT_PAD6,   0           }, /* 102 */
+   {0x37,       0,          CTL_PAD7,    ALT_PAD7,   0           }, /* 103 */
+   {0x38,       0,          CTL_PAD8,    ALT_PAD8,   0           }, /* 104 */
+   {0x39,       0,          CTL_PAD9,    ALT_PAD9,   0           }, /* 105 */
+   {PADSTAR,    SHF_PADSTAR,CTL_PADSTAR, ALT_PADSTAR,999         }, /* 106 */
+   {PADPLUS,    SHF_PADPLUS,CTL_PADPLUS, ALT_PADPLUS,999         }, /* 107 */
+   {0,          0,          0,           0,          0           }, /* 108 */
+   {PADMINUS,   SHF_PADMINUS,CTL_PADMINUS,ALT_PADMINUS,999       }, /* 109 */
+   {0x2E,       0,          CTL_PADSTOP, ALT_PADSTOP,0           }, /* 110 */
+   {PADSLASH,   SHF_PADSLASH,CTL_PADSLASH,ALT_PADSLASH,2         }, /* 111 */
+   {KEY_F(1),   KEY_F(13),  KEY_F(25),   KEY_F(37),  0           }, /* 112 */
+   {KEY_F(2),   KEY_F(14),  KEY_F(26),   KEY_F(38),  0           }, /* 113 */
+   {KEY_F(3),   KEY_F(15),  KEY_F(27),   KEY_F(39),  0           }, /* 114 */
+   {KEY_F(4),   KEY_F(16),  KEY_F(28),   KEY_F(40),  0           }, /* 115 */
+   {KEY_F(5),   KEY_F(17),  KEY_F(29),   KEY_F(41),  0           }, /* 116 */
+   {KEY_F(6),   KEY_F(18),  KEY_F(30),   KEY_F(42),  0           }, /* 117 */
+   {KEY_F(7),   KEY_F(19),  KEY_F(31),   KEY_F(43),  0           }, /* 118 */
+   {KEY_F(8),   KEY_F(20),  KEY_F(32),   KEY_F(44),  0           }, /* 119 */
+   {KEY_F(9),   KEY_F(21),  KEY_F(33),   KEY_F(45),  0           }, /* 120 */
+   {KEY_F(10),  KEY_F(22),  KEY_F(34),   KEY_F(46),  0           }, /* 121 */
+   {KEY_F(11),  KEY_F(23),  KEY_F(35),   KEY_F(47),  0           }, /* 122 */
+   {KEY_F(12),  KEY_F(24),  KEY_F(36),   KEY_F(48),  0           }, /* 123 */
+   {0,          0,          0,           0,          0           }, /* 124 */
+   {0,          0,          0,           0,          0           }, /* 125 */
+   {0,          0,          0,           0,          0           }, /* 126 */
+   {0,          0,          0,           0,          0           }, /* 127 */
+   {0,          0,          0,           0,          0           }, /* 128 */
+   {0,          0,          0,           0,          0           }, /* 129 */
+   {0,          0,          0,           0,          0           }, /* 130 */
+   {0,          0,          0,           0,          0           }, /* 131 */
+   {0,          0,          0,           0,          0           }, /* 132 */
+   {0,          0,          0,           0,          0           }, /* 133 */
+   {0,          0,          0,           0,          0           }, /* 134 */
+   {0,          0,          0,           0,          0           }, /* 135 */
+   {0,          0,          0,           0,          0           }, /* 136 */
+   {0,          0,          0,           0,          0           }, /* 137 */
+   {0,          0,          0,           0,          0           }, /* 138 */
+   {0,          0,          0,           0,          0           }, /* 139 */
+   {0,          0,          0,           0,          0           }, /* 140 */
+   {0,          0,          0,           0,          0           }, /* 141 */
+   {0,          0,          0,           0,          0           }, /* 142 */
+   {0,          0,          0,           0,          0           }, /* 143 */
+   {0,          0,          0,           0,          0           }, /* 144 */
+   {0,          0,          0,           0,          0           }, /* 145 */
+   {0,          0,          0,           0,          0           }, /* 146 */
+   {0,          0,          0,           0,          0           }, /* 147 */
+   {0,          0,          0,           0,          0           }, /* 148 */
+   {0,          0,          0,           0,          0           }, /* 149 */
+   {0,          0,          0,           0,          0           }, /* 150 */
+   {0,          0,          0,           0,          0           }, /* 151 */
+   {0,          0,          0,           0,          0           }, /* 152 */
+   {0,          0,          0,           0,          0           }, /* 153 */
+   {0,          0,          0,           0,          0           }, /* 154 */
+   {0,          0,          0,           0,          0           }, /* 155 */
+   {0,          0,          0,           0,          0           }, /* 156 */
+   {0,          0,          0,           0,          0           }, /* 157 */
+   {0,          0,          0,           0,          0           }, /* 158 */
+   {0,          0,          0,           0,          0           }, /* 159 */
+   {0,          0,          0,           0,          0           }, /* 160 */
+   {0,          0,          0,           0,          0           }, /* 161 */
+   {0,          0,          0,           0,          0           }, /* 162 */
+   {0,          0,          0,           0,          0           }, /* 163 */
+   {0,          0,          0,           0,          0           }, /* 164 */
+   {0,          0,          0,           0,          0           }, /* 165 */
+   {0,          0,          0,           0,          0           }, /* 166 */
+   {0,          0,          0,           0,          0           }, /* 167 */
+   {0,          0,          0,           0,          0           }, /* 168 */
+   {0,          0,          0,           0,          0           }, /* 169 */
+   {0,          0,          0,           0,          0           }, /* 170 */
+   {0,          0,          0,           0,          0           }, /* 171 */
+   {0,          0,          0,           0,          0           }, /* 172 */
+   {0,          0,          0,           0,          0           }, /* 173 */
+   {0,          0,          0,           0,          0           }, /* 174 */
+   {0,          0,          0,           0,          0           }, /* 175 */
+   {0,          0,          0,           0,          0           }, /* 176 */
+   {0,          0,          0,           0,          0           }, /* 177 */
+   {0,          0,          0,           0,          0           }, /* 178 */
+   {0,          0,          0,           0,          0           }, /* 179 */
+   {0,          0,          0,           0,          0           }, /* 180 */
+   {0,          0,          0,           0,          0           }, /* 181 */
+   {0,          0,          0,           0,          0           }, /* 182 */
+   {0,          0,          0,           0,          0           }, /* 183 */
+   {0,          0,          0,           0,          0           }, /* 184 */
+   {0,          0,          0,           0,          0           }, /* 185 */
+   {0x3B,       0x3A,       0x3B,        ALT_SEMICOLON,0,        }, /* 186 */
+   {0x3D,       0x2B,       0x3D,        ALT_EQUAL,  0           }, /* 187 */
+   {0x2C,       0x3C,       0x2C,        ALT_COMMA,  0           }, /* 188 */
+   {0x2D,       0x5F,       0x2D,        0x2D,       0           }, /* 189 */
+   {0x2E,       0x3E,       0x2E,        ALT_STOP,   0           }, /* 190 */
+   {0x2F,       0x3F,       0x2F,        ALT_FSLASH, 13          }, /* 191 */
+   {0x60,       0x7E,       0x60,        ALT_BQUOTE, 0           }, /* 192 */
+   {0,          0,          0,           0,          0           }, /* 193 */
+   {0,          0,          0,           0,          0           }, /* 194 */
+   {0,          0,          0,           0,          0           }, /* 195 */
+   {0,          0,          0,           0,          0           }, /* 196 */
+   {0,          0,          0,           0,          0           }, /* 197 */
+   {0,          0,          0,           0,          0           }, /* 198 */
+   {0,          0,          0,           0,          0           }, /* 199 */
+   {0,          0,          0,           0,          0           }, /* 200 */
+   {0,          0,          0,           0,          0           }, /* 201 */
+   {0,          0,          0,           0,          0           }, /* 202 */
+   {0,          0,          0,           0,          0           }, /* 203 */
+   {0,          0,          0,           0,          0           }, /* 204 */
+   {0,          0,          0,           0,          0           }, /* 205 */
+   {0,          0,          0,           0,          0           }, /* 206 */
+   {0,          0,          0,           0,          0           }, /* 207 */
+   {0,          0,          0,           0,          0           }, /* 208 */
+   {0,          0,          0,           0,          0           }, /* 209 */
+   {0,          0,          0,           0,          0           }, /* 210 */
+   {0,          0,          0,           0,          0           }, /* 211 */
+   {0,          0,          0,           0,          0           }, /* 212 */
+   {0,          0,          0,           0,          0           }, /* 213 */
+   {0,          0,          0,           0,          0           }, /* 214 */
+   {0,          0,          0,           0,          0           }, /* 215 */
+   {0,          0,          0,           0,          0           }, /* 216 */
+   {0,          0,          0,           0,          0           }, /* 217 */
+   {0,          0,          0,           0,          0           }, /* 218 */
+   {0x5B,       0x7B,       0x1B,        ALT_LBRACKET,0          }, /* 219 */
+   {0x5C,       0x7C,       0x1C,        ALT_BSLASH, 0           }, /* 220 */
+   {0x5D,       0x7D,       0x1D,        ALT_RBRACKET,0          }, /* 221 */
+   {0,          0,          0x27,        ALT_FQUOTE, 0           }, /* 222 */
+   {0,          0,          0,           0,          0           }, /* 223 */
+   {0,          0,          0,           0,          0           }, /* 224 */
+   {0,          0,          0,           0,          0           }  /* 225 */
+};
+
+static KPTAB ext_kptab[] =
+{
+   {0,          0,          0,           0,          }, /* MUST BE EMPTY */
+   {PADENTER,   SHF_PADENTER,   CTL_PADENTER,ALT_PADENTER}, /* 13 */
+   {PADSLASH,   SHF_PADSLASH,   CTL_PADSLASH,ALT_PADSLASH}, /* 111 */
+   {KEY_PPAGE,  KEY_SPREVIOUS,  CTL_PGUP,    ALT_PGUP    }, /* 33 */
+   {KEY_NPAGE,  KEY_SNEXT,      CTL_PGDN,    ALT_PGDN    }, /* 34 */
+   {KEY_END,    KEY_SEND,       CTL_END,     ALT_END     }, /* 35 */
+   {KEY_HOME,   KEY_SHOME,      CTL_HOME,    ALT_HOME    }, /* 36 */
+   {KEY_LEFT,   KEY_SLEFT,      CTL_LEFT,    ALT_LEFT    }, /* 37 */
+   {KEY_UP,     KEY_SUP,        CTL_UP,      ALT_UP      }, /* 38 */
+   {KEY_RIGHT,  KEY_SRIGHT,     CTL_RIGHT,   ALT_RIGHT   }, /* 39 */
+   {KEY_DOWN,   KEY_SDOWN,      CTL_DOWN,    ALT_DOWN    }, /* 40 */
+   {KEY_IC,     KEY_SIC,        CTL_INS,     ALT_INS     }, /* 45 */
+   {KEY_DC,     KEY_SDC,        CTL_DEL,     ALT_DEL     }, /* 46 */
+   {PADSLASH,   SHF_PADSLASH,   CTL_PADSLASH,ALT_PADSLASH}, /* 191 */
+};
+ /* End of kptab[]       */
+
+MOUSE_STATUS Trapped_Mouse_status;
+
+/*man-start*********************************************************************
+
+  PDC_breakout()  - check for type-ahead
+
+  X/Open Description:
+   The curses package does the "line-breakout optimisation" by
+   looking for type-ahead periodically while updating the screen.
+   If input is found, the current update will be postponed until
+   refresh() or doupdate() are called again.  This allows faster
+   response to commands typed in advance.  Normally, the input FILE
+   pointer passed to newterm(), or stdin in the case when initscr()
+   was called, will be used to do this type-ahead checking.  This routine
+   will do the actual check for PDcurses to see if input is pending.
+
+  PDCurses Description:
+   This routine does what the PDcurses typeahead routine used to do.  But
+   to make that routine consistent with its System V counterpart, all it
+   does now is set whether or not typeahead checking is performed.
+
+  X/Open Return Value:
+   The PDC_breakout() routine returns TRUE if keyboard input is pending
+   otherwise FALSE is returned.
+
+  Portability:
+   PDCurses bool PD_breakout( void );
+
+**man-end**********************************************************************/
+
+bool PDC_breakout( void )
+{
+   extern   int   c_pindex;         /* putter index */
+   extern   int   c_gindex;         /* getter index */
+   extern   int   c_ungind;         /* wungetch() push index */
+   bool rc;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_breakout() - called\n");
+#endif
+
+   if (c_ungind)
+      rc = TRUE;       /* ungotten char */
+   else if (c_pindex > c_gindex)
+      rc = TRUE;       /* buffered char */
+   else if (PDC_SP->raw_inp)
+      rc= (bool)PDC_check_bios_key();  /* raw mode test */
+   else
+      rc = (bool)PDC_check_bios_key(); /* normal mode test */
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_breakout() - returned: %d c_ungind %d c_pindex %d c_gindex %d\n",rc,c_ungind,c_pindex,c_gindex);
+#endif
+   return(rc);
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_input_fd() - Get file descriptor used for PDCurses input
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   This routine will return the file descriptor that PDCurses reads
+   its input from. It can be used for WaitForMulitpleObjects()
+
+  PDCurses Return Value:
+   Returns a HANDLE.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int   PDC_get_input_fd( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+unsigned long PDC_get_input_fd(void)
+#else
+unsigned long PDC_get_input_fd()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_input_fd() - called\n");
+#endif
+
+#if defined(PDC_THREAD_BUILD)
+   return (unsigned long)hSemKeyCount;
+#else
+   return 0L;
+#endif
+}
+
+/*man-start*********************************************************************
+
+  PDC_check_bios_key()  - Check BIOS key data area for input
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   This routine will check the BIOS for any indication that
+   keystrokes are pending.
+
+  PDCurses Return Value:
+   Returns 1 if a keyboard character is available, 0 otherwise.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses bool  PDC_check_bios_key( void );
+
+**man-end**********************************************************************/
+
+bool PDC_check_bios_key(void)
+{
+   return(win32_kbhit(0));
+}         
+
+/*man-start*********************************************************************
+
+  PDC_get_bios_key() - Returns the next key available from the BIOS.
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Returns the next key code struck at the keyboard. If the low 8
+   bits are 0, the upper bits contain the extended character
+   code. If bit 0-7 are non-zero, the upper bits = 0.
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_get_bios_key( void );
+
+**man-end**********************************************************************/
+
+int   PDC_get_bios_key(void)
+{
+   MOUSE_STATUS Temp_Mouse_status;
+   static int last_button_no=0;
+   static MOUSE_STATUS Actual_Mouse_status;
+   int button_no=0;
+   bool trap_mouse=FALSE;
+   int idx=0,key=0;
+   bool enhanced=FALSE;
+   unsigned long local_key_modifiers=0L;
+   int ignore_key;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_bios_key() - called\n");
+#endif
+
+   while(1)
+   {
+      win32_getch();
+   
+      switch(save_ip.EventType)
+      {
+         case KEY_EVENT:
+#if 0
+         {
+            char buf[KL_NAMELENGTH];
+            GetKeyboardLayoutName( buf );
+            fprintf(stderr,"AsciiChar: %d Unicode: %d KeyCode: %d ScanCode: %d State: %x Name: %s\n",
+                    save_ip.Event.KeyEvent.uChar.AsciiChar,
+                    save_ip.Event.KeyEvent.uChar.UnicodeChar,
+                    save_ip.Event.KeyEvent.wVirtualKeyCode,
+                    save_ip.Event.KeyEvent.wVirtualScanCode,
+                    save_ip.Event.KeyEvent.dwControlKeyState,
+                    buf
+                    );
+         }
+#endif
+
+            local_key_modifiers = pdc_key_modifiers = 0L;
+            ignore_key = 0;
+            switch(save_ip.Event.KeyEvent.wVirtualKeyCode)
+            {
+               case 16: /* shift */
+                  if ( PDC_SP->return_key_modifiers ) return KEY_SHIFT_R;
+                  ignore_key = 1;
+                  break;
+               case 17: /* control */
+                  if (save_ip.Event.KeyEvent.dwControlKeyState & LEFT_CTRL_PRESSED)
+                  {
+                     if ( PDC_SP->return_key_modifiers ) return KEY_CONTROL_L;
+                  }
+                  else
+                  {
+                     if ( PDC_SP->return_key_modifiers ) return KEY_CONTROL_R;
+                  }
+                  ignore_key = 1;
+                  break;
+               case 18: /* alt */
+                  if (save_ip.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED)
+                  {
+                     if ( PDC_SP->return_key_modifiers ) return KEY_ALT_L;
+                  }
+                  else
+                  {
+                     if ( PDC_SP->return_key_modifiers ) return KEY_ALT_R;
+                  }
+                  ignore_key = 1;
+                  break;
+               default:
+                  break;
+            }
+            if ( ignore_key )
+               break;
+            /*
+             * Must calculate the key modifiers so that Alt keys work!
+             */
+            if (save_ip.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED
+            ||  save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_ALT_PRESSED)
+               local_key_modifiers |= PDC_KEY_MODIFIER_ALT;
+            if (save_ip.Event.KeyEvent.dwControlKeyState & SHIFT_PRESSED)
+               local_key_modifiers |= PDC_KEY_MODIFIER_SHIFT;
+            if (save_ip.Event.KeyEvent.dwControlKeyState & LEFT_CTRL_PRESSED
+            ||  save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_CTRL_PRESSED)
+               local_key_modifiers |= PDC_KEY_MODIFIER_CONTROL;
+            if (save_ip.Event.KeyEvent.dwControlKeyState & NUMLOCK_ON)
+               local_key_modifiers |= PDC_KEY_MODIFIER_NUMLOCK;
+            /*
+             * Save the key modifiers if required
+             */
+            if (PDC_SP->save_key_modifiers)
+            {
+               pdc_key_modifiers = local_key_modifiers;
+            }
+            /*
+             * If the Unicode character is not zero; its a displayable character.
+             * Check for Ctrl-Alt sequences; they are diatric characters
+             */
+            if ( save_ip.Event.KeyEvent.uChar.UnicodeChar != 0 )
+            {
+               idx = save_ip.Event.KeyEvent.wVirtualKeyCode;
+               if ( local_key_modifiers & PDC_KEY_MODIFIER_CONTROL
+               &&   local_key_modifiers & PDC_KEY_MODIFIER_ALT )
+                  return (int)save_ip.Event.KeyEvent.uChar.UnicodeChar;
+               if ( local_key_modifiers & PDC_KEY_MODIFIER_CONTROL )
+                  return kptab[idx].control;
+               if ( local_key_modifiers & PDC_KEY_MODIFIER_ALT )
+                  return kptab[idx].alt;
+               return (int)save_ip.Event.KeyEvent.uChar.UnicodeChar;
+            }
+
+            if (save_ip.Event.KeyEvent.uChar.AsciiChar == 0
+            ||  save_ip.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED
+            ||  save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_ALT_PRESSED
+            ||  save_ip.Event.KeyEvent.dwControlKeyState & ENHANCED_KEY)
+            {
+               if (save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_ALT_PRESSED
+               &&  save_ip.Event.KeyEvent.uChar.AsciiChar != 0)
+/*                  return((int)(unsigned char)save_ip.Event.KeyEvent.uChar.AsciiChar); */
+                  return((int)save_ip.Event.KeyEvent.uChar.UnicodeChar);
+               if (save_ip.Event.KeyEvent.dwControlKeyState & ENHANCED_KEY)
+               {
+                  enhanced = TRUE;
+                  idx = kptab[save_ip.Event.KeyEvent.wVirtualKeyCode].extended;
+               }
+               else
+               {
+                  enhanced = FALSE;
+                  idx = save_ip.Event.KeyEvent.wVirtualKeyCode;
+               }
+               if (save_ip.Event.KeyEvent.dwControlKeyState & SHIFT_PRESSED)
+                  return((enhanced)?ext_kptab[idx].shift:kptab[idx].shift);
+               if (save_ip.Event.KeyEvent.dwControlKeyState & LEFT_CTRL_PRESSED
+               ||  save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_CTRL_PRESSED)
+                  return((enhanced)?ext_kptab[idx].control:kptab[idx].control);
+               if (save_ip.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED
+               ||  save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_ALT_PRESSED)
+                  return((enhanced)?ext_kptab[idx].alt:kptab[idx].alt);
+               return((enhanced)?ext_kptab[idx].normal:kptab[idx].normal);
+            }
+            else
+            {
+               if (kptab[save_ip.Event.KeyEvent.wVirtualKeyCode].extended == 999)
+               {
+                  idx = save_ip.Event.KeyEvent.wVirtualKeyCode;
+                  if (save_ip.Event.KeyEvent.dwControlKeyState & SHIFT_PRESSED)
+                     return(kptab[idx].shift);
+                  if (save_ip.Event.KeyEvent.dwControlKeyState & LEFT_CTRL_PRESSED
+                  ||  save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_CTRL_PRESSED)
+                     return(kptab[idx].control);
+                  if (save_ip.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED
+                  ||  save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_ALT_PRESSED)
+                     return(kptab[idx].alt);
+                  return(kptab[idx].normal);
+               }
+               else
+               {
+                  idx = save_ip.Event.KeyEvent.wVirtualKeyCode;
+                  if (save_ip.Event.KeyEvent.dwControlKeyState & SHIFT_PRESSED
+                  && kptab[idx].shift)
+                     return(kptab[idx].shift);
+                  if ((save_ip.Event.KeyEvent.dwControlKeyState & LEFT_CTRL_PRESSED
+                  ||   save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_CTRL_PRESSED)
+                  &&  kptab[idx].control)
+                     return(kptab[idx].control);
+                  if ((save_ip.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED
+                  ||   save_ip.Event.KeyEvent.dwControlKeyState & RIGHT_ALT_PRESSED)
+                  &&  kptab[idx].alt)
+                     return(kptab[idx].alt);
+/*                  return((int)(unsigned char)save_ip.Event.KeyEvent.uChar.AsciiChar); */
+                  return((int)save_ip.Event.KeyEvent.uChar.UnicodeChar);
+               }
+            }
+            break;
+         case MOUSE_EVENT:
+            memset((char*)&Temp_Mouse_status,0,sizeof(MOUSE_STATUS));
+            /* 
+             * button press, release or double click ...
+             */
+            if (save_ip.Event.MouseEvent.dwEventFlags == 0 
+            ||  save_ip.Event.MouseEvent.dwEventFlags == DOUBLE_CLICK)
+            {
+               /*
+                * Check for Left-most button - always button 1
+                */
+               if (save_ip.Event.MouseEvent.dwButtonState & FROM_LEFT_1ST_BUTTON_PRESSED
+               && !(ACTUAL_BUTTON_STATUS(1) & BUTTON_RELEASED))
+               {
+                  button_no = 1;
+                  TEMP_BUTTON_STATUS(button_no) = (save_ip.Event.MouseEvent.dwEventFlags)?BUTTON_DOUBLE_CLICKED:BUTTON_PRESSED;
+                  if (TEMP_BUTTON_STATUS(button_no) == BUTTON_PRESSED
+                  && (PDC_SP->_trap_mbe) & BUTTON1_PRESSED)
+                     trap_mouse = TRUE;
+                  if (TEMP_BUTTON_STATUS(button_no) == BUTTON_DOUBLE_CLICKED
+                  && (PDC_SP->_trap_mbe) & BUTTON1_DOUBLE_CLICKED)
+                     trap_mouse = TRUE;
+                  break;
+               }
+               /*
+                * Check for Right-most button - always button 3
+                */
+               if (save_ip.Event.MouseEvent.dwButtonState & RIGHTMOST_BUTTON_PRESSED
+               && !(ACTUAL_BUTTON_STATUS(3) & BUTTON_RELEASED))
+               {
+                  button_no = 3;
+                  TEMP_BUTTON_STATUS(button_no) = (save_ip.Event.MouseEvent.dwEventFlags)?BUTTON_DOUBLE_CLICKED:BUTTON_PRESSED;
+                  if (TEMP_BUTTON_STATUS(button_no) == BUTTON_PRESSED
+                  && (PDC_SP->_trap_mbe) & BUTTON3_PRESSED)
+                     trap_mouse = TRUE;
+                  if (TEMP_BUTTON_STATUS(button_no) == BUTTON_DOUBLE_CLICKED
+                  && (PDC_SP->_trap_mbe) & BUTTON3_DOUBLE_CLICKED)
+                     trap_mouse = TRUE;
+                  break;
+               }
+               /*
+                * To get here we have a button release event or another button press
+                * while a current button is pressed. The latter, we throw away. 
+                * We have to use the information from the previous mouse event to 
+                * determine which button was released.
+                */
+               if (last_button_no == 1
+               && (ACTUAL_BUTTON_STATUS(1) & BUTTON_PRESSED
+                   || ACTUAL_BUTTON_STATUS(1) & BUTTON_DOUBLE_CLICKED
+                   || ACTUAL_MOUSE_MOVED)
+               && !(save_ip.Event.MouseEvent.dwButtonState & FROM_LEFT_1ST_BUTTON_PRESSED))
+               {
+                  button_no = 1;
+                  TEMP_BUTTON_STATUS(button_no) = BUTTON_RELEASED;
+                  if ((PDC_SP->_trap_mbe) & BUTTON1_RELEASED)
+                     trap_mouse = TRUE;
+                  break;
+               }
+               /*
+                * Check for Right-most button - always button 3
+                */
+               if (last_button_no == 3
+               && (ACTUAL_BUTTON_STATUS(3) & BUTTON_PRESSED
+                  || ACTUAL_BUTTON_STATUS(3) & BUTTON_DOUBLE_CLICKED
+                   || ACTUAL_MOUSE_MOVED)
+               && !(save_ip.Event.MouseEvent.dwButtonState & RIGHTMOST_BUTTON_PRESSED))
+               {
+                  button_no = 3;
+                  TEMP_BUTTON_STATUS(button_no) = BUTTON_RELEASED;
+                  if ((PDC_SP->_trap_mbe) & BUTTON3_RELEASED)
+                     trap_mouse = TRUE;
+                  break;
+               }
+               if (PDC_SP->num_mouse_buttons == 3)
+               {
+                  /*
+                   * Check for Middle button - button 2 only for 3 button mice
+                   */
+                  if (save_ip.Event.MouseEvent.dwButtonState & FROM_LEFT_2ND_BUTTON_PRESSED
+                  && !(ACTUAL_BUTTON_STATUS(2) & BUTTON_RELEASED))
+                  {
+                     button_no = 2;
+                     TEMP_BUTTON_STATUS(button_no) = (save_ip.Event.MouseEvent.dwEventFlags)?BUTTON_DOUBLE_CLICKED:BUTTON_PRESSED;
+                     if (TEMP_BUTTON_STATUS(button_no) == BUTTON_PRESSED
+                     && (PDC_SP->_trap_mbe) & BUTTON3_PRESSED)
+                        trap_mouse = TRUE;
+                     if (TEMP_BUTTON_STATUS(button_no) == BUTTON_DOUBLE_CLICKED
+                     && (PDC_SP->_trap_mbe) & BUTTON3_DOUBLE_CLICKED)
+                        trap_mouse = TRUE;
+                     break;
+                  }
+                  if (last_button_no == 2
+                  && (ACTUAL_BUTTON_STATUS(2) & BUTTON_PRESSED
+                     || ACTUAL_BUTTON_STATUS(2) & BUTTON_DOUBLE_CLICKED
+                     || ACTUAL_MOUSE_MOVED)
+                  && !(save_ip.Event.MouseEvent.dwButtonState & FROM_LEFT_2ND_BUTTON_PRESSED))
+                  {
+                     button_no = 2;
+                     TEMP_BUTTON_STATUS(button_no) = BUTTON_RELEASED;
+                     if ((PDC_SP->_trap_mbe) & BUTTON2_RELEASED)
+                        trap_mouse = TRUE;
+                     break;
+                    }
+               }
+               /*
+                * If we get here, then we don't know how to handle the event, so
+                * dispose of it
+                */
+               break;
+            }
+            else /* button motion event */
+            {
+               Temp_Mouse_status.changes |= 8;
+               button_no = last_button_no;
+               if (button_no == 1
+               &&  (PDC_SP->_trap_mbe) & BUTTON1_MOVED)
+                  trap_mouse = TRUE;
+               if (button_no == 2
+               &&  (PDC_SP->_trap_mbe) & BUTTON2_MOVED)
+                  trap_mouse = TRUE;
+               if (button_no == 3
+               &&  (PDC_SP->_trap_mbe) & BUTTON3_MOVED)
+                  trap_mouse = TRUE;
+               break;
+            }
+            break;
+         case WINDOW_BUFFER_SIZE_EVENT:
+            return(-1);
+            break;
+         default:
+            break;
+      }
+      if (button_no != 0)
+      {
+         TEMP_MOUSE_X_POS = save_ip.Event.MouseEvent.dwMousePosition.X;
+         TEMP_MOUSE_Y_POS = save_ip.Event.MouseEvent.dwMousePosition.Y;
+         /*
+          * First thing is to check if the mouse has been clicked
+          * on a slk area. If the return value is > 0 (indicating the
+          * label number, return with the KEY_F(key) value.
+          * Only call this if we have set trap_mouse to TRUE above.
+          */
+         if (trap_mouse
+         && (key = PDC_mouse_in_slk(TEMP_MOUSE_Y_POS,TEMP_MOUSE_X_POS)))
+            return(KEY_F(key));
+  
+         Temp_Mouse_status.changes |= (1 << (button_no-1));
+         if (save_ip.Event.MouseEvent.dwControlKeyState & SHIFT_PRESSED)
+            TEMP_BUTTON_STATUS(button_no) |= BUTTON_SHIFT;
+         if (save_ip.Event.MouseEvent.dwControlKeyState & LEFT_CTRL_PRESSED)
+            TEMP_BUTTON_STATUS(button_no) |= BUTTON_CONTROL;
+         if (save_ip.Event.MouseEvent.dwControlKeyState & RIGHT_CTRL_PRESSED)
+            TEMP_BUTTON_STATUS(button_no) |= BUTTON_CONTROL;
+         if (save_ip.Event.MouseEvent.dwControlKeyState & RIGHT_ALT_PRESSED)
+            TEMP_BUTTON_STATUS(button_no) |= BUTTON_ALT;
+         if (save_ip.Event.MouseEvent.dwControlKeyState & LEFT_ALT_PRESSED)
+            TEMP_BUTTON_STATUS(button_no) |= BUTTON_ALT;
+         last_button_no = button_no;
+         /*
+          * We now have the current mouse status information for the last
+          * Mouse event.  We need to save this in Actual_Mouse_status so
+          * we can use that when comparing against the next mouse event.
+          * We also need to determine if we need to set Trapped_Mouse_status
+          * based on the settings in PDC_SP->_trap_mbe.
+          */
+         memcpy((char*)&Actual_Mouse_status,(char*)&Temp_Mouse_status,sizeof(MOUSE_STATUS));
+         if (trap_mouse)
+            break;
+      }
+   }
+   /*
+    * To get here we have a mouse event that has been trapped by the
+    * user. Save it in the Trapped_Mouse_status structure.
+    */
+   memcpy((char*)&Trapped_Mouse_status,(char*)&Temp_Mouse_status,sizeof(MOUSE_STATUS));
+   return(KEY_MOUSE);
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_ctrl_break()  - return OS control break state
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Returns the current OS Control Break Check state.
+
+  PDCurses Return Value:
+   DOS:
+      This function returns TRUE if the Control Break
+      Check is enabled otherwise FALSE is returned.
+
+   FLEXOS:
+      This function returns TRUE on if the Keyboard Mode
+      allows a break to bre reported otherwise FALSE is returned.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses bool  PDC_get_ctrl_break( void );
+
+**man-end**********************************************************************/
+
+bool  PDC_get_ctrl_break(void)
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_ctrl_break() - called\n");
+#endif
+   return FALSE;
+}
+
+/*man-start*********************************************************************
+
+  PDC_rawgetch()  - Returns the next uninterpreted character (if available).
+
+  PDCurses Description:
+   Gets a character without any interpretation at all and returns
+   it. If keypad mode is active for the designated window,
+   function key translation will be performed.  Otherwise,
+   function keys are ignored.  If nodelay mode is active in the
+   window, then PDC_rawgetch() returns -1 if no character is
+   available.
+
+   WARNING:  It is unknown whether the FUNCTION key translation
+        is performed at this level. --Frotz 911130 BUG
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int   PDC_rawgetch( void );
+
+**man-end**********************************************************************/
+
+int   PDC_rawgetch(void)
+{
+   extern   WINDOW*  _getch_win_;
+
+   int   c=0;
+   int   oldc=0;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_rawgetch() - called\n");
+#endif
+
+   if (_getch_win_ == (WINDOW *)NULL)   /* @@ */
+      return( -1 );
+
+   if (_getch_win_->_nodelay && !PDC_breakout()) /* @@ */
+      return( -1 );
+
+   while (1)      /* loop to get valid char */
+   {
+      c = PDC_get_bios_key();
+      oldc = c;
+      /*
+       * Return the key if it is not a special key.
+       */
+      if (c != KEY_MOUSE
+      && (c = PDC_validchar(c)) >= 0)
+      {     /* get & check next char */
+         return( c );
+      }
+      if (_getch_win_->_use_keypad)
+         return( oldc );
+   }
+   return( -1 );
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_ctrl_break()  - Enables/Disables the host OS BREAK key check.
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Enables/Disables the host OS BREAK key check. If the supplied setting
+   is TRUE, this enables CTRL/C and CTRL/BREAK to abort the process.
+   If FALSE, CTRL/C and CTRL/BREAK are ignored.
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_set_ctrl_break( bool setting );
+
+**man-end**********************************************************************/
+
+int   PDC_set_ctrl_break(bool setting)
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_set_ctrl_break() - called\n");
+#endif
+
+   return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_sysgetch()  - Return a character using default system routines.
+
+  PDCurses Description:
+   This is a private PDCurses function.
+
+   Gets a character without normal ^S, ^Q, ^P and ^C interpretation
+   and returns it.  If keypad mode is active for the designated
+   window, function key translation will be performed. Otherwise,
+   function keys are ignored. If nodelay mode is active in the
+   window, then sysgetch() returns -1 if no character is
+   available.
+
+  PDCurses Return Value:
+   This function returns OK upon success otherwise ERR is returned.
+
+  PDCurses Errors:
+   No errors are defined for this routine.
+
+  Portability:
+   PDCurses int   PDC_sysgetch( void );
+
+**man-end**********************************************************************/
+
+int   PDC_sysgetch(void)
+{
+   extern   WINDOW*  _getch_win_;
+
+   int c=0;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_sysgetch() - called\n");
+#endif
+
+   if (_getch_win_ == (WINDOW *)NULL)  /* @@ */
+      return (-1);
+
+   if (_getch_win_->_nodelay && !PDC_breakout())
+      return (-1);
+
+   while (1)
+   {
+      c = PDC_get_bios_key();
+      /*
+       * Return the key if it is not a special key.
+       */
+      if ((unsigned int)c < 256)
+         return(c);
+      if ((c = PDC_validchar(c)) >= 0)
+      {
+         return (c);      /* get & check next char */
+      }
+   }
+   return( -1 );
+}
+
+
+/*man-start*********************************************************************
+
+  PDC_validchar() - validate/translate passed character
+  
+  PDCurses Description:
+   This is a private PDCurses function.
+  
+   Checks that 'c' is a valid character, and if so returns it,
+   with function key translation applied if 'w' has keypad mode
+   set.  If char is invalid, returns -1.
+  
+  PDCurses Return Value:
+   This function returns -1 if the passed character is invalid, or
+   the WINDOW* 'w' is NULL, or 'w's keypad is not active.
+  
+   This function returns 0 under Flexos if the passed character
+   is 0x0300.  (-:Forget why.  --Frotz 911130:-)
+  
+   Otherwise, this function returns the PDCurses equivalent of the
+   passed character.  See the function key and key macros in
+   <curses.h>
+  
+  PDCurses Errors:
+   There are no errors defined for this routine.
+  
+  Portability:
+   PDCurses int   PDC_validchar( int c );
+
+**man-end**********************************************************************/
+
+int   PDC_validchar(int c)
+{
+   extern   WINDOW*  _getch_win_;
+   int ch=c;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_validchar() - called\n");
+#endif
+
+   if (_getch_win_ == (WINDOW *)NULL)
+      ch = (-1);   /* bad window pointer     */
+   else if ((unsigned int)c < 256) 
+      ch = c;      /* normal character */
+   else if (!(_getch_win_->_use_keypad)) 
+      ch = (-1);   /* skip if keys if !keypad mode */
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_validchar() - returned: %x\n",ch);
+#endif
+   return(ch);
+}
+
+/***********************************************************************/
+static int GetInterestingEvent( INPUT_RECORD *ip )
+/***********************************************************************/
+{
+   int numKeys = 0;
+   static int save_press;
+#ifdef PDCDEBUG
+#if defined(PDC_THREAD_BUILD)
+#  define PDC_DEBUG_THREADING1 "-->"
+#  define PDC_DEBUG_THREADING2 "THREADING"
+# else
+#  define PDC_DEBUG_THREADING1 ""
+#  define PDC_DEBUG_THREADING2 ""
+# endif
+   char *ptr="";
+   if (trace_on) PDC_debug("%sGetInterestingEvent(%s) - called\n",PDC_DEBUG_THREADING1,PDC_DEBUG_THREADING2);
+#endif
+
+   switch(ip->EventType)
+   {
+      case KEY_EVENT:
+         if (ip->Event.KeyEvent.wVirtualKeyCode == 20
+          ||  ip->Event.KeyEvent.wVirtualKeyCode == 144
+          ||  ip->Event.KeyEvent.wVirtualKeyCode == 145)
+         {
+#ifdef PDCDEBUG
+            ptr = "KEY MODIFIERS";
+#endif
+            break;  /* throw away some modifiers */
+         }
+         if (ip->Event.KeyEvent.bKeyDown == FALSE)
+         {
+            /* key up */
+            if ((ip->Event.KeyEvent.wVirtualKeyCode == 16
+            ||  ip->Event.KeyEvent.wVirtualKeyCode == 17
+            ||  ip->Event.KeyEvent.wVirtualKeyCode == 18)
+            &&  ip->Event.KeyEvent.wVirtualKeyCode == save_press
+            &&  PDC_SP->return_key_modifiers)
+#ifdef PDCDEBUG
+               ptr = "KEYUP WANTED";
+#else
+               ;
+#endif
+            else
+            {
+#ifdef PDCDEBUG
+               ptr = "KEYUP IGNORED";
+#endif
+               break;                    /* throw away KeyUp events */
+            }
+         }
+         else
+         {
+            if ((ip->Event.KeyEvent.wVirtualKeyCode == 16
+            ||  ip->Event.KeyEvent.wVirtualKeyCode == 17
+            ||  ip->Event.KeyEvent.wVirtualKeyCode == 18)
+            &&  PDC_SP->return_key_modifiers)
+            {
+               save_press = ip->Event.KeyEvent.wVirtualKeyCode;
+#ifdef PDCDEBUG
+               ptr = "KEYDOWN SAVED";
+#endif
+               break; /* throw away key press */
+            }
+         }
+         save_press = 0;
+         if (ip->Event.KeyEvent.uChar.AsciiChar == 0 &&
+             (MapVirtualKey(ip->Event.KeyEvent.wVirtualKeyCode,2) & 0x80000000))
+         {
+#ifdef PDCDEBUG
+            ptr = "DIACRITIC IGNORED";
+#endif
+            break;              /* Diacritic characters, ignore them */
+         }
+#ifdef PDCDEBUG
+         ptr = "KEY WANTED";
+#endif
+         numKeys = ip->Event.KeyEvent.wRepeatCount;
+         break;
+      case MOUSE_EVENT:
+         /*
+          * If we aren't trapping mouse events, then the "keyboard" hasn't
+          * been hit. Fix from stepheng@clearspeed.com
+          */
+         if (!PDC_SP->_trap_mbe)
+         {
+#ifdef PDCDEBUG
+            ptr = "MOUSE - NOT TRAPPED";
+#endif
+            break;
+         }
+         if (ip->Event.MouseEvent.dwEventFlags == MS_MOUSE_MOVED
+         &&  ip->Event.MouseEvent.dwButtonState == 0)
+         {
+#ifdef PDCDEBUG
+            ptr = "MOUSE MOVE IGNORED";
+#endif
+            break;               /* throw away plain MOUSE_MOVE events */
+         }
+#ifdef PDCDEBUG
+         ptr = "MOUSE MOVE WANTED";
+#endif
+         numKeys = 1;
+         break;
+      case WINDOW_BUFFER_SIZE_EVENT:
+  /*
+         PDC_resize_screen( PDC_get_rows(), PDC_get_columns() );
+  */
+         PDC_SP->resized = TRUE;
+#ifdef PDCDEBUG
+         ptr = "BUFFER SIZE";
+#endif
+         numKeys = 0; /* was 1 */
+         break;
+      default:
+#ifdef PDCDEBUG
+         ptr = "UNKNOWN";
+#endif
+         numKeys = 0;
+         break;
+   }
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%sGetInterestingEvent(%s) - returning: numKeys %d type %d: %s\n",PDC_DEBUG_THREADING1,PDC_DEBUG_THREADING2,numKeys,ip->EventType,ptr);
+#endif
+   return numKeys;
+}
+
+#if defined(PDC_THREAD_BUILD)
+/***********************************************************************/
+static int win32_kbhit(int timeout)
+/***********************************************************************/
+{
+   DWORD read=0,avail=0,unread=0;
+   INPUT_RECORD ip;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("win32_kbhit(THREADING) - called: timeout %d\n", timeout);
+#endif
+
+
+#if 0
+   if ( timeout == INFINITE )
+   {
+      ReadFile( hPipeRead, &save_ip, sizeof(INPUT_RECORD), &read, NULL );
+      return TRUE;
+   }
+   else
+   {
+      if ( WaitForSingleObject( hSemKeyCount, timeout ) != WAIT_OBJECT_0 )
+      {
+         return FALSE;
+      }
+      if ( PeekNamedPipe( hPipeRead, &ip, sizeof(INPUT_RECORD), &read, &avail, &unread ) )
+      {
+#ifdef PDCDEBUG
+         if (trace_on) PDC_debug("win32_kbhit(THREADING) - maybe key on pipe. read %d avail %d unread %d\n",read,avail,unread);
+#endif
+         if ( read == sizeof(INPUT_RECORD) )
+            return TRUE;
+      }
+   }
+#else
+   if ( WaitForSingleObject( hSemKeyCount, timeout ) != WAIT_OBJECT_0 )
+   {
+      return FALSE;
+   }
+   if ( timeout == INFINITE )
+   {
+      ReadFile( hPipeRead, &save_ip, sizeof(INPUT_RECORD), &read, NULL );
+      return TRUE;
+   }
+   else
+   {
+      if ( PeekNamedPipe( hPipeRead, &ip, sizeof(INPUT_RECORD), &read, &avail, &unread ) )
+      {
+#ifdef PDCDEBUG
+         if (trace_on) PDC_debug("win32_kbhit(THREADING) - maybe key on pipe. read %d avail %d unread %d\n",read,avail,unread);
+#endif
+         if ( read == sizeof(INPUT_RECORD) )
+            return TRUE;
+      }
+   }
+#endif
+   return FALSE;
+}
+
+
+/***********************************************************************/
+static void win32_getch(void)
+/***********************************************************************/
+{
+   while (win32_kbhit(INFINITE) == FALSE)
+      ;
+
+   return;
+}
+#else
+
+/***********************************************************************/
+static int win32_kbhit(int timeout)
+/***********************************************************************/
+{
+   INPUT_RECORD ip;
+   DWORD read, avail;
+   int rc=FALSE;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("win32_kbhit() - called: timeout %d keyCount %d\n", timeout, keyCount);
+#endif
+  
+   if (keyCount > 0)
+      return TRUE;
+  
+   if (WaitForSingleObject(hConIn, timeout) != WAIT_OBJECT_0)
+   {
+      return FALSE;
+   }
+  
+   PeekConsoleInput(hConIn, &ip, 1, &read);
+   if (read == 0)
+      return(FALSE);
+   ReadConsoleInput(hConIn, &ip, 1, &read);
+
+   keyCount = GetInterestingEvent( &ip );
+   if ( keyCount )
+   {
+      /*
+       * To get here a recognised event has occurred; save it and return TRUE
+       */
+      memcpy( (char*)&save_ip, (char*)&ip, sizeof(INPUT_RECORD) );
+      rc = TRUE;
+   }
+   return(rc);
+}
+
+/***********************************************************************/
+static void win32_getch(void)
+/***********************************************************************/
+{
+   while (win32_kbhit(INFINITE) == FALSE)
+      ;
+
+   keyCount --;
+
+   return;
+}
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_get_key_modifiers()  - Returns the keyboard modifier(s) at time of last getch()
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Returns the keyboard modifiers effective at the time of the last getch()
+   call only if PDC_save_key_modifiers(TRUE) has been called before the
+   getch();
+   Use the macros; PDC_KEY_MODIFIER_* to determine which modifier(s)
+   were set.
+
+  PDCurses Return Value:
+   This function returns the modifiers.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_get_key_modifiers( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+unsigned long  PDC_get_key_modifiers(void)
+#else
+unsigned long  PDC_get_key_modifiers()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_key_modifiers() - called\n");
+#endif
+   return(pdc_key_modifiers);
+}
+
+
+#if defined(PDC_THREAD_BUILD)
+/***********************************************************************/
+LONG InputThread( LPVOID lpThreadData )
+/***********************************************************************/
+{
+   INPUT_RECORD ip;
+   DWORD read;
+   LONG prev;
+   int num_keys,i;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("-->InputThread() - called\n");
+#endif
+   /*
+    * Create a semaphore on which the parent thread will wait...
+    */
+   hSemKeyCount = CreateSemaphore( NULL, 0, 1024, NULL );
+   if ( hSemKeyCount != NULL )
+   {
+      for ( ; ; )
+      {
+         ReadConsoleInput(hConIn, &ip, 1, &read);
+         /*
+          * Now that this thread has woken up we need to check if the
+          * key/mouse event is relevant to us. If so, write it to the
+          * anonymous pipe.
+          */
+#ifdef PDCDEBUG
+         if (trace_on) PDC_debug("-->InputThread() - read %d character(s)\n",read);
+#endif
+         num_keys = GetInterestingEvent( &ip );
+#ifdef PDCDEBUG
+         if (trace_on) PDC_debug("-->InputThread() - got %d interesting keys\n",num_keys);
+#endif
+         for ( i = 0; i < num_keys; i++ )
+         {
+            /*
+             * For each key written to the pipe, increment the semaphore...
+             */
+            if ( ReleaseSemaphore( hSemKeyCount, 1, &prev ) )
+            {
+#ifdef PDCDEBUG
+               if (trace_on) PDC_debug("-->InputThread() - writing to pipe; sem incremented from %d\n",prev);
+#endif
+               if ( !WriteFile( hPipeWrite, &ip, sizeof(INPUT_RECORD), &read, NULL ) )
+               {
+                  /*
+                   * An error occured, we assume it is because the pipe broke;
+                   * therefore the parent thread is shutting down; so will we.
+                   */
+                  break;
+               }
+            }
+         }
+      }
+   }
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("-->InputThread() - finished\n");
+#endif
+   return 0;
+}
+#endif
Index: PDCurses/win32/pdcscrn.c
===================================================================
--- PDCurses/win32/pdcscrn.c	(revision 1)
+++ PDCurses/win32/pdcscrn.c	(working copy)
@@ -1,530 +1,530 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define  CURSES_LIBRARY 1
-#define  INCLUDE_WINDOWS_H
-#include <curses.h>
-
-#ifdef PDCDEBUG
-char *rcsid_PDCscrn  = "$Id: pdcscrn.c,v 1.2 2002/06/23 04:10:03 mark Exp $";
-#endif
-
-HANDLE hConOut = INVALID_HANDLE_VALUE;
-HANDLE hConIn = INVALID_HANDLE_VALUE;
-#if defined(PDC_THREAD_BUILD)
-HANDLE hPipeRead = INVALID_HANDLE_VALUE;
-HANDLE hPipeWrite = INVALID_HANDLE_VALUE;
-HANDLE hSemKeyCount = INVALID_HANDLE_VALUE;
-extern LONG InputThread( LPVOID lpThreadData );
-#endif
-
-CONSOLE_SCREEN_BUFFER_INFO scr;
-CONSOLE_SCREEN_BUFFER_INFO orig_scr;
- 
-static CHAR_INFO *ciSaveBuffer=NULL;
-static CHAR_INFO *save_ci=NULL;
-static DWORD dwConsoleMode=0;
-
-/*man-start*********************************************************************
-
-  PDC_scr_close() - Internal low-level binding to close the physical screen
-
-  PDCurses Description:
-   This function provides a low-level binding for the Flexos
-   platform which must close the screen before writing to it.
-   This is a nop for the DOS platform.
-
-   This function is provided in order to reset the FlexOS 16 bit
-   character set for input rather than the limited input
-   character set associated with the VT52.
-
-  PDCurses Return Value:
-   This function returns OK on success, otherwise an ERR is returned.
-
-  PDCurses Errors:
-   The DOS platform will never fail.  The Flexos platform may fail
-   depending on the ability to close the current virtual console in
-   8 (as opposed to 16) bit mode.
-
-  Portability:
-   PDCurses int   PDC_scr_close( void );
-
-**man-end**********************************************************************/
-
-int   PDC_scr_close(void)
-{
- COORD origin;
- SMALL_RECT rect;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_scr_close() - called\n");
-#endif
-   /*
-    * All of this code should probably go into DllMain() at DLL_PROCESS_DETACH
-    */
-   SetConsoleScreenBufferSize(hConOut, orig_scr.dwSize);
-   SetConsoleWindowInfo(hConOut,TRUE,&orig_scr.srWindow);
-   SetConsoleScreenBufferSize(hConOut, orig_scr.dwSize);
-   SetConsoleWindowInfo(hConOut,TRUE,&orig_scr.srWindow);
-
-   if (SP->_restore)
-   {
-      rect.Top = rect.Left = 0;
-      rect.Bottom = orig_scr.dwSize.Y  - 1;
-      rect.Right = orig_scr.dwSize.X - 1;
-      origin.X = origin.Y = 0;
-      if (!WriteConsoleOutput(hConOut,ciSaveBuffer,orig_scr.dwSize,origin,&rect))
-         return(ERR);
-   }
-
-   SetConsoleActiveScreenBuffer(hConOut);
-   SetConsoleMode(hConIn, dwConsoleMode);
-#if defined(PDC_THREAD_BUILD)
-   if ( hPipeRead != INVALID_HANDLE_VALUE )
-      CloseHandle( hPipeRead );
-   if ( hPipeWrite != INVALID_HANDLE_VALUE )
-      CloseHandle( hPipeWrite );
-#endif
-
-   return( OK );
-}
-
-/*man-start*********************************************************************
-
-  PDC_scrn_modes_equal()   - Decide if two screen modes are equal
-
-  PDCurses Description:
-   Mainly required for OS/2. It decides if two screen modes
-        (VIOMODEINFO structure) are equal. Under DOS it just compares
-        two integers
-
-  PDCurses Return Value:
-   This function returns TRUE if equal else FALSe.
-
-  PDCurses Errors:
-   No errors are defined for this function.
-
-  Portability:
-   PDCurses int PDC_scrn_modes_equal( int mode1, int mode2 );
-   OS2 PDCurses   int PDC_scrn_modes_equal( VIOMODEINFO mode1, VIOMODEINFO mode2 );
-
-**man-end**********************************************************************/
-
-bool  PDC_scrn_modes_equal(int mode1, int mode2)
-{
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_scrn_modes_equal() - called\n");
-#endif
-   return (mode1 == mode2);
-}
-
-/*man-start*********************************************************************
-
-  PDC_scr_open()  - Internal low-level binding to open the physical screen
-
-  PDCurses Description:
-   This function provides a low-level binding for the Flexos
-   platform which must open the screen before writing to it.
-
-   This function is provided in order to access the FlexOS 16 bit
-   character set for input rather than the limited input
-   character set associated with the VT52.
-
-  PDCurses Return Value:
-   This function returns OK on success, otherwise an ERR is returned.
-
-  PDCurses Errors:
-   The DOS platform will never fail.  The Flexos platform may fail
-   depending on the ability to open the current virtual console in
-   8 (as opposed to 16) bit mode.
-
-  Portability:
-   PDCurses int   PDC_scr_open( SCREEN* internal, bool echo );
-
-**man-end**********************************************************************/
-
-int   PDC_scr_open(SCREEN *internal, bool echo)
-{
-   DWORD numbuttons=0;
-   COORD bufsize,origin;
-   SMALL_RECT rect;
-   char *str=NULL;
-   CONSOLE_SCREEN_BUFFER_INFO csbi;
-#if defined(PDC_THREAD_BUILD)
-   HANDLE hThread;
-   DWORD dwThreadID;
-#endif
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_scr_open() - called\n");
-#endif
-
-   hConOut = GetStdHandle(STD_OUTPUT_HANDLE);
-   hConIn = GetStdHandle(STD_INPUT_HANDLE);
-
-   GetConsoleScreenBufferInfo(hConOut, &csbi);
-   GetConsoleScreenBufferInfo(hConOut, &orig_scr);
-   GetConsoleMode(hConIn, &dwConsoleMode);
-
-   if ((str = getenv("LINES")) != NULL)
-      internal->lines = atoi(str);
-   else
-      internal->lines   = PDC_get_rows();
-
-   if ((str = getenv("COLS")) != NULL)
-      internal->cols = atoi(str);
-   else
-      internal->cols = PDC_get_columns();
-
-   if (internal->lines < 2
-   ||  internal->lines > csbi.dwMaximumWindowSize.Y)
-   {
-      fprintf(stderr,"LINES value must be >= 2 and <= %d: got %d\n",
-            csbi.dwMaximumWindowSize.Y,
-            internal->lines);
-      return(ERR);
-   }
-
-   if (internal->cols < 2
-   ||  internal->cols > csbi.dwMaximumWindowSize.X)
-   {
-      fprintf(stderr,"COLS value must be >= 2 and <= %d: got %d\n",
-            csbi.dwMaximumWindowSize.X,
-            internal->cols);
-      return(ERR);
-   }
-
-   if (getenv("PDC_RESTORE_SCREEN") != NULL)
-   {
-      if ((ciSaveBuffer = (CHAR_INFO*)malloc(orig_scr.dwSize.X*orig_scr.dwSize.Y*sizeof(CHAR_INFO))) == NULL)
-         return(ERR);
-      bufsize.X = orig_scr.dwSize.X;
-      bufsize.Y = orig_scr.dwSize.Y;
-
-      origin.X = origin.Y = 0;
-
-      rect.Top = rect.Left = 0;
-      rect.Bottom = orig_scr.dwSize.Y  - 1;
-      rect.Right = orig_scr.dwSize.X - 1;
-      if (!ReadConsoleOutput(hConOut,ciSaveBuffer,bufsize,origin,&rect))
-      {
-         free(ciSaveBuffer);
-         ciSaveBuffer = NULL;
-         return(ERR);
-      }
-      internal->_restore = TRUE;
-   }
-   else
-      internal->_restore = FALSE;
-
-   if (getenv("PDC_PRESERVE_SCREEN") != NULL)
-   {
-      bufsize.X = csbi.srWindow.Right - csbi.srWindow.Left + 1;
-      bufsize.Y = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;
-      if ((save_ci = (CHAR_INFO*)malloc(bufsize.X*bufsize.Y*sizeof(CHAR_INFO))) == NULL)
-         return(ERR);
-
-      origin.X = origin.Y = 0;
-
-      rect.Top = csbi.srWindow.Top;
-      rect.Left = csbi.srWindow.Left;
-      rect.Bottom = csbi.srWindow.Bottom;
-      rect.Right = csbi.srWindow.Right;
-      if (!ReadConsoleOutput(hConOut,save_ci,bufsize,origin,&rect))
-      {
-         free(save_ci);
-         save_ci = NULL;
-         return(ERR);
-      }
-      internal->_preserve = TRUE;
-   }
-   else
-      internal->_preserve = FALSE;
-
-   bufsize.X = orig_scr.srWindow.Right - orig_scr.srWindow.Left + 1;
-   bufsize.Y = orig_scr.srWindow.Bottom - orig_scr.srWindow.Top + 1;
-   rect.Top = rect.Left = 0;
-   rect.Bottom = bufsize.Y - 1;
-   rect.Right = bufsize.X - 1;
-
-   SetConsoleScreenBufferSize(hConOut, bufsize);
-   SetConsoleWindowInfo(hConOut,TRUE,&rect);
-   SetConsoleScreenBufferSize(hConOut, bufsize);
-   SetConsoleActiveScreenBuffer(hConOut);
-
-   PDC_reset_prog_mode();
-
-   GetNumberOfConsoleMouseButtons((LPDWORD)&numbuttons);
-   internal->num_mouse_buttons = (int)numbuttons;
-
-   PDC_get_cursor_pos(&internal->cursrow, &internal->curscol);
-   internal->direct_video  = TRUE; /* Assume that we can      */
-   internal->autocr  = TRUE;     /* lf -> crlf by default     */
-   internal->raw_out = FALSE; /* tty I/O modes       */
-   internal->raw_inp = FALSE; /* tty I/O modes       */
-   internal->cbreak  = TRUE;
-   internal->save_key_modifiers  = FALSE;
-   internal->return_key_modifiers   = FALSE;
-   internal->echo = echo;
-   /* under System V Curses, typeahead checking is enabled by default */
-   internal->refrbrk = TRUE;  /* allow premature end of refresh*/
-   internal->video_seg  = 0xb000;   /* Base screen segment addr   */
-   internal->video_ofs  = 0x0;      /* Base screen segment ofs    */
-   internal->video_page = 0;     /* Current Video Page         */
-   internal->visible_cursor= TRUE;  /* Assume that it is visible  */
-   internal->cursor  = PDC_get_cursor_mode();
-
-   internal->adapter = PDC_query_adapter_type();
-   internal->scrnmode   = PDC_get_scrn_mode();
-
-   internal->audible = TRUE;
-   internal->visibility = 1;
-   internal->orig_cursor = internal->cursor;
-   internal->orgcbr = PDC_get_ctrl_break();
-   internal->blank = ' ';
-   internal->resized = FALSE;
-   internal->shell = FALSE;
-   internal->_trap_mbe = 0L;
-   internal->_map_mbe_to_key = 0L;
-   internal->linesrippedoff = 0;
-   internal->linesrippedoffontop = 0;
-   internal->delaytenths = 0;
-#if defined(PDC_THREAD_BUILD)
-   /*
-    * Create the anonymous pipe and thread for handling input
-    */
-   if ( !CreatePipe( &hPipeRead,     // reading handle
-                     &hPipeWrite,    // writing handle
-                     NULL,           // handles not inherited
-                     0 ) )           // default buffer size
-   {
-      // error during pipe creation
-      fprintf( stderr, "Cannot create input pipe\n" );
-      return( ERR );
-   }
-   hThread = CreateThread( NULL,              // security attributes
-                           0,                 // initial stack size
-                           (LPTHREAD_START_ROUTINE) InputThread,
-                           NULL,              // argument
-                           CREATE_SUSPENDED,  // creation flag
-                           &dwThreadID );     // new thread ID
-   if ( ! hThread )
-   {
-      fprintf( stderr, "Cannot create input thread\n" );
-      return( ERR );
-   }
-   ResumeThread( hThread );
-#endif
-
-   return( OK );
-}
-
-static BOOL FitConsoleWindow(HANDLE hConOut, CONST SMALL_RECT *rect)
-/* Calls SetConsoleWindowInfo with the given parameters but fits them if a
- * scoll bar shrinks the maximum possible value. The rectangle must at least
- * fit in a half-sized window.
- */
-{
- SMALL_RECT run;
- SHORT mx, my;
-
-   if (SetConsoleWindowInfo(hConOut, TRUE, rect))
-      return(TRUE);
-
-   run = *rect;
-   run.Right /= 2;
-   run.Bottom /= 2;
-   mx = run.Right;
-   my = run.Bottom;
-
-   if (!SetConsoleWindowInfo(hConOut, TRUE, &run))
-      return(FALSE);
-   for (run.Right = rect->Right;run.Right >= mx;run.Right--)
-   {
-      if (SetConsoleWindowInfo(hConOut, TRUE, &run))
-         break;
-   }
-   if (run.Right < mx)
-      return(FALSE);
-   for (run.Bottom = rect->Bottom;run.Bottom >= my;run.Bottom--)
-   {
-      if (SetConsoleWindowInfo(hConOut, TRUE, &run))
-         return(TRUE);
-   }
-   return(FALSE);
-}
-
-/*man-start*********************************************************************
-
-  PDC_resize_screen()   - Internal low-level function to resize screen
-
-  PDCurses Description:
-   This function provides a means for the application program to
-   resize the overall dimensions of the screen.  Under DOS and OS/2
-   the application can tell PDCurses what size to make the screen;
-   under X11, resizing is done by the user and this function simply
-   adjusts its internal structures to fit the new size.
-   This function doesn't set LINES, COLS, SP->lines or SP->cols. This
-   must be done by resize_term.
-   If both arguments are 0 the function returns sucessfully. This
-   allows the calling routine to reset the SP->resized flag.
-   The functions fails if one of the arguments is less then 2.
-
-  PDCurses Return Value:
-   This function returns OK on success, otherwise an ERR is returned.
-
-  PDCurses Errors:
-
-  Portability:
-   PDCurses int   PDC_resize_screen( int, int );
-
-**man-end**********************************************************************/
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_resize_screen(int nlines, int ncols)
-#else
-int   PDC_resize_screen(nlines, ncols)
-int nlines,ncols;
-#endif
-/***********************************************************************/
-{
-#ifdef FGC0
-   COORD size, max;
-   SMALL_RECT rect;
-   CONSOLE_SCREEN_BUFFER_INFO csbi;
-   int external_resized = SP->resized;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_resize_screen() - called. Lines: %d Cols: %d\n",nlines,ncols);
-#endif
-   SP->resized = FALSE; /* prevent endless loops in case of errors */
-   
-   if (nlines == 0 
-   && ncols == 0)
-      return(OK); /* undocumented feature: let assign LINES and COLS
-                          to current values by the calling
-                          resize_term-function */
-
-   if (nlines < 2 || ncols < 2)
-      return(ERR);
-
-   if (!GetConsoleScreenBufferInfo(hConOut,&csbi)) /*needed for recovery*/
-      return(ERR);
-   max = GetLargestConsoleWindowSize(hConOut);
-   
-   size.X = ncols;
-   size.Y = nlines;
-   
-   /* Fit window into allowed values */
-   rect.Left = rect.Top = 0;
-   rect.Right = ncols - 1;
-   if (rect.Right >= max.X)
-      rect.Right = max.X;
-   rect.Bottom = rect.Top + nlines - 1;
-   if (rect.Bottom >= max.Y)
-      rect.Bottom = max.Y;
-   FitConsoleWindow(hConOut, &rect); /* helps to allow the BufferSize */
-   if (!SetConsoleScreenBufferSize(hConOut, size) ||
-       !FitConsoleWindow(hConOut, &rect))
-   {
-      SetConsoleScreenBufferSize(hConOut, csbi.dwSize);
-      SetConsoleWindowInfo(hConOut, TRUE, &csbi.srWindow);
-      return( (external_resized) ? OK : ERR );
-   }
-   
-   SetConsoleActiveScreenBuffer(hConOut);
-   return ( OK );
-#else
-   int rc=OK;
-   COORD size;
-   SMALL_RECT rect;
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_resize_screen() - called. Lines: %d Cols: %d\n",nlines,ncols);
-#endif
-
-   if (nlines < 2)
-      return(ERR);
-   SP->lines = LINES = nlines;
-
-   if (ncols < 2)
-      return(ERR);
-   SP->cols = COLS = ncols;
-
-   size.X = SP->cols;
-   size.Y = SP->lines;
-   rect.Top = rect.Left = 0;
-   rect.Bottom = SP->lines - 1;
-   rect.Right = SP->cols - 1;
-   SetConsoleScreenBufferSize(hConOut, size);
-   SetConsoleWindowInfo(hConOut,TRUE,&rect);
-   SetConsoleScreenBufferSize(hConOut, size);
-   SetConsoleWindowInfo(hConOut,TRUE,&rect);
-   SetConsoleActiveScreenBuffer(hConOut);
-   SP->resized = FALSE;
-   return ( rc );
-#endif
-}
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_reset_prog_mode(void)
-#else
-int   PDC_reset_prog_mode()
-#endif
-/***********************************************************************/
-{
-   SetConsoleMode(hConIn, ENABLE_MOUSE_INPUT | ENABLE_WINDOW_INPUT);
-   return(OK);
-}
-
-/***********************************************************************/
-#ifdef HAVE_PROTO
-int   PDC_reset_shell_mode(void)
-#else
-int   PDC_reset_shell_mode()
-#endif
-/***********************************************************************/
-{
-   SetConsoleMode(hConIn, dwConsoleMode);
-   return(OK);
-}
-
-#if !defined(PDC_STATIC_BUILD)
-BOOL WINAPI DllMain( HINSTANCE hDLL, DWORD dwReason, LPVOID pReserved)
-{
-   switch( dwReason)
-   {
-      case DLL_PROCESS_ATTACH:
-/*         fprintf(stderr,"DLL_PROCESS_ATTACH\n"); */
-         break;
-      case DLL_PROCESS_DETACH:
-/*         fprintf(stderr,"DLL_PROCESS_DETACH\n"); */
-         break;
-      case DLL_THREAD_ATTACH:
-/*         fprintf(stderr,"DLL_THREAD_ATTACH\n"); */
-         break;
-      case DLL_THREAD_DETACH:
-/*         fprintf(stderr,"DLL_THREAD_DETACH\n"); */
-         break;
-   }
-   return(TRUE);
-}
-#endif
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define  CURSES_LIBRARY 1
+#define  INCLUDE_WINDOWS_H
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCscrn  = "$Id: pdcscrn.c,v 1.2 2002/06/23 04:10:03 mark Exp $";
+#endif
+
+HANDLE hConOut = INVALID_HANDLE_VALUE;
+HANDLE hConIn = INVALID_HANDLE_VALUE;
+#if defined(PDC_THREAD_BUILD)
+HANDLE hPipeRead = INVALID_HANDLE_VALUE;
+HANDLE hPipeWrite = INVALID_HANDLE_VALUE;
+HANDLE hSemKeyCount = INVALID_HANDLE_VALUE;
+extern LONG InputThread( LPVOID lpThreadData );
+#endif
+
+CONSOLE_SCREEN_BUFFER_INFO scr;
+CONSOLE_SCREEN_BUFFER_INFO orig_scr;
+ 
+static CHAR_INFO *ciSaveBuffer=NULL;
+static CHAR_INFO *save_ci=NULL;
+static DWORD dwConsoleMode=0;
+
+/*man-start*********************************************************************
+
+  PDC_scr_close() - Internal low-level binding to close the physical screen
+
+  PDCurses Description:
+   This function provides a low-level binding for the Flexos
+   platform which must close the screen before writing to it.
+   This is a nop for the DOS platform.
+
+   This function is provided in order to reset the FlexOS 16 bit
+   character set for input rather than the limited input
+   character set associated with the VT52.
+
+  PDCurses Return Value:
+   This function returns OK on success, otherwise an ERR is returned.
+
+  PDCurses Errors:
+   The DOS platform will never fail.  The Flexos platform may fail
+   depending on the ability to close the current virtual console in
+   8 (as opposed to 16) bit mode.
+
+  Portability:
+   PDCurses int   PDC_scr_close( void );
+
+**man-end**********************************************************************/
+
+int   PDC_scr_close(void)
+{
+ COORD origin;
+ SMALL_RECT rect;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_scr_close() - called\n");
+#endif
+   /*
+    * All of this code should probably go into DllMain() at DLL_PROCESS_DETACH
+    */
+   SetConsoleScreenBufferSize(hConOut, orig_scr.dwSize);
+   SetConsoleWindowInfo(hConOut,TRUE,&orig_scr.srWindow);
+   SetConsoleScreenBufferSize(hConOut, orig_scr.dwSize);
+   SetConsoleWindowInfo(hConOut,TRUE,&orig_scr.srWindow);
+
+   if (PDC_SP->_restore)
+   {
+      rect.Top = rect.Left = 0;
+      rect.Bottom = orig_scr.dwSize.Y  - 1;
+      rect.Right = orig_scr.dwSize.X - 1;
+      origin.X = origin.Y = 0;
+      if (!WriteConsoleOutput(hConOut,ciSaveBuffer,orig_scr.dwSize,origin,&rect))
+         return(ERR);
+   }
+
+   SetConsoleActiveScreenBuffer(hConOut);
+   SetConsoleMode(hConIn, dwConsoleMode);
+#if defined(PDC_THREAD_BUILD)
+   if ( hPipeRead != INVALID_HANDLE_VALUE )
+      CloseHandle( hPipeRead );
+   if ( hPipeWrite != INVALID_HANDLE_VALUE )
+      CloseHandle( hPipeWrite );
+#endif
+
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_scrn_modes_equal()   - Decide if two screen modes are equal
+
+  PDCurses Description:
+   Mainly required for OS/2. It decides if two screen modes
+        (VIOMODEINFO structure) are equal. Under DOS it just compares
+        two integers
+
+  PDCurses Return Value:
+   This function returns TRUE if equal else FALSe.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_scrn_modes_equal( int mode1, int mode2 );
+   OS2 PDCurses   int PDC_scrn_modes_equal( VIOMODEINFO mode1, VIOMODEINFO mode2 );
+
+**man-end**********************************************************************/
+
+bool  PDC_scrn_modes_equal(int mode1, int mode2)
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_scrn_modes_equal() - called\n");
+#endif
+   return (mode1 == mode2);
+}
+
+/*man-start*********************************************************************
+
+  PDC_scr_open()  - Internal low-level binding to open the physical screen
+
+  PDCurses Description:
+   This function provides a low-level binding for the Flexos
+   platform which must open the screen before writing to it.
+
+   This function is provided in order to access the FlexOS 16 bit
+   character set for input rather than the limited input
+   character set associated with the VT52.
+
+  PDCurses Return Value:
+   This function returns OK on success, otherwise an ERR is returned.
+
+  PDCurses Errors:
+   The DOS platform will never fail.  The Flexos platform may fail
+   depending on the ability to open the current virtual console in
+   8 (as opposed to 16) bit mode.
+
+  Portability:
+   PDCurses int   PDC_scr_open( SCREEN* internal, bool echo );
+
+**man-end**********************************************************************/
+
+int   PDC_scr_open(SCREEN *internal, bool echo)
+{
+   DWORD numbuttons=0;
+   COORD bufsize,origin;
+   SMALL_RECT rect;
+   char *str=NULL;
+   CONSOLE_SCREEN_BUFFER_INFO csbi;
+#if defined(PDC_THREAD_BUILD)
+   HANDLE hThread;
+   DWORD dwThreadID;
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_scr_open() - called\n");
+#endif
+
+   hConOut = GetStdHandle(STD_OUTPUT_HANDLE);
+   hConIn = GetStdHandle(STD_INPUT_HANDLE);
+
+   GetConsoleScreenBufferInfo(hConOut, &csbi);
+   GetConsoleScreenBufferInfo(hConOut, &orig_scr);
+   GetConsoleMode(hConIn, &dwConsoleMode);
+
+   if ((str = getenv("LINES")) != NULL)
+      internal->lines = atoi(str);
+   else
+      internal->lines   = PDC_get_rows();
+
+   if ((str = getenv("COLS")) != NULL)
+      internal->cols = atoi(str);
+   else
+      internal->cols = PDC_get_columns();
+
+   if (internal->lines < 2
+   ||  internal->lines > csbi.dwMaximumWindowSize.Y)
+   {
+      fprintf(stderr,"LINES value must be >= 2 and <= %d: got %d\n",
+            csbi.dwMaximumWindowSize.Y,
+            internal->lines);
+      return(ERR);
+   }
+
+   if (internal->cols < 2
+   ||  internal->cols > csbi.dwMaximumWindowSize.X)
+   {
+      fprintf(stderr,"COLS value must be >= 2 and <= %d: got %d\n",
+            csbi.dwMaximumWindowSize.X,
+            internal->cols);
+      return(ERR);
+   }
+
+   if (getenv("PDC_RESTORE_SCREEN") != NULL)
+   {
+      if ((ciSaveBuffer = (CHAR_INFO*)malloc(orig_scr.dwSize.X*orig_scr.dwSize.Y*sizeof(CHAR_INFO))) == NULL)
+         return(ERR);
+      bufsize.X = orig_scr.dwSize.X;
+      bufsize.Y = orig_scr.dwSize.Y;
+
+      origin.X = origin.Y = 0;
+
+      rect.Top = rect.Left = 0;
+      rect.Bottom = orig_scr.dwSize.Y  - 1;
+      rect.Right = orig_scr.dwSize.X - 1;
+      if (!ReadConsoleOutput(hConOut,ciSaveBuffer,bufsize,origin,&rect))
+      {
+         free(ciSaveBuffer);
+         ciSaveBuffer = NULL;
+         return(ERR);
+      }
+      internal->_restore = TRUE;
+   }
+   else
+      internal->_restore = FALSE;
+
+   if (getenv("PDC_PRESERVE_SCREEN") != NULL)
+   {
+      bufsize.X = csbi.srWindow.Right - csbi.srWindow.Left + 1;
+      bufsize.Y = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;
+      if ((save_ci = (CHAR_INFO*)malloc(bufsize.X*bufsize.Y*sizeof(CHAR_INFO))) == NULL)
+         return(ERR);
+
+      origin.X = origin.Y = 0;
+
+      rect.Top = csbi.srWindow.Top;
+      rect.Left = csbi.srWindow.Left;
+      rect.Bottom = csbi.srWindow.Bottom;
+      rect.Right = csbi.srWindow.Right;
+      if (!ReadConsoleOutput(hConOut,save_ci,bufsize,origin,&rect))
+      {
+         free(save_ci);
+         save_ci = NULL;
+         return(ERR);
+      }
+      internal->_preserve = TRUE;
+   }
+   else
+      internal->_preserve = FALSE;
+
+   bufsize.X = orig_scr.srWindow.Right - orig_scr.srWindow.Left + 1;
+   bufsize.Y = orig_scr.srWindow.Bottom - orig_scr.srWindow.Top + 1;
+   rect.Top = rect.Left = 0;
+   rect.Bottom = bufsize.Y - 1;
+   rect.Right = bufsize.X - 1;
+
+   SetConsoleScreenBufferSize(hConOut, bufsize);
+   SetConsoleWindowInfo(hConOut,TRUE,&rect);
+   SetConsoleScreenBufferSize(hConOut, bufsize);
+   SetConsoleActiveScreenBuffer(hConOut);
+
+   PDC_reset_prog_mode();
+
+   GetNumberOfConsoleMouseButtons((LPDWORD)&numbuttons);
+   internal->num_mouse_buttons = (int)numbuttons;
+
+   PDC_get_cursor_pos(&internal->cursrow, &internal->curscol);
+   internal->direct_video  = TRUE; /* Assume that we can      */
+   internal->autocr  = TRUE;     /* lf -> crlf by default     */
+   internal->raw_out = FALSE; /* tty I/O modes       */
+   internal->raw_inp = FALSE; /* tty I/O modes       */
+   internal->cbreak  = TRUE;
+   internal->save_key_modifiers  = FALSE;
+   internal->return_key_modifiers   = FALSE;
+   internal->echo = echo;
+   /* under System V Curses, typeahead checking is enabled by default */
+   internal->refrbrk = TRUE;  /* allow premature end of refresh*/
+   internal->video_seg  = 0xb000;   /* Base screen segment addr   */
+   internal->video_ofs  = 0x0;      /* Base screen segment ofs    */
+   internal->video_page = 0;     /* Current Video Page         */
+   internal->visible_cursor= TRUE;  /* Assume that it is visible  */
+   internal->cursor  = PDC_get_cursor_mode();
+
+   internal->adapter = PDC_query_adapter_type();
+   internal->scrnmode   = PDC_get_scrn_mode();
+
+   internal->audible = TRUE;
+   internal->visibility = 1;
+   internal->orig_cursor = internal->cursor;
+   internal->orgcbr = PDC_get_ctrl_break();
+   internal->blank = ' ';
+   internal->resized = FALSE;
+   internal->shell = FALSE;
+   internal->_trap_mbe = 0L;
+   internal->_map_mbe_to_key = 0L;
+   internal->linesrippedoff = 0;
+   internal->linesrippedoffontop = 0;
+   internal->delaytenths = 0;
+#if defined(PDC_THREAD_BUILD)
+   /*
+    * Create the anonymous pipe and thread for handling input
+    */
+   if ( !CreatePipe( &hPipeRead,     // reading handle
+                     &hPipeWrite,    // writing handle
+                     NULL,           // handles not inherited
+                     0 ) )           // default buffer size
+   {
+      // error during pipe creation
+      fprintf( stderr, "Cannot create input pipe\n" );
+      return( ERR );
+   }
+   hThread = CreateThread( NULL,              // security attributes
+                           0,                 // initial stack size
+                           (LPTHREAD_START_ROUTINE) InputThread,
+                           NULL,              // argument
+                           CREATE_SUSPENDED,  // creation flag
+                           &dwThreadID );     // new thread ID
+   if ( ! hThread )
+   {
+      fprintf( stderr, "Cannot create input thread\n" );
+      return( ERR );
+   }
+   ResumeThread( hThread );
+#endif
+
+   return( OK );
+}
+
+static BOOL FitConsoleWindow(HANDLE hConOut, CONST SMALL_RECT *rect)
+/* Calls SetConsoleWindowInfo with the given parameters but fits them if a
+ * scoll bar shrinks the maximum possible value. The rectangle must at least
+ * fit in a half-sized window.
+ */
+{
+ SMALL_RECT run;
+ SHORT mx, my;
+
+   if (SetConsoleWindowInfo(hConOut, TRUE, rect))
+      return(TRUE);
+
+   run = *rect;
+   run.Right /= 2;
+   run.Bottom /= 2;
+   mx = run.Right;
+   my = run.Bottom;
+
+   if (!SetConsoleWindowInfo(hConOut, TRUE, &run))
+      return(FALSE);
+   for (run.Right = rect->Right;run.Right >= mx;run.Right--)
+   {
+      if (SetConsoleWindowInfo(hConOut, TRUE, &run))
+         break;
+   }
+   if (run.Right < mx)
+      return(FALSE);
+   for (run.Bottom = rect->Bottom;run.Bottom >= my;run.Bottom--)
+   {
+      if (SetConsoleWindowInfo(hConOut, TRUE, &run))
+         return(TRUE);
+   }
+   return(FALSE);
+}
+
+/*man-start*********************************************************************
+
+  PDC_resize_screen()   - Internal low-level function to resize screen
+
+  PDCurses Description:
+   This function provides a means for the application program to
+   resize the overall dimensions of the screen.  Under DOS and OS/2
+   the application can tell PDCurses what size to make the screen;
+   under X11, resizing is done by the user and this function simply
+   adjusts its internal structures to fit the new size.
+   This function doesn't set LINES, COLS, PDC_SP->lines or PDC_SP->cols. This
+   must be done by resize_term.
+   If both arguments are 0 the function returns sucessfully. This
+   allows the calling routine to reset the PDC_SP->resized flag.
+   The functions fails if one of the arguments is less then 2.
+
+  PDCurses Return Value:
+   This function returns OK on success, otherwise an ERR is returned.
+
+  PDCurses Errors:
+
+  Portability:
+   PDCurses int   PDC_resize_screen( int, int );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_resize_screen(int nlines, int ncols)
+#else
+int   PDC_resize_screen(nlines, ncols)
+int nlines,ncols;
+#endif
+/***********************************************************************/
+{
+#ifdef FGC0
+   COORD size, max;
+   SMALL_RECT rect;
+   CONSOLE_SCREEN_BUFFER_INFO csbi;
+   int external_resized = PDC_SP->resized;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_resize_screen() - called. Lines: %d Cols: %d\n",nlines,ncols);
+#endif
+   PDC_SP->resized = FALSE; /* prevent endless loops in case of errors */
+   
+   if (nlines == 0 
+   && ncols == 0)
+      return(OK); /* undocumented feature: let assign LINES and COLS
+                          to current values by the calling
+                          resize_term-function */
+
+   if (nlines < 2 || ncols < 2)
+      return(ERR);
+
+   if (!GetConsoleScreenBufferInfo(hConOut,&csbi)) /*needed for recovery*/
+      return(ERR);
+   max = GetLargestConsoleWindowSize(hConOut);
+   
+   size.X = ncols;
+   size.Y = nlines;
+   
+   /* Fit window into allowed values */
+   rect.Left = rect.Top = 0;
+   rect.Right = ncols - 1;
+   if (rect.Right >= max.X)
+      rect.Right = max.X;
+   rect.Bottom = rect.Top + nlines - 1;
+   if (rect.Bottom >= max.Y)
+      rect.Bottom = max.Y;
+   FitConsoleWindow(hConOut, &rect); /* helps to allow the BufferSize */
+   if (!SetConsoleScreenBufferSize(hConOut, size) ||
+       !FitConsoleWindow(hConOut, &rect))
+   {
+      SetConsoleScreenBufferSize(hConOut, csbi.dwSize);
+      SetConsoleWindowInfo(hConOut, TRUE, &csbi.srWindow);
+      return( (external_resized) ? OK : ERR );
+   }
+   
+   SetConsoleActiveScreenBuffer(hConOut);
+   return ( OK );
+#else
+   int rc=OK;
+   COORD size;
+   SMALL_RECT rect;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_resize_screen() - called. Lines: %d Cols: %d\n",nlines,ncols);
+#endif
+
+   if (nlines < 2)
+      return(ERR);
+   PDC_SP->lines = LINES = nlines;
+
+   if (ncols < 2)
+      return(ERR);
+   PDC_SP->cols = COLS = ncols;
+
+   size.X = PDC_SP->cols;
+   size.Y = PDC_SP->lines;
+   rect.Top = rect.Left = 0;
+   rect.Bottom = PDC_SP->lines - 1;
+   rect.Right = PDC_SP->cols - 1;
+   SetConsoleScreenBufferSize(hConOut, size);
+   SetConsoleWindowInfo(hConOut,TRUE,&rect);
+   SetConsoleScreenBufferSize(hConOut, size);
+   SetConsoleWindowInfo(hConOut,TRUE,&rect);
+   SetConsoleActiveScreenBuffer(hConOut);
+   PDC_SP->resized = FALSE;
+   return ( rc );
+#endif
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_reset_prog_mode(void)
+#else
+int   PDC_reset_prog_mode()
+#endif
+/***********************************************************************/
+{
+   SetConsoleMode(hConIn, ENABLE_MOUSE_INPUT | ENABLE_WINDOW_INPUT);
+   return(OK);
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_reset_shell_mode(void)
+#else
+int   PDC_reset_shell_mode()
+#endif
+/***********************************************************************/
+{
+   SetConsoleMode(hConIn, dwConsoleMode);
+   return(OK);
+}
+
+#if !defined(PDC_STATIC_BUILD)
+BOOL WINAPI DllMain( HINSTANCE hDLL, DWORD dwReason, LPVOID pReserved)
+{
+   switch( dwReason)
+   {
+      case DLL_PROCESS_ATTACH:
+/*         fprintf(stderr,"DLL_PROCESS_ATTACH\n"); */
+         break;
+      case DLL_PROCESS_DETACH:
+/*         fprintf(stderr,"DLL_PROCESS_DETACH\n"); */
+         break;
+      case DLL_THREAD_ATTACH:
+/*         fprintf(stderr,"DLL_THREAD_ATTACH\n"); */
+         break;
+      case DLL_THREAD_DETACH:
+/*         fprintf(stderr,"DLL_THREAD_DETACH\n"); */
+         break;
+   }
+   return(TRUE);
+}
+#endif
Index: PDCurses/win32/pdcgetsc.c
===================================================================
--- PDCurses/win32/pdcgetsc.c	(revision 1)
+++ PDCurses/win32/pdcgetsc.c	(working copy)
@@ -1,421 +1,421 @@
-/*
-***************************************************************************
-* This file comprises part of PDCurses. PDCurses is Public Domain software.
-* You may use this code for whatever purposes you desire. This software
-* is provided AS IS with NO WARRANTY whatsoever.
-* Should this software be used in another application, an acknowledgement
-* that PDCurses code is used would be appreciated, but is not mandatory.
-*
-* Any changes which you make to this software which may improve or enhance
-* it, should be forwarded to the current maintainer for the benefit of 
-* other users.
-*
-* The only restriction placed on this code is that no distribution of
-* modified PDCurses code be made under the PDCurses name, by anyone
-* other than the current maintainer.
-* 
-* See the file maintain.er for details of the current maintainer.
-***************************************************************************
-*/
-#define	CURSES_LIBRARY	1
-#define	INCLUDE_WINDOWS_H
-#include <curses.h>
-
-#ifdef PDCDEBUG
-char *rcsid_PDCgetsc  = "$Id: pdcgetsc.c,v 1.1 2001/01/10 08:30:48 mark Exp $";
-#endif
-
-extern HANDLE hConOut, hConIn;
-extern CONSOLE_SCREEN_BUFFER_INFO scr;
-
-/*man-start*********************************************************************
-
-  PDC_get_cursor_pos()	- return current cursor position
-
-  PDCurses Description:
- 	This is a private PDCurses function
-
- 	Gets the cursor position in video page 0.  'row' and 'column'
- 	are the cursor address.  At this time, there is no support for
- 	use of multiple screen pages.
-
-  PDCurses Return Value:
- 	This routine will return OK upon success and otherwise ERR will be
- 	returned.
-
-  PDCurses Errors:
- 	There are no defined errors for this routine.
-
-  Portability:
- 	PDCurses	int	PDC_get_cursor_pos( int* row, int* col );
-
-**man-end**********************************************************************/
-
-int	PDC_get_cursor_pos(int *row, int *col)
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_get_cursor_pos() - called\n");
-#endif
-
-   GetConsoleScreenBufferInfo(hConOut, &scr);
-   *col = scr.dwCursorPosition.X;
-   *row = scr.dwCursorPosition.Y;
-   return(OK);
-}
-
-/*man-start*********************************************************************
-
-  PDC_get_cur_col()	- get current column position of cursor
-
-  PDCurses Description:
- 	This is a private PDCurses function
-
- 	This routine returns the current column position of the cursor on
- 	screen.
-
-  PDCurses Return Value:
- 	This routine returns the current column position of the cursor. No
- 	error is returned.
-
-  PDCurses Errors:
- 	There are no defined errors for this routine.
-
-  Portability:
- 	PDCurses	int	PDC_get_cur_col( void );
-
-**man-end**********************************************************************/
-
-int	PDC_get_cur_col(void)
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_get_cur_col() - called\n");
-#endif
-
-   GetConsoleScreenBufferInfo(hConOut, &scr);
-   return (scr.dwCursorPosition.X);
-}
-
-/*man-start*********************************************************************
-
-  PDC_get_cur_row()	- get current row position of cursor
-
-  PDCurses Description:
- 	This is a private PDCurses function
-
- 	This routine returns the current row position of the cursor on
- 	screen.
-
-  PDCurses Return Value:
- 	This routine returns the current row position of the cursor. No
- 	error is returned.
-
-  PDCurses Errors:
- 	There are no defined errors for this routine.
-
-  Portability:
- 	PDCurses	int	PDC_get_cur_row( void );
-
-**man-end**********************************************************************/
-
-int	PDC_get_cur_row(void)
-{
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_get_cur_row() - called\n");
-#endif
-
-   GetConsoleScreenBufferInfo(hConOut, &scr);
-   return (scr.dwCursorPosition.Y);
-}
-
-// Stopped Here...
-
-/*man-start*********************************************************************
-
-  PDC_get_attribute()	- Get attribute at current cursor
-
-  PDCurses Description:
- 	This is a private PDCurses function
-
- 	Return the current attr at current cursor position on the screen.
-
-  PDCurses Return Value:
- 	This routine will return OK upon success and otherwise ERR will be
- 	returned.
-
-  PDCurses Errors:
- 	There are no defined errors for this routine.
-
-  Portability:
- 	PDCurses	int	PDC_get_attribute( void );
-
-**man-end**********************************************************************/
-
-int	PDC_get_attribute(void)
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_get_attribute() - called\n");
-#endif
-/* doesnt do anything !! */
-	return(0);
-}
-
-/*man-start*********************************************************************
-
-  PDC_get_cursor_mode()	- Get the cursor start and stop scan lines.
-
-  PDCurses Description:
- 	Gets the cursor type to begin in scan line startrow and end in
- 	scan line endrow.  Both values should be 0-31.
-
-  PDCurses Return Value:
- 	This function returns OK on success and ERR on error.
-
-  PDCurses Errors:
- 	No errors are defined for this function.
-
-  Portability:
- 	PDCurses	int PDC_get_cursor_mode( void );
-
-**man-end**********************************************************************/
-
-int	PDC_get_cursor_mode(void)
-{
- CONSOLE_CURSOR_INFO ci;
-    
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_get_cursor_mode() - called\n");
-#endif
-
- GetConsoleCursorInfo(hConOut, &ci);
-/* size is between 1 and 100, so convert it */
- return ((ci.dwSize * 32 / 100) - 1);
-}
-
-/*man-start*********************************************************************
-
-  PDC_get_font()	- Get the current font size
-
-  PDCurses Description:
- 	This is a private PDCurses routine.
-
- 	This function returns the current font size.  This function only
- 	works if the #define FAST_VIDEO is true.
-
-  PDCurses Return Value:
- 	This function returns OK on success and ERR on error.
-
-  PDCurses Errors:
- 	An ERR will be returned if FAST_VIDEO is not true.
-
-  Portability:
- 	PDCurses	int PDC_get_font( void );
-
-**man-end**********************************************************************/
-
-int	PDC_get_font(void)
-{
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_get_font() - called\n");
-#endif
-
-	return(0); /* this is N/A */
-}
-
-/*man-start*********************************************************************
-
-  PDC_get_rows()	- Return number of screen rows.
-
-  PDCurses Description:
- 	This is a private PDCurses routine.
-
- 	Returns the maximum number of rows supported by the display.
- 	e.g.  25, 28, 43, 50, 60, 66...
-
-  PDCurses Return Value:
- 	This function returns OK on success and ERR on error.
-
-  PDCurses Errors:
- 	No errors are defined for this function.
-
-  Portability:
- 	PDCurses	int PDC_get_rows( void );
-
-**man-end**********************************************************************/
-
-int	PDC_get_rows(void)
-{
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_get_rows() - called\n");
-#endif
-
-   GetConsoleScreenBufferInfo(hConOut, &scr);
-#if FGC0
-   return ( scr.dwSize.Y ); /* Allow the whole screen to be accessed */
-#else
-   return (scr.srWindow.Bottom - scr.srWindow.Top + 1);
-#endif
-}
-
-/*man-start*********************************************************************
-
-  PDC_get_buffer_rows()	- Return number of screen buffer rows.
-
-  PDCurses Description:
- 	This is a private PDCurses routine.
-
-  PDCurses Return Value:
- 	Returns the maximum number of rows in the screen buffer.
-
-  PDCurses Errors:
- 	No errors are defined for this function.
-
-  Portability:
- 	PDCurses	int PDC_get_buffer_rows( void );
-
-**man-end**********************************************************************/
-
-int	PDC_get_buffer_rows(void)
-{
-
-#ifdef PDCDEBUG
-   if (trace_on) PDC_debug("PDC_get_buffer_rows() - called\n");
-#endif
-
-   GetConsoleScreenBufferInfo( hConOut, &scr );
-   return ( scr.dwSize.Y );
-}
-
-/*man-start*********************************************************************
-
-  PDC_get_columns()	- return width of screen/viewport.
-
-  PDCurses Description:
- 	This is a private PDCurses function
-
- 	This function will return the width of the current screen.
-
-  PDCurses Return Value:
- 	This routine will return OK upon success and otherwise ERR will be
- 	returned.
-
-  PDCurses Errors:
- 	There are no defined errors for this routine.
-
-  Portability:
- 	PDCurses	int	PDC_get_columns( void );
-
-**man-end**********************************************************************/
-
-int	PDC_get_columns(void)
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_get_columns() - called\n");
-#endif
-
-   GetConsoleScreenBufferInfo(hConOut, &scr);
-#if FGC0
-   return ( scr.dwSize.X ); /* Allow the whole screen to be accessed */
-#else
-   return (scr.srWindow.Right - scr.srWindow.Left + 1);
-#endif
-}
-
-/*man-start*********************************************************************
-
-  PDC_get_scrn_mode()	- Return the current BIOS video mode
-
-  PDCurses Description:
- 	This is a private PDCurses routine.
-
-
-  PDCurses Return Value:
- 	Returns the current BIOS Video Mode Number.
-
-  PDCurses Errors:
- 	The FLEXOS version of this routine returns an ERR.
- 	The UNIX version of this routine returns an ERR.
- 	The EMXVIDEO version of this routine returns an ERR.
-
-  Portability:
- 	PDCurses	int PDC_get_scrn_mode( void );
-
-**man-end**********************************************************************/
-
-int	PDC_get_scrn_mode(void)
-{
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_get_scrn_mode() - called\n");
-#endif
-	return(OK);
-}
-
-/*man-start*********************************************************************
-
-  PDC_query_adapter_type()	- Determine PC video adapter type
-
-  PDCurses Description:
- 	This is a private PDCurses routine.
-
- 	Thanks to Jeff Duntemann, K16RA for providing the impetus
- 	(through the Dr. Dobbs Journal, March 1989 issue) for getting
- 	the routines below merged into Bjorn Larsson's PDCurses 1.3...
- 		-- frotz@dri.com	900730
-
-  PDCurses Return Value:
- 	This function returns a macro identifier indicating the adapter
- 	type.  See the list of adapter types in CURSPRIV.H.
-
-  PDCurses Errors:
- 	No errors are defined for this function.
-
-  Portability:
- 	PDCurses	int PDC_query_adapter_type( void );
-
-**man-end**********************************************************************/
-
-int	PDC_query_adapter_type(void)
-{
-	int	retval = _NONE;
-
-#ifdef PDCDEBUG
-	if (trace_on) PDC_debug("PDC_query_adapter_type() - called\n");
-#endif
-
-	SP->mono = FALSE;
-	retval = _VGACOLOR;
-
-	return (retval);
-}
-
-/*man-start*********************************************************************
-
-  PDC_sanity_check() - A video adapter identification sanity check
-
-  PDCurses Description:
- 	This is a private PDCurses routine.
-
- 	This routine will force sane values for various control flags.
-
-  PDCurses Return Value:
- 	This function returns OK on success and ERR on error.
-
-  PDCurses Errors:
- 	No errors are defined for this function.
-
-  Portability:
- 	PDCurses	int PDC_sanity_check( int adapter );
-
-**man-end**********************************************************************/
-
-int	PDC_sanity_check(int adapter)
-{
-#ifdef PDCDEBUG
-   if (trace_on) 
-      PDC_debug("PDC_sanity_check() - called: Adapter %d\n",adapter);
-#endif
-
-   return (adapter);
-}
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#define	INCLUDE_WINDOWS_H
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCgetsc  = "$Id: pdcgetsc.c,v 1.1 2001/01/10 08:30:48 mark Exp $";
+#endif
+
+extern HANDLE hConOut, hConIn;
+extern CONSOLE_SCREEN_BUFFER_INFO scr;
+
+/*man-start*********************************************************************
+
+  PDC_get_cursor_pos()	- return current cursor position
+
+  PDCurses Description:
+ 	This is a private PDCurses function
+
+ 	Gets the cursor position in video page 0.  'row' and 'column'
+ 	are the cursor address.  At this time, there is no support for
+ 	use of multiple screen pages.
+
+  PDCurses Return Value:
+ 	This routine will return OK upon success and otherwise ERR will be
+ 	returned.
+
+  PDCurses Errors:
+ 	There are no defined errors for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_get_cursor_pos( int* row, int* col );
+
+**man-end**********************************************************************/
+
+int	PDC_get_cursor_pos(int *row, int *col)
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_cursor_pos() - called\n");
+#endif
+
+   GetConsoleScreenBufferInfo(hConOut, &scr);
+   *col = scr.dwCursorPosition.X;
+   *row = scr.dwCursorPosition.Y;
+   return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_cur_col()	- get current column position of cursor
+
+  PDCurses Description:
+ 	This is a private PDCurses function
+
+ 	This routine returns the current column position of the cursor on
+ 	screen.
+
+  PDCurses Return Value:
+ 	This routine returns the current column position of the cursor. No
+ 	error is returned.
+
+  PDCurses Errors:
+ 	There are no defined errors for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_get_cur_col( void );
+
+**man-end**********************************************************************/
+
+int	PDC_get_cur_col(void)
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_cur_col() - called\n");
+#endif
+
+   GetConsoleScreenBufferInfo(hConOut, &scr);
+   return (scr.dwCursorPosition.X);
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_cur_row()	- get current row position of cursor
+
+  PDCurses Description:
+ 	This is a private PDCurses function
+
+ 	This routine returns the current row position of the cursor on
+ 	screen.
+
+  PDCurses Return Value:
+ 	This routine returns the current row position of the cursor. No
+ 	error is returned.
+
+  PDCurses Errors:
+ 	There are no defined errors for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_get_cur_row( void );
+
+**man-end**********************************************************************/
+
+int	PDC_get_cur_row(void)
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_cur_row() - called\n");
+#endif
+
+   GetConsoleScreenBufferInfo(hConOut, &scr);
+   return (scr.dwCursorPosition.Y);
+}
+
+// Stopped Here...
+
+/*man-start*********************************************************************
+
+  PDC_get_attribute()	- Get attribute at current cursor
+
+  PDCurses Description:
+ 	This is a private PDCurses function
+
+ 	Return the current attr at current cursor position on the screen.
+
+  PDCurses Return Value:
+ 	This routine will return OK upon success and otherwise ERR will be
+ 	returned.
+
+  PDCurses Errors:
+ 	There are no defined errors for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_get_attribute( void );
+
+**man-end**********************************************************************/
+
+int	PDC_get_attribute(void)
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_attribute() - called\n");
+#endif
+/* doesnt do anything !! */
+	return(0);
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_cursor_mode()	- Get the cursor start and stop scan lines.
+
+  PDCurses Description:
+ 	Gets the cursor type to begin in scan line startrow and end in
+ 	scan line endrow.  Both values should be 0-31.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_get_cursor_mode( void );
+
+**man-end**********************************************************************/
+
+int	PDC_get_cursor_mode(void)
+{
+ CONSOLE_CURSOR_INFO ci;
+    
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_cursor_mode() - called\n");
+#endif
+
+ GetConsoleCursorInfo(hConOut, &ci);
+/* size is between 1 and 100, so convert it */
+ return ((ci.dwSize * 32 / 100) - 1);
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_font()	- Get the current font size
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	This function returns the current font size.  This function only
+ 	works if the #define FAST_VIDEO is true.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	An ERR will be returned if FAST_VIDEO is not true.
+
+  Portability:
+ 	PDCurses	int PDC_get_font( void );
+
+**man-end**********************************************************************/
+
+int	PDC_get_font(void)
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_font() - called\n");
+#endif
+
+	return(0); /* this is N/A */
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_rows()	- Return number of screen rows.
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Returns the maximum number of rows supported by the display.
+ 	e.g.  25, 28, 43, 50, 60, 66...
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_get_rows( void );
+
+**man-end**********************************************************************/
+
+int	PDC_get_rows(void)
+{
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_rows() - called\n");
+#endif
+
+   GetConsoleScreenBufferInfo(hConOut, &scr);
+#if FGC0
+   return ( scr.dwSize.Y ); /* Allow the whole screen to be accessed */
+#else
+   return (scr.srWindow.Bottom - scr.srWindow.Top + 1);
+#endif
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_buffer_rows()	- Return number of screen buffer rows.
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+  PDCurses Return Value:
+ 	Returns the maximum number of rows in the screen buffer.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_get_buffer_rows( void );
+
+**man-end**********************************************************************/
+
+int	PDC_get_buffer_rows(void)
+{
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_buffer_rows() - called\n");
+#endif
+
+   GetConsoleScreenBufferInfo( hConOut, &scr );
+   return ( scr.dwSize.Y );
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_columns()	- return width of screen/viewport.
+
+  PDCurses Description:
+ 	This is a private PDCurses function
+
+ 	This function will return the width of the current screen.
+
+  PDCurses Return Value:
+ 	This routine will return OK upon success and otherwise ERR will be
+ 	returned.
+
+  PDCurses Errors:
+ 	There are no defined errors for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_get_columns( void );
+
+**man-end**********************************************************************/
+
+int	PDC_get_columns(void)
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_columns() - called\n");
+#endif
+
+   GetConsoleScreenBufferInfo(hConOut, &scr);
+#if FGC0
+   return ( scr.dwSize.X ); /* Allow the whole screen to be accessed */
+#else
+   return (scr.srWindow.Right - scr.srWindow.Left + 1);
+#endif
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_scrn_mode()	- Return the current BIOS video mode
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+
+  PDCurses Return Value:
+ 	Returns the current BIOS Video Mode Number.
+
+  PDCurses Errors:
+ 	The FLEXOS version of this routine returns an ERR.
+ 	The UNIX version of this routine returns an ERR.
+ 	The EMXVIDEO version of this routine returns an ERR.
+
+  Portability:
+ 	PDCurses	int PDC_get_scrn_mode( void );
+
+**man-end**********************************************************************/
+
+int	PDC_get_scrn_mode(void)
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_scrn_mode() - called\n");
+#endif
+	return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_query_adapter_type()	- Determine PC video adapter type
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Thanks to Jeff Duntemann, K16RA for providing the impetus
+ 	(through the Dr. Dobbs Journal, March 1989 issue) for getting
+ 	the routines below merged into Bjorn Larsson's PDCurses 1.3...
+ 		-- frotz@dri.com	900730
+
+  PDCurses Return Value:
+ 	This function returns a macro identifier indicating the adapter
+ 	type.  See the list of adapter types in CURSPRIV.H.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_query_adapter_type( void );
+
+**man-end**********************************************************************/
+
+int	PDC_query_adapter_type(void)
+{
+	int	retval = _NONE;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_query_adapter_type() - called\n");
+#endif
+
+	PDC_SP->mono = FALSE;
+	retval = _VGACOLOR;
+
+	return (retval);
+}
+
+/*man-start*********************************************************************
+
+  PDC_sanity_check() - A video adapter identification sanity check
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	This routine will force sane values for various control flags.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_sanity_check( int adapter );
+
+**man-end**********************************************************************/
+
+int	PDC_sanity_check(int adapter)
+{
+#ifdef PDCDEBUG
+   if (trace_on) 
+      PDC_debug("PDC_sanity_check() - called: Adapter %d\n",adapter);
+#endif
+
+   return (adapter);
+}
